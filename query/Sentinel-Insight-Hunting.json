{
    "$schema":  "http://schema.management.azure.com/schemas/2014-04-01-preview/deploymenttemplate.json#",
    "contentversion":  "1.0.0.0",
    "parameters":  {
                       "location":  {
                                        "type":  "string",
                                        "defaultvalue": "chinaeast2"
                                    },
                       "workspacename":  {
                                             "type":  "string"
                                         }
                   },
    "resources":  [
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-High-severity",
                                             "displayName":  "Suspicious application consent similar to O365 Attack Toolkit",
                                             "query":  "//This will alert when a user consents to provide a previously-unknown Azure application with the same OAuth permissions used by the MDSec O365 Attack Toolkit (https://github.com/mdsecactivebreach/o365-attack-toolkit).\n//The default permissions/scope for the MDSec O365 Attack toolkit are contacts.read, user.read, mail.read, notes.read.all, mailboxsettings.readwrite, and files.readwrite.all.\n//Consent to applications with these permissions should be rare, especially as the knownApplications list is expanded, especially as the knownApplications list is expanded. Public contributions to expand this filter are welcome!\n//For further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.\n//\nlet detectionTime = 1d;\nlet joinLookback = 14d;\nAuditLogs\n| where TimeGenerated \u003e ago(detectionTime)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Consent to application\"\n| where TargetResources has \"mailboxsettings\"\n| extend AppDisplayName = TargetResources.[0].displayName\n| extend AppClientId = tolower(TargetResources.[0].id)\n| where AppClientId !in ((externaldata(knownAppClientId:string, knownAppDisplayName:string)[@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Microsoft.OAuth.KnownApplications.csv\"] with (format=\"csv\")))\n| extend ConsentFull = TargetResources[0].modifiedProperties[4].newValue\n| parse ConsentFull with * \"ConsentType: \" GrantConsentType \", Scope: \" GrantScope1 \"]\" *\n| where ConsentFull contains \"contacts.read\" and ConsentFull contains \"user.read\" and ConsentFull contains \"mail.read\" and ConsentFull contains \"notes.read.all\" and ConsentFull contains \"mailboxsettings.readwrite\" and ConsentFull contains \"Files.ReadWrite.All\"\n| where GrantConsentType != \"AllPrincipals\" // NOTE: we are ignoring if OAuth application was granted to all users via an admin - but admin due diligence should be audited occasionally\n| extend GrantIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress)\n| extend GrantInitiatedBy = iff(isnotempty(InitiatedBy.user.userPrincipalName),InitiatedBy.user.userPrincipalName, InitiatedBy.app.displayName)\n| extend GrantUserAgent = iff(AdditionalDetails[0].key =~ \"User-Agent\", AdditionalDetails[0].value, \"\")\n| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, GrantIpAddress, GrantUserAgent, AppClientId, OperationName, ConsentFull, CorrelationId\n| join kind = leftouter (AuditLogs\n| where TimeGenerated \u003e ago(joinLookback)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Add service principal\"\n| extend AppClientId = tolower(TargetResources[0].id)\n| extend AppReplyURLs = iff(TargetResources[0].modifiedProperties[1].newValue has \"AddressType\", TargetResources[0].modifiedProperties[1].newValue, \"\")\n| distinct AppClientId, tostring(AppReplyURLs)\n)\non AppClientId\n| join kind = innerunique (AuditLogs\n| where TimeGenerated \u003e ago(joinLookback)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Add OAuth2PermissionGrant\" or OperationName =~ \"Add delegated permission grant\"\n| extend GrantAuthentication = tostring(TargetResources[0].displayName)\n| extend GrantOperation = OperationName\n| project GrantAuthentication, GrantOperation, CorrelationId\n) on CorrelationId\n| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, AppReplyURLs, GrantIpAddress, GrantUserAgent, AppClientId, GrantAuthentication, OperationName, GrantOperation, CorrelationId, ConsentFull\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_1')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Suspicious application consent similar to PwnAuth",
                                             "query":  "//This will alert when a user consents to provide a previously-unknown Azure application with the same OAuth permissions used by the FireEye PwnAuth toolkit (https://github.com/fireeye/PwnAuth).\n//The default permissions/scope for the PwnAuth toolkit are user.read, offline_access, mail.readwrite, mail.send, and files.read.all.\n//Consent to applications with these permissions should be rare, especially as the knownApplications list is expanded. Public contributions to expand this filter are welcome!\n//For further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.\n//\nlet detectionTime = 1d;\nlet joinLookback = 14d;\nAuditLogs\n| where TimeGenerated \u003e ago(detectionTime)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Consent to application\"\n| where TargetResources has \"offline\"\n| extend AppDisplayName = TargetResources.[0].displayName\n| extend AppClientId = tolower(TargetResources.[0].id)\n| where AppClientId !in ((externaldata(knownAppClientId:string, knownAppDisplayName:string)[@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Microsoft.OAuth.KnownApplications.csv\"] with (format=\"csv\")))\n| extend ConsentFull = TargetResources[0].modifiedProperties[4].newValue\n| parse ConsentFull with * \"ConsentType: \" GrantConsentType \", Scope: \" GrantScope1 \"]\" *\n| where ConsentFull contains \"user.read\" and ConsentFull contains \"offline_access\" and ConsentFull contains \"mail.readwrite\" and ConsentFull contains \"mail.send\" and ConsentFull contains \"files.read.all\"\n| where GrantConsentType != \"AllPrincipals\" // NOTE: we are ignoring if OAuth application was granted to all users via an admin - but admin due diligence should be audited occasionally\n| extend GrantIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress)\n| extend GrantInitiatedBy = iff(isnotempty(InitiatedBy.user.userPrincipalName),InitiatedBy.user.userPrincipalName, InitiatedBy.app.displayName)\n| extend GrantUserAgent = iff(AdditionalDetails[0].key =~ \"User-Agent\", AdditionalDetails[0].value, \"\")\n| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, GrantIpAddress, GrantUserAgent, AppClientId, OperationName, ConsentFull, CorrelationId\n| join kind = leftouter (AuditLogs\n| where TimeGenerated \u003e ago(joinLookback)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Add service principal\"\n| extend AppClientId = tolower(TargetResources[0].id)\n| extend AppReplyURLs = iff(TargetResources[0].modifiedProperties[1].newValue has \"AddressType\", TargetResources[0].modifiedProperties[1].newValue, \"\")\n| distinct AppClientId, tostring(AppReplyURLs)\n)\non AppClientId\n| join kind = innerunique (AuditLogs\n| where TimeGenerated \u003e ago(joinLookback)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Add OAuth2PermissionGrant\" or OperationName =~ \"Add delegated permission grant\"\n| extend GrantAuthentication = tostring(TargetResources[0].displayName)\n| extend GrantOperation = OperationName\n| project GrantAuthentication, GrantOperation, CorrelationId\n) on CorrelationId\n| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, AppReplyURLs, GrantIpAddress, GrantUserAgent, AppClientId, GrantAuthentication, OperationName, GrantOperation, CorrelationId, ConsentFull\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_2')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Rare application consent",
                                             "query":  "//This will alert when the \"Consent to application\" operation occurs by a user that has not done this operation before or rarely does this.\n//This could indicate that permissions to access the listed Azure App were provided to a malicious actor. \n//Consent to application, Add service principal and Add OAuth2PermissionGrant should typically be rare events. \n//This may help detect the Oauth2 attack that can be initiated by this publicly available tool - https://github.com/fireeye/PwnAuth\n//For further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.\n//\n\nlet current = 1d;\nlet auditLookback = 7d;\n// Setting threshold to 3 as a default, change as needed.  \n// Any operation that has been initiated by a user or app more than 3 times in the past 7 days will be excluded\nlet threshold = 3;\n// Gather initial data from lookback period, excluding current, adjust current to more than a single day if no results\nlet AuditTrail = AuditLogs | where TimeGenerated \u003e= ago(auditLookback) and TimeGenerated \u003c ago(current)\n// 2 other operations that can be part of malicious activity in this situation are \n// \"Add OAuth2PermissionGrant\" and \"Add service principal\", extend the filter below to capture these too\n| where OperationName == \"Consent to application\"\n| extend InitiatedBy = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), \ntostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))\n| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))\n| summarize max(TimeGenerated), OperationCount = count() by OperationName, InitiatedBy, TargetResourceName\n// only including operations by initiated by a user or app that is above the threshold so we produce only rare and has not occurred in last 7 days\n| where OperationCount \u003e threshold\n;\n// Gather current period of audit data\nlet RecentConsent = AuditLogs | where TimeGenerated \u003e= ago(current)\n| where OperationName == \"Consent to application\"\n| extend IpAddress = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)), \ntostring(parse_json(tostring(InitiatedBy.user)).ipAddress), tostring(parse_json(tostring(InitiatedBy.app)).ipAddress))\n| extend InitiatedBy = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), \ntostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))\n| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))\n| parse TargetResources.[0].modifiedProperties with * \"ConsentType: \" ConsentType \"]\" *\n| project TimeGenerated, InitiatedBy, IpAddress, TargetResourceName, Category, OperationName, ConsentType , CorrelationId, Type;\n// Exclude previously seen audit activity for \"Consent to application\" that was seen in the lookback period\n// First for rare InitiatedBy\nlet RareConsentBy = RecentConsent | join kind= leftanti AuditTrail on OperationName, InitiatedBy \n| extend Reason = \"Previously unseen user consenting\";\n// Second for rare TargetResourceName\nlet RareConsentApp = RecentConsent | join kind= leftanti AuditTrail on OperationName, TargetResourceName\n| extend Reason = \"Previously unseen app granted consent\";\nRareConsentBy | union RareConsentApp\n| summarize Reason = makeset(Reason) by TimeGenerated, InitiatedBy, IpAddress, TargetResourceName, Category, OperationName, ConsentType, CorrelationId, Type\n| extend timestamp = TimeGenerated, AccountCustomEntity = InitiatedBy, HostCustomEntity = TargetResourceName, IPCustomEntity = IpAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_3')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "Suspicious application consent for offline access",
                                             "query":  "//This will alert when a user consents to provide a previously-unknown Azure application with offline access via OAuth.\n//Offline access will provide the Azure App with access to the listed resources without requiring two-factor authentication.\n//Consent to applications with offline access and read capabilities should be rare, especially as the knownApplications list is expanded. Public contributions to expand this filter are welcome!\n//For further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.\n//\nlet detectionTime = 1d;\nlet joinLookback = 14d;\nAuditLogs\n| where TimeGenerated \u003e ago(detectionTime)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Consent to application\"\n| where TargetResources has \"offline\"\n| extend AppDisplayName = TargetResources.[0].displayName\n| extend AppClientId = tolower(TargetResources.[0].id)\n| where AppClientId !in ((externaldata(knownAppClientId:string, knownAppDisplayName:string)[@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Microsoft.OAuth.KnownApplications.csv\"] with (format=\"csv\")))\n| extend ConsentFull = TargetResources[0].modifiedProperties[4].newValue\n| parse ConsentFull with * \"ConsentType: \" GrantConsentType \", Scope: \" GrantScope1 \"]\" *\n| where ConsentFull contains \"offline_access\" and ConsentFull contains \"Files.Read\" or ConsentFull contains \"Mail.Read\" or ConsentFull contains \"Notes.Read\" or ConsentFull contains \"ChannelMessage.Read\" or ConsentFull contains \"Chat.Read\" or ConsentFull contains \"TeamsActivity.Read\" or ConsentFull contains \"Group.Read\" or ConsentFull contains \"EWS.AccessAsUser.All\" or ConsentFull contains \"EAS.AccessAsUser.All\"\n| where GrantConsentType != \"AllPrincipals\" // NOTE: we are ignoring if OAuth application was granted to all users via an admin - but admin due diligence should be audited occasionally\n| extend GrantIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress)\n| extend GrantInitiatedBy = iff(isnotempty(InitiatedBy.user.userPrincipalName),InitiatedBy.user.userPrincipalName, InitiatedBy.app.displayName)\n| extend GrantUserAgent = iff(AdditionalDetails[0].key =~ \"User-Agent\", AdditionalDetails[0].value, \"\")\n| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, GrantIpAddress, GrantUserAgent, AppClientId, OperationName, ConsentFull, CorrelationId\n| join kind = leftouter (AuditLogs\n| where TimeGenerated \u003e ago(joinLookback)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Add service principal\"\n| extend AppClientId = tolower(TargetResources[0].id)\n| extend AppReplyURLs = iff(TargetResources[0].modifiedProperties[1].newValue has \"AddressType\", TargetResources[0].modifiedProperties[1].newValue, \"\")\n| distinct AppClientId, tostring(AppReplyURLs)\n)\non AppClientId\n| join kind = innerunique (AuditLogs\n| where TimeGenerated \u003e ago(joinLookback)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Add OAuth2PermissionGrant\" or OperationName =~ \"Add delegated permission grant\"\n| extend GrantAuthentication = tostring(TargetResources[0].displayName)\n| extend GrantOperation = OperationName\n| project GrantAuthentication, GrantOperation, CorrelationId\n) on CorrelationId\n| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, AppReplyURLs, GrantIpAddress, GrantUserAgent, AppClientId, GrantAuthentication, OperationName, GrantOperation, CorrelationId, ConsentFull\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_4')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "User added to Azure Active Directory Privileged Groups",
                                             "query":  "//This will alert when a user is added to any of the Privileged Groups.\n//For further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.\n//For Administrator role permissions in Azure Active Directory please see https://docs.microsoft.com/azure/active-directory/users-groups-roles/directory-assign-admin-roles\n//\nlet timeframe = 1h;\nlet OperationList = dynamic([\"Add member to role\",\"Add member to role in PIM requested (permanent)\"]);\nlet PrivilegedGroups = dynamic([\"UserAccountAdmins\",\"PrivilegedRoleAdmins\",\"TenantAdmins\"]);\nAuditLogs\n| where TimeGenerated \u003e= ago(timeframe)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"RoleManagement\"\n| where OperationName in~ (OperationList)\n| mv-expand TargetResources\n| extend modifiedProperties = parse_json(TargetResources).modifiedProperties\n| mv-expand modifiedProperties\n| extend DisplayName = tostring(parse_json(modifiedProperties).displayName), GroupName =  trim(@'\"',tostring(parse_json(modifiedProperties).newValue))\n| extend AppId = tostring(parse_json(parse_json(InitiatedBy).app).appId), InitiatedByDisplayName = tostring(parse_json(parse_json(InitiatedBy).app).displayName), ServicePrincipalId = tostring(parse_json(parse_json(InitiatedBy).app).servicePrincipalId), ServicePrincipalName = tostring(parse_json(parse_json(InitiatedBy).app).servicePrincipalName)\n| where DisplayName =~ \"Role.WellKnownObjectName\"\n| where GroupName in~ (PrivilegedGroups)\n// If you want to still alert for operations from PIM, remove below filtering for MS-PIM.\n| where InitiatedByDisplayName != \"MS-PIM\"\n| project TimeGenerated, AADOperationType, Category, OperationName, AADTenantId, AppId, InitiatedByDisplayName, ServicePrincipalId, ServicePrincipalName, DisplayName, GroupName\n| extend timestamp = TimeGenerated, AccountCustomEntity = ServicePrincipalName\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_5')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Suspicious number of resource creation or deployment activities",
                                             "query":  "//Indicates when an anomalous number of VM creations or deployment activities occur in Azure via the AzureActivity log.\n//The anomaly detection identifies activities that have occured both since the start of the day 1 day ago and the start of the day 7 days ago.\n//The start of the day is considered 12am UTC time.\n//\n\nlet szOperationNames = dynamic([\"Create or Update Virtual Machine\", \"Create Deployment\"]);\nlet starttime = 7d;\nlet endtime = 1d;\nAzureActivity\n| where TimeGenerated between (startofday(ago(starttime)) .. startofday(ago(endtime)))\n| where OperationName in~ (szOperationNames)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ActivityTimeStamp = makelist(TimeGenerated), ActivityStatus = makelist(ActivityStatus), \nOperationIds = makelist(OperationId), CallerIpAddress = makelist(CallerIpAddress), CorrelationId = makelist(CorrelationId) \nby ResourceId, Caller, OperationName, Resource, ResourceGroup\n| mvexpand CallerIpAddress\n| where isnotempty(CallerIpAddress)\n| make-series dResourceCount=dcount(ResourceId)  default=0 on StartTimeUtc in range(startofday(ago(7d)), now(), 1d) \nby Caller, tostring(ActivityTimeStamp), tostring(ActivityStatus), tostring(OperationIds), tostring(CallerIpAddress), tostring(CorrelationId), ResourceId, OperationName, Resource, ResourceGroup\n| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dResourceCount)\n| where Slope \u003e 0.2\n| join kind=leftsemi (\n// Last day's activity is anomalous\nAzureActivity\n| where TimeGenerated \u003e= startofday(ago(endtime))\n| where OperationName in~ (szOperationNames)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ActivityTimeStamp = makelist(TimeGenerated), ActivityStatus = makelist(ActivityStatus), \nOperationIds = makelist(OperationId), CallerIpAddress = makelist(CallerIpAddress), CorrelationId = makelist(CorrelationId) \nby ResourceId, Caller, OperationName, Resource, ResourceGroup\n| mvexpand CallerIpAddress\n| where isnotempty(CallerIpAddress)\n| make-series dResourceCount=dcount(ResourceId)  default=0 on StartTimeUtc in range(startofday(ago(1d)), now(), 1d) \nby Caller, tostring(ActivityTimeStamp), tostring(ActivityStatus), tostring(OperationIds), tostring(CallerIpAddress), tostring(CorrelationId), ResourceId, OperationName, Resource, ResourceGroup\n| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dResourceCount)\n| where Slope \u003e 0.2    \n) on Caller, CallerIpAddress        \n| mvexpand todynamic(ActivityTimeStamp), todynamic(ActivityStatus), todynamic(OperationIds), todynamic(CorrelationId)\n| extend timestamp = ActivityTimeStamp, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_6')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection--severity",
                                             "displayName":  "Creation of expensive computes in Azure",
                                             "query":  "//Identifies the creation of large size/expensive VMs (GPU or with large no of virtual CPUs) in Azure.\n//Adversary may create new or update existing virtual machines sizes to evade defenses \n//or use it for cryptomining purposes.\n//For Windows/Linux Vm Sizes - https://docs.microsoft.com/azure/virtual-machines/windows/sizes \n//Azure VM Naming Conventions - https://docs.microsoft.com/azure/virtual-machines/vm-naming-conventions\n//\nlet timeframe = 1d;\nlet tokens = dynamic([\"416\",\"208\",\"128\",\"120\",\"96\",\"80\",\"72\",\"64\",\"48\",\"44\",\"40\",\"g5\",\"gs5\",\"g4\",\"gs4\",\"nc12\",\"nc24\",\"nv12\"]);\nlet operationList = dynamic([\"Create or Update Virtual Machine\", \"Create Deployment\"]);\nAzureActivity\n| where TimeGenerated \u003e= ago(timeframe)\n| where OperationName in (operationList)\n| where ActivityStatus == \"Accepted\" \n| where isnotempty(Properties)\n| extend vmSize = tolower(tostring(parse_json(tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).hardwareProfile)).vmSize))\n| where isnotempty(vmSize)\n| where vmSize has_any (tokens) \n| extend ComputerName = tostring(parse_json(tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).osProfile)).computerName)\n| extend clientIpAddress = tostring(parse_json(HTTPRequest).clientIpAddress)\n| project TimeGenerated, OperationName, ActivityStatus, Caller, CallerIpAddress, ComputerName, vmSize\n| extend timestamp = TimeGenerated, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_7')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Suspicious granting of permissions to an account",
                                             "query":  "//Identifies IPs from which users grant access to other users on azure resources and alerts when a previously unseen source IP address is used.\n//\n\nlet starttime = 14d;\nlet endtime = 1d;\n// The number of operations below which an IP address is considered an unusual source of role assignment operations\nlet alertOperationThreshold = 5;\nlet createRoleAssignmentActivity = AzureActivity\n| where OperationName == \"Create role assignment\";\ncreateRoleAssignmentActivity \n| where TimeGenerated between (ago(starttime) .. ago(endtime))\n| summarize count() by CallerIpAddress, Caller\n| where count_ \u003e= alertOperationThreshold\n| join kind = rightanti ( \ncreateRoleAssignmentActivity\n| where TimeGenerated \u003e ago(endtime)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ActivityTimeStamp = makelist(TimeGenerated), ActivityStatus = makelist(ActivityStatus), \nOperationIds = makelist(OperationId), CorrelationId = makelist(CorrelationId), ActivityCountByCallerIPAddress = count()  \nby ResourceId, CallerIpAddress, Caller, OperationName, Resource, ResourceGroup\n) on CallerIpAddress, Caller\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_8')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "Suspicious Resource deployment",
                                             "query":  "//Identifies when a rare Resource and ResourceGroup deployment occurs by a previously unseen Caller.\n//\n\nlet szOperationNames = dynamic([\"Create or Update Virtual Machine\", \"Create Deployment\"]);\nlet starttime = 14d;\nlet endtime = 1d;\nlet RareCaller = AzureActivity\n| where TimeGenerated between (ago(starttime) .. ago(endtime))\n| where OperationName in~ (szOperationNames)\n| project ResourceGroup, Caller, OperationName, CallerIpAddress\n| join kind=rightantisemi (\nAzureActivity\n| where TimeGenerated \u003e ago(endtime)\n| where OperationName in~ (szOperationNames)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ActivityStatus = makeset(ActivityStatus), OperationIds = makeset(OperationId), CallerIpAddress = makeset(CallerIpAddress) \nby ResourceId, Caller, OperationName, Resource, ResourceGroup\n) on Caller, ResourceGroup \n| mvexpand CallerIpAddress\n| where isnotempty(CallerIpAddress);\nlet Counts = RareCaller | summarize ActivityCountByCaller = count() by Caller;\nRareCaller | join kind= inner (Counts) on Caller | project-away Caller1\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = tostring(CallerIpAddress)\n| sort by ActivityCountByCaller desc nulls last \n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_9')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "Rare subscription-level operations in Azure",
                                             "query":  "//This query looks for a few sensitive subscription-level events based on Azure Activity Logs. \n// For example this monitors for the operation name Create or Update Snapshot which is used for creating backups but could be misused by attackers \n// to dump hashes or extract sensitive information from the disk.\n//\n\nlet starttime = 14d;\nlet endtime = 1d;\n// The number of operations below which an IP address is considered an unusual source of role assignment operations\nlet alertOperationThreshold = 5;\nlet SensitiveOperationList = dynamic(\n[\"List keys\", \"List Storage Account Keys\", \"Register Subscription\", \"Create or Update Snapshot\", \"Create or Update Network Security Group\"]);\nlet SensitiveActivity = AzureActivity\n| where OperationName in~ (SensitiveOperationList)\n| where ActivityStatus =~ \"Succeeded\";\nSensitiveActivity\n| where TimeGenerated between (ago(starttime) .. ago(endtime))\n| summarize count() by CallerIpAddress, Caller\n| where count_ \u003e= alertOperationThreshold\n| join kind = rightanti ( \nSensitiveActivity\n| where TimeGenerated \u003e= ago(endtime)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ActivityTimeStamp = makelist(TimeGenerated), ActivityStatus = makelist(ActivityStatus), \nOperationIds = makelist(OperationId), CorrelationIds = makelist(CorrelationId), Resources = makelist(Resource), ResourceGroups = makelist(ResourceGroup), ResourceIds = makelist(ResourceId), ActivityCountByCallerIPAddress = count()  \nby CallerIpAddress, Caller, OperationName\n) on CallerIpAddress, Caller\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_10')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "Mass secret retrieval from Azure Key Vault",
                                             "query":  "//Identifies mass secret retrieval from Azure Key Vault observed by a single user. \n//Mass secret retrival crossing a certain threshold is an indication of credential dump operations or mis-configured applications. \n//You can tweak the EventCountThreshold based on average count seen in your environment \n//and also filter any known sources (IP/Account) and useragent combinations based on historical analysis to further reduce noise\n//\n\nlet timeframe =1d;\nlet EventCountThreshold = 25;\nlet OperationList = dynamic(\n[\"SecretGet\", \"KeyGet\", \"VaultGet\"]);\nAzureDiagnostics\n| where TimeGenerated \u003e ago(timeframe)\n| extend ResultType = columnifexists(\"ResultType\", \"None\"), identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g = columnifexists(\"identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g\", \"None\")\n| where ResultType !~ \"None\" and isnotempty(ResultType)\n| where identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g !~ \"None\" and isnotempty(identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g)\n| where ResourceType =~ \"VAULTS\" and ResultType =~ \"Success\"\n| where OperationName in (OperationList) \n| summarize count() by identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g, OperationName\n| where count_ \u003e EventCountThreshold  \n| join (\nAzureDiagnostics\n| where TimeGenerated \u003e ago(timeframe)\n| extend ResultType = columnifexists(\"ResultType\", \"NoResultType\")\n| extend requestUri_s = columnifexists(\"requestUri_s\", \"None\"), identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g = columnifexists(\"identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g\", \"None\")\n| extend id_s = columnifexists(\"id_s\", \"None\"), CallerIPAddress = columnifexists(\"CallerIPAddress\", \"None\"), clientInfo_s = columnifexists(\"clientInfo_s\", \"None\")\n| where ResultType !~ \"None\" and isnotempty(ResultType)\n| where identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g !~ \"None\" and isnotempty(identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g)\n| where id_s !~ \"None\" and isnotempty(id_s)\n| where CallerIPAddress !~ \"None\" and isnotempty(CallerIPAddress)\n| where clientInfo_s !~ \"None\" and isnotempty(clientInfo_s)\n| where requestUri_s !~ \"None\" and isnotempty(requestUri_s)\n| where OperationName in~ (OperationList)   \n) on identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g \n| summarize EventCount=sum(count_), StartTimeUtc=min(TimeGenerated), EndTimeUtc=max(TimeGenerated), TimeTriggered=makelist(TimeGenerated),OperationNameList=make_set(OperationName), RequestURLList=make_set(requestUri_s), CallerIPList = make_set(CallerIPAddress),  CallerIPMax= arg_max(CallerIPAddress,*) by ResourceType, ResultType, Resource, id_s, identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g, clientInfo_s\n| extend timestamp = EndTimeUtc, IPCustomEntity = CallerIPMax, AccountCustomEntity = identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_11')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "Sensitive Azure Key Vault operations",
                                             "query":  "//Identifies when sensitive Azure Key Vault operations are used. This includes: VaultDelete, KeyDelete, KeyDecrypt, SecretDelete, SecretPurge, KeyPurge, SecretBackup, KeyBackup. \n//Any Backup operations should match with expected scheduled backup activity.\n//\n\nlet timeframe = 1d;\nlet SensitiveOperationList = dynamic(\n[\"VaultDelete\", \"KeyDelete\", \"SecretDelete\", \"SecretPurge\", \"KeyPurge\", \"SecretBackup\", \"KeyBackup\"]);\nAzureDiagnostics\n| where TimeGenerated \u003e ago(timeframe)\n| extend ResultType = columnifexists(\"ResultType\", \"NoResultType\")\n| extend requestUri_s = columnifexists(\"requestUri_s\", \"None\"), identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g = columnifexists(\"identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g\", \"None\")\n| extend id_s = columnifexists(\"id_s\", \"None\"), CallerIPAddress = columnifexists(\"CallerIPAddress\", \"None\"), clientInfo_s = columnifexists(\"clientInfo_s\", \"None\")\n| where ResultType !~ \"None\" and isnotempty(ResultType)\n| where identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g !~ \"None\" and isnotempty(identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g)\n| where id_s !~ \"None\" and isnotempty(id_s)\n| where CallerIPAddress !~ \"None\" and isnotempty(CallerIPAddress)\n| where clientInfo_s !~ \"None\" and isnotempty(clientInfo_s)\n| where requestUri_s !~ \"None\" and isnotempty(requestUri_s)\n| where ResourceType =~ \"VAULTS\" and ResultType =~ \"Success\" \n| where OperationName in~ (SensitiveOperationList)  \n| summarize EventCount=count(), StartTimeUtc=min(TimeGenerated), EndTimeUtc=max(TimeGenerated), TimeTriggered=makelist(TimeGenerated),OperationNameList=make_set(OperationName), RequestURLList=make_set(requestUri_s), CallerIPList = make_set(CallerIPAddress),  CallerIPMax= arg_max(CallerIPAddress,*) by ResourceType, ResultType, Resource, id_s, identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g, clientInfo_s\n| extend timestamp = StartTimeUtc, IPCustomEntity = CallerIPMax, AccountCustomEntity = identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_12')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "Azure Key Vault access TimeSeries anomaly",
                                             "query":  "//Indentifies a sudden increase in count of Azure Key Vault secret or vault access operations by CallerIPAddress. The query leverages a built-in KQL anomaly detection algorithm \n//to find large deviations from baseline Azure Key Vault access patterns. Any sudden increase in the count of Azure Key Vault accesses can be an \n//indication of adversary dumping credentials via automated methods. If you are seeing any noise, try filtering known source(IP/Account) and user-agent combinations.\n//TimeSeries Reference Blog: https://techcommunity.microsoft.com/t5/azure-sentinel/looking-for-unknown-anomalies-what-is-normal-time-series/ba-p/555052\n//\n\nlet starttime = 14d;\nlet timeframe = 1d;\nlet scorethreshold = 3;\nlet baselinethreshold = 5;\nlet OperationList = dynamic(\n[\"SecretGet\", \"KeyGet\", \"VaultGet\"]);\nlet TimeSeriesData = AzureDiagnostics\n| where TimeGenerated between (startofday(ago(starttime))..startofday(now()))\n| extend ResultType = columnifexists(\"ResultType\", \"None\"), CallerIPAddress = columnifexists(\"CallerIPAddress\", \"None\")\n| where ResultType !~ \"None\" and isnotempty(ResultType)\n| where CallerIPAddress !~ \"None\" and isnotempty(CallerIPAddress)\n| where ResourceType =~ \"VAULTS\" and ResultType =~ \"Success\"\n| where OperationName in (OperationList) \n| project TimeGenerated, OperationName, Resource, CallerIPAddress \n| make-series HourlyCount=count() on TimeGenerated from startofday(ago(starttime)) to startofday(now()) step timeframe by Resource;\n//Filter anomolies against TimeSeriesData\nlet TimeSeriesAlerts = TimeSeriesData\n| extend (anomalies, score, baseline) = series_decompose_anomalies(HourlyCount, scorethreshold, -1, 'linefit')\n| mv-expand HourlyCount to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double),score to typeof(double), baseline to typeof(long)\n| where anomalies \u003e 0 | extend AnomalyHour = TimeGenerated\n| where baseline \u003e baselinethreshold // Filtering low count events per baselinethreshold\n| project Resource, AnomalyHour, TimeGenerated, HourlyCount, baseline, anomalies, score;\n// Filter the alerts since specified timeframe\nTimeSeriesAlerts\n| where TimeGenerated \u003e ago(timeframe)\n// Join against base logs since specified timeframe to retrive records associated with the hour of anomoly\n| join (\nAzureDiagnostics\n| where TimeGenerated \u003e ago(timeframe)\n| extend ResultType = columnifexists(\"ResultType\", \"NoResultType\")\n| extend requestUri_s = columnifexists(\"requestUri_s\", \"None\"), identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g = columnifexists(\"identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g\", \"None\")\n| extend id_s = columnifexists(\"id_s\", \"None\"), CallerIPAddress = columnifexists(\"CallerIPAddress\", \"None\"), clientInfo_s = columnifexists(\"clientInfo_s\", \"None\")\n| where ResultType !~ \"None\" and isnotempty(ResultType)\n| where identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g !~ \"None\" and isnotempty(identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g)\n| where id_s !~ \"None\" and isnotempty(id_s)\n| where CallerIPAddress !~ \"None\" and isnotempty(CallerIPAddress)\n| where clientInfo_s !~ \"None\" and isnotempty(clientInfo_s)\n| where requestUri_s !~ \"None\" and isnotempty(requestUri_s)\n| where ResourceType =~ \"VAULTS\" and ResultType =~ \"Success\"\n| where OperationName in (OperationList)  \n| summarize PerOperationCount=count(), LatestAnomalyTime = arg_max(TimeGenerated,*) by bin(TimeGenerated,1h), Resource, OperationName, id_s, CallerIPAddress, identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g, requestUri_s, clientInfo_s     \n) on Resource, TimeGenerated \n| summarize EventCount=count(), OperationNameList = make_set(OperationName), RequestURLList = make_set(requestUri_s), AccountList = make_set(identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g), AccountMax = arg_max(identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g,*) by Resource, id_s, clientInfo_s, LatestAnomalyTime\n| extend timestamp = LatestAnomalyTime, IPCustomEntity = CallerIPAddress, AccountCustomEntity = AccountMax\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_13')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "Cisco ASA - average attack detection rate increase",
                                             "query":  "//This will help you determine if Cisco ASA devices are under heavier attack than normal over the last hour versus the previous 6 hours based on DeviceEventClassID 733100\n//References: https://www.cisco.com/c/en/us/td/docs/security/asa/syslog/b_syslog/syslogs9.html\n//Details on how to further troubleshoot/investigate: https://www.cisco.com/c/en/us/support/docs/security/asa-5500-x-series-next-generation-firewalls/113685-asa-threat-detection.html\n//\n\nlet timeframe = 1h;\nlet last1h = CommonSecurityLog \n| where TimeGenerated \u003e= ago(timeframe)\n| where isempty(CommunicationDirection) \n| where DeviceEventClassID == \"733100\"\n| extend SourceOfDropRateCount = tostring(split(tostring(split(Message, \"]\")[0]),\"[ \")[1])\n| extend splitMessage = split(Message, \".\")\n| extend DropRate = tostring(split(tostring(splitMessage[0]),\"] \")[1])\n| extend CurrentBurstRate = split(tostring(split(tostring(splitMessage[1]),\"  \")[0]),\"is \")\n| extend CurrentBurstRatePerSec = toint(split(tostring(CurrentBurstRate[1]),\" \")[0])\n| extend MaxConfiguredBurstRate = toint(CurrentBurstRate[2])\n| extend CurrentAvgRate = split(tostring(split(tostring(splitMessage[1]),\"  \")[1]),\"is \")\n| extend CurrentAvgRatePerSec = toint(split(tostring(CurrentAvgRate[1]),\" \")[0])\n| extend MaxConfiguredAvgRate = toint(CurrentAvgRate[2])\n| extend CumulativeTotal = toint(split(tostring(split(tostring(splitMessage[1]),\"  \")[2]),\"is \")[1])\n| summarize last1hCumTotal = sum(CumulativeTotal), last1hAvgRatePerSec = avg(CurrentAvgRatePerSec), last1hAvgBurstRatePerSec = avg(CurrentBurstRatePerSec) by DeviceName, DeviceEventClassID, SourceIP, SourceOfDropRateCount, DropRate;\nlet prev6h = CommonSecurityLog \n| where TimeGenerated between (ago(6h) .. ago(1h))\n| where isempty(CommunicationDirection) \n| where DeviceEventClassID == \"733100\"\n| extend SourceOfDropRateCount = tostring(split(tostring(split(Message, \"]\")[0]),\"[ \")[1])\n| extend splitMessage = split(Message, \".\")\n| extend DropRate = tostring(split(tostring(splitMessage[0]),\"] \")[1])\n| extend CurrentBurstRate = split(tostring(split(tostring(splitMessage[1]),\"  \")[0]),\"is \")\n| extend prevCurrentBurstRatePerSec = toint(split(tostring(CurrentBurstRate[1]),\" \")[0])\n| extend prevMaxConfiguredBurstRate = toint(CurrentBurstRate[2])\n| extend CurrentAvgRate = split(tostring(split(tostring(splitMessage[1]),\"  \")[1]),\"is \")\n| extend prevCurrentAvgRatePerSec = toint(split(tostring(CurrentAvgRate[1]),\" \")[0])\n| extend prevMaxConfiguredAvgRate = toint(CurrentAvgRate[2])\n| extend prevCumulativeTotal = toint(split(tostring(split(tostring(splitMessage[1]),\"  \")[2]),\"is \")[1])\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), prev6hCumTotal = sum(prevCumulativeTotal), prev6hAvgRatePerSec = avg(prevCurrentAvgRatePerSec), prev6hAvgBurstRatePerSec = avg(prevCurrentBurstRatePerSec) \nby DeviceName, DeviceEventClassID, SourceIP, SourceOfDropRateCount, DropRate;\nlast1h | join (\n  prev6h \n) on DeviceName, DeviceEventClassID, SourceIP, SourceOfDropRateCount, DropRate\n| project StartTimeUtc, EndTimeUtc, DeviceName, DeviceEventClassID, SourceIP, SourceOfDropRateCount, DropRate, last1hCumTotal, prev6hCumTotal, prev6hAvgCumTotal = prev6hCumTotal/6, last1hAvgRatePerSec, prev6hAvgRatePerSec, last1hAvgBurstRatePerSec, prev6hAvgBurstRatePerSec\n// Select only events that indicate a doubling of the expected rate in the last hour over the previous 6 hours\n| where last1hCumTotal \u003e 2*prev6hAvgCumTotal or last1hAvgRatePerSec \u003e 2*prev6hAvgRatePerSec or last1hAvgBurstRatePerSec \u003e 2*prev6hAvgBurstRatePerSec\n| extend timestamp = StartTimeUtc, IPCustomEntity = SourceIP, HostCustomEntity = DeviceName\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_14')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Cisco ASA - threat detection message fired",
                                             "query":  "//Identifies when the Cisco ASA Threat Detection engine fired an alert based on malicious activity occurring on the network inicated by DeviceEventClassID 733101-733105\n//Resources: https://www.cisco.com/c/en/us/td/docs/security/asa/syslog/b_syslog/syslogs9.html\n//Details on how to further troubleshoot/investigate: https://www.cisco.com/c/en/us/support/docs/security/asa-5500-x-series-next-generation-firewalls/113685-asa-threat-detection.html\n//\n\nlet timeframe = 1h;\nCommonSecurityLog \n| where TimeGenerated \u003e= ago(timeframe)\n| where isempty(CommunicationDirection) \n| where DeviceEventClassID in (\"733101\",\"733102\",\"733103\",\"733104\",\"733105\")\n| extend timestamp = TimeGenerated, IPCustomEntity = SourceIP, HostCustomEntity = DeviceName\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_15')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "Fortinet - Beacon pattern detected",
                                             "query":  "//Identifies patterns in the time deltas of contacts between internal and external IPs in Fortinet network data that are consistent with beaconing.\n// Accounts for randomness (jitter) and seasonality such as working hours that may have been introduced into the beacon pattern.\n// The lookback is set to 1d, the minimum granularity in time deltas is set to 60 seconds and the minimum number of beacons required to emit a\n// detection is set to 4.\n// Increase the lookback period to capture beacons with larger periodicities.\n// The jitter tolerance is set to 0.2 - This means we account for an overall 20% deviation from the infered beacon periodicity. Seasonality is dealt with\n// automatically using series_outliers.\n// Note: In large environments it may be necessary to reduce the lookback period to get fast query times.\n//\n\nlet starttime = 1d;\nlet TimeDeltaThresholdInSeconds = 60; // we ignore beacons diffs that fall below this threshold \nlet TotalBeaconsThreshold = 4; // minimum number of beacons required in a session to surface a row\nlet JitterTolerance = 0.2; // tolerance to jitter, e.g. - 0.2 = 20% jitter is tolerated either side of the periodicity\nlet PrivateIPregex = @\"^127\\.|^10\\.|^172\\.1[6-9]\\.|^172\\.2[0-9]\\.|^172\\.3[0-1]\\.|^192\\.168\\.\"; // exclude destinations that fall into this category\nCommonSecurityLog\n| where DeviceVendor == \"Fortinet\"\n| where TimeGenerated \u003e ago(starttime)\n// eliminate bad data\n| where isnotempty(SourceIP) and isnotempty(DestinationIP) and SourceIP != \"0.0.0.0\"\n// filter out deny, close, rst and SNMP to reduce data volume\n| where DeviceAction !in (\"close\", \"client-rst\", \"server-rst\", \"deny\") and DestinationPort != 161\n// map input fields\n| project TimeGenerated , SourceIP, DestinationIP, DestinationPort, ReceivedBytes, SentBytes, DeviceAction \n// where destination IPs are public\n| extend DestinationIPType = iff(DestinationIP matches regex PrivateIPregex,\"private\" ,\"public\" )\n| where DestinationIPType == \"public\"\n// sort into source-\u003edestination 'sessions'\n| sort by SourceIP asc, DestinationIP asc, DestinationPort asc, TimeGenerated asc\n| serialize\n// time diff the contact times between source and destination to get a list of deltas\n| extend nextTimeGenerated = next(TimeGenerated, 1), nextSourceIP = next(SourceIP, 1), nextDestIP = next(DestinationIP, 1), nextDestPort = next(DestinationPort, 1)\n| extend TimeDeltainSeconds = datetime_diff(\"second\",nextTimeGenerated,TimeGenerated)\n| where SourceIP == nextSourceIP and DestinationIP == nextDestIP and DestinationPort == nextDestPort\n// remove small time deltas below the set threshold\n| where TimeDeltainSeconds \u003e TimeDeltaThresholdInSeconds\n| project TimeGenerated, TimeDeltainSeconds, SourceIP, DestinationIP, DestinationPort, ReceivedBytes, SentBytes, DeviceAction \n// summarize the deltas by source-\u003edestination\n| summarize count(), StartTime=min(TimeGenerated), EndTime=max(TimeGenerated), sum(ReceivedBytes), sum(SentBytes), makelist(TimeDeltainSeconds), makeset(DeviceAction) by SourceIP, DestinationIP, DestinationPort\n// get some statistical properties of the delta distribution and smooth any outliers (e.g. laptop shut overnight, working hours)\n| extend series_stats(list_TimeDeltainSeconds), outliers=series_outliers(list_TimeDeltainSeconds)\n// expand the deltas and the outliers\n| mvexpand list_TimeDeltainSeconds to typeof(double), outliers to typeof(double)\n// replace outliers with the average of the distribution\n| extend list_TimeDeltainSeconds_normalized=iff(outliers \u003e 1.5 or outliers \u003c -1.5, series_stats_list_TimeDeltainSeconds_avg , list_TimeDeltainSeconds)\n// summarize with the smoothed distribution\n| summarize BeaconCount=count(), makelist(list_TimeDeltainSeconds), list_TimeDeltainSeconds_normalized=makelist(list_TimeDeltainSeconds_normalized), makeset(set_DeviceAction) by StartTime, EndTime, SourceIP, DestinationIP, DestinationPort, sum_ReceivedBytes, sum_SentBytes\n// get stats on the smoothed distribution\n| extend series_stats(list_TimeDeltainSeconds_normalized)\n// match jitter tolerance on smoothed distrib\n| extend MaxJitter = (series_stats_list_TimeDeltainSeconds_normalized_avg*JitterTolerance)\n| where series_stats_list_TimeDeltainSeconds_normalized_stdev \u003c MaxJitter\n// where the minimum beacon threshold is satisfied and there was some data transfer\n| where BeaconCount \u003e TotalBeaconsThreshold and (sum_SentBytes \u003e 0 or sum_ReceivedBytes \u003e 0)\n// final projection\n| project StartTime, EndTime, SourceIP, DestinationIP, DestinationPort, BeaconCount, TimeDeltasInSeconds=list_list_TimeDeltainSeconds, Periodicity=series_stats_list_TimeDeltainSeconds_normalized_avg, ReceivedBytes=sum_ReceivedBytes, SentBytes=sum_SentBytes, Actions=set_set_DeviceAction\n// where periodicity is order of magnitude larger than time delta threshold (eliminates FPs whose periodicity is close to the values we ignored)\n| where Periodicity \u003e= (10*TimeDeltaThresholdInSeconds)\n| extend timestamp = StartTime, IPCustomEntity = DestinationIP\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_16')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Possible contact with a domain generated by a DGA",
                                             "query":  "//Identifies contacts with domains names in CommonSecurityLog that might have been generated by a Domain Generation Algorithm (DGA). DGAs can be used\n//by malware to generate rendezvous points that are difficult to predict in advance. This detection uses the Alexa Top 1 million domain names to build a model\n//of what normal domains look like. It uses this to identify domains that may have been randomly generated by an algorithm.\n//The triThreshold is set to 500 - increase this to report on domains that are less likely to have been randomly generated, decrease it for more likely.\n//The start time and end time look back over 6 hours of data and the dgaLengthThreshold is set to 8 - meaning domains whose length is 8 or more are reported.\n//\n\nlet triThreshold = 500;\nlet startTime = 6h;\nlet dgaLengthThreshold = 8;\n// fetch the alexa top 1M domains\nlet top1M =  (externaldata (Position:int, Domain:string)   [@\"http://s3-us-west-1.amazonaws.com/umbrella-static/top-1m.csv.zip\"]  with (format=\"csv\", zipPattern=\"*.csv\"));\n// extract tri grams that are above our threshold - i.e. are common\nlet triBaseline =   top1M\n| extend Domain = tolower(extract(\"([^.]*).{0,7}$\", 1, Domain))\n| extend AllTriGrams = array_concat(extract_all(\"(...)\", Domain), extract_all(\"(...)\", substring(Domain, 1)), extract_all(\"(...)\", substring(Domain, 2)))\n| mvexpand Trigram=AllTriGrams\n| summarize triCount=count() by tostring(Trigram)\n| sort by triCount desc\n| where triCount \u003e triThreshold\n| distinct Trigram;\n// collect domain information from common security log, filter and extract the DGA candidate and its trigrams\nlet allDataSummarized =   CommonSecurityLog\n| where TimeGenerated \u003e ago(startTime)\n| where isnotempty(DestinationHostName)\n| extend Name = tolower(DestinationHostName)\n| distinct Name\n| where Name has \".\"\n| where Name !endswith \".home\" and Name !endswith \".lan\"\n// extract DGA candidate\n| extend DGADomain = extract(\"([^.]*).{0,7}$\", 1, Name)\n| where strlen(DGADomain) \u003e dgaLengthThreshold\n// throw out domains with number in them\n| where DGADomain matches regex \"^[A-Za-z]{0,}$\"\n// extract the tri grams from summarized data\n| extend AllTriGrams = array_concat(extract_all(\"(...)\", DGADomain), extract_all(\"(...)\", substring(DGADomain, 1)), extract_all(\"(...)\", substring(DGADomain, 2)));\n// throw out domains that have repeating tri's and/or \u003e=3 repeating letters\nlet nonRepeatingTris =  allDataSummarized\n| join kind=leftanti\n(\n    allDataSummarized\n    | mvexpand AllTriGrams\n    | summarize count() by tostring(AllTriGrams), DGADomain\n    | where count_ \u003e 1\n    | distinct DGADomain\n)\non DGADomain;\n// find domains that do not have a common tri in the baseline\nlet dataWithRareTris =  nonRepeatingTris\n| join kind=leftanti\n(\n    nonRepeatingTris\n    | mvexpand AllTriGrams\n    | extend Trigram = tostring(AllTriGrams)\n    | distinct Trigram, DGADomain\n    | join kind=inner\n    (\n        triBaseline\n    )\n    on Trigram\n    | distinct DGADomain\n)\non DGADomain;\ndataWithRareTris\n// join DGAs back on connection data\n| join kind=inner\n(\n    CommonSecurityLog\n    | where TimeGenerated \u003e ago(startTime)\n    | where isnotempty(DestinationHostName)\n    | extend DestinationHostName = tolower(DestinationHostName)\n    | project-rename Name=DestinationHostName, DataSource=DeviceVendor\n    | summarize StartTime=min(TimeGenerated), EndTime=max(TimeGenerated) by Name, SourceIP, DestinationIP, DataSource\n)\non Name\n| project StartTime, EndTime, Name, DGADomain, SourceIP, DestinationIP, DataSource\n| extend timestamp=StartTime, IPCustomEntity=SourceIP\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_17')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "Palo Alto - potential beaconing detected",
                                             "query":  "//Identifies beaconing patterns from Palo Alto Network traffic logs based on recurrent timedelta patterns. \n//The query leverages various KQL functions to calculate time deltas and then compares it with total events observed in a day to find percentage of beaconing. \n//This outbound beaconing pattern to untrusted public networks should be investigated for any malware callbacks or data exfiltration attempts.\n//Reference Blog:\n//http://www.austintaylor.io/detect/beaconing/intrusion/detection/system/command/control/flare/elastic/stack/2017/06/10/detect-beaconing-with-flare-elasticsearch-and-intrusion-detection-systems/\n//\n\nlet starttime = 2d;\nlet endtime = 1d;\nlet TimeDeltaThreshold = 10;\nlet TotalEventsThreshold = 15;\nlet PercentBeaconThreshold = 80;\nlet PrivateIPregex = @'^127\\.|^10\\.|^172\\.1[6-9]\\.|^172\\.2[0-9]\\.|^172\\.3[0-1]\\.|^192\\.168\\.';\nCommonSecurityLog\n| where DeviceVendor == \"Palo Alto Networks\" and Activity == \"TRAFFIC\"\n| where TimeGenerated between (ago(starttime)..ago(endtime))\n| extend DestinationIPType = iff(DestinationIP matches regex PrivateIPregex,\"private\" ,\"public\" )\n| where DestinationIPType == \"public\"\n| project TimeGenerated, DeviceName, SourceUserID, SourceIP, SourcePort, DestinationIP, DestinationPort, ReceivedBytes, SentBytes\n| sort by SourceIP asc,TimeGenerated asc, DestinationIP asc, DestinationPort asc\n| serialize\n| extend nextTimeGenerated = next(TimeGenerated, 1), nextSourceIP = next(SourceIP, 1)\n| extend TimeDeltainSeconds = datetime_diff('second',nextTimeGenerated,TimeGenerated)\n| where SourceIP == nextSourceIP\n//Whitelisting criteria/ threshold criteria\n| where TimeDeltainSeconds \u003e TimeDeltaThreshold \n| project TimeGenerated, TimeDeltainSeconds, DeviceName, SourceUserID, SourceIP, SourcePort, DestinationIP, DestinationPort, ReceivedBytes, SentBytes\n| summarize count(), sum(ReceivedBytes), sum(SentBytes), make_list(TimeDeltainSeconds) \nby TimeDeltainSeconds, bin(TimeGenerated, 1h), DeviceName, SourceUserID, SourceIP, DestinationIP, DestinationPort\n| summarize (MostFrequentTimeDeltaCount, MostFrequentTimeDeltainSeconds) = arg_max(count_, TimeDeltainSeconds), TotalEvents=sum(count_), TotalSentBytes = sum(sum_SentBytes), TotalReceivedBytes = sum(sum_ReceivedBytes) \nby bin(TimeGenerated, 1h), DeviceName, SourceUserID, SourceIP, DestinationIP, DestinationPort\n| where TotalEvents \u003e TotalEventsThreshold \n| extend BeaconPercent = MostFrequentTimeDeltaCount/toreal(TotalEvents) * 100\n| where BeaconPercent \u003e PercentBeaconThreshold\n| extend timestamp = TimeGenerated, IPCustomEntity = DestinationIP, AccountCustomEntity = SourceUserID, HostCustomEntity = DeviceName \n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_18')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "Palo Alto - possible internal to external port scanning",
                                             "query":  "//Identifies a list of internal Source IPs (10.x.x.x Hosts) that have triggered 10 or more non-graceful tcp server resets from one or more Destination IPs which \n//results in an \"ApplicationProtocol = incomplete\" designation. The server resets coupled with an \"Incomplete\" ApplicationProtocol designation can be an indication \n//of internal to external port scanning or probing attack. \n//References: https://knowledgebase.paloaltonetworks.com/KCSArticleDetail?id=kA10g000000ClUvCAK and\n//https://knowledgebase.paloaltonetworks.com/KCSArticleDetail?id=kA10g000000ClTaCAK\n//\n\nlet timeframe = 1h;\nCommonSecurityLog \n| where TimeGenerated \u003e ago(timeframe) \n| where isnotempty(DestinationPort) and DeviceAction !in (\"reset-both\", \"deny\") \n// filter out common usage ports. Add ports that are legitimate for your environment\n| where DestinationPort !in (\"443\", \"53\", \"389\", \"80\", \"0\", \"880\", \"8888\", \"8080\")\n| where ApplicationProtocol == \"incomplete\" \n// filter out IANA ephemeral or negotiated ports as per https://en.wikipedia.org/wiki/Ephemeral_port\n| where DestinationPort !between (toint(49512) .. toint(65535)) \n| where Computer != \"\" \n| where DestinationIP !startswith \"10.\"\n// Filter out any graceful reset reasons of AGED OUT which occurs when a TCP session closes with a FIN due to aging out. \n| where AdditionalExtensions !has \"reason=aged-out\" \n// Filter out any TCP FIN which occurs when a TCP FIN is used to gracefully close half or both sides of a connection.\n| where AdditionalExtensions !has \"reason=tcp-fin\" \n// Uncomment one of the following where clauses to trigger on specific TCP reset reasons\n// See Palo Alto article for details - https://knowledgebase.paloaltonetworks.com/KCSArticleDetail?id=kA10g000000ClUvCAK\n// TCP RST-server - Occurs when the server sends a TCP reset to the client\n// | where AdditionalExtensions has \"reason=tcp-rst-from-server\"  \n// TCP RST-client - Occurs when the client sends a TCP reset to the server\n// | where AdditionalExtensions has \"reason=tcp-rst-from-client\"  \n| extend reason = tostring(split(AdditionalExtensions, \";\")[3])\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by DeviceName, SourceUserID, SourceIP, ApplicationProtocol, reason, DestinationPort, Protocol, DeviceVendor, DeviceProduct, DeviceAction, DestinationIP\n| where count_ \u003e= 10\n| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc), makeset(DestinationIP), totalcount = sum(count_) by DeviceName, SourceUserID, SourceIP, ApplicationProtocol, reason, DestinationPort, Protocol, DeviceVendor, DeviceProduct, DeviceAction\n| extend timestamp = StartTimeUtc, IPCustomEntity = SourceIP, AccountCustomEntity = SourceUserID, HostCustomEntity = DeviceName \n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_19')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Time series anomaly detection for total volume of traffic",
                                             "query":  "//Identifies anamalous spikes in network traffic logs as compared to baseline or normal historical patterns. \n//The query leverages a KQL built-in anomaly detection algorithm to find large deviations from baseline patterns. \n//Sudden increases in network traffic volume may be an indication of data exfiltration attempts and should be investigated.\n//The higher the score, the further it is from the baseline value.\n//The output is aggregated to provide summary view of unique source IP to destination IP address and port traffic observed in the flagged anomaly hour. \n//The source IP addresses which were sending less than percentotalthreshold of the total traffic have been exluded whose value can be adjusted as needed .\n//You may have to run queries for individual source IP addresses from SourceIPlist to determine if anything looks suspicious\n//\n\nlet starttime = 14d;\nlet endtime = 1d;\nlet timeframe = 1h;\nlet scorethreshold = 5;\nlet percentotalthreshold = 25;\nlet TimeSeriesData = CommonSecurityLog \n| where isnotempty(DestinationIP) and isnotempty(SourceIP)\n| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))\n| project TimeGenerated,SourceIP, DestinationIP, DeviceVendor\n| make-series Total=count() on TimeGenerated from startofday(ago(starttime)) to startofday(ago(endtime)) step timeframe by DeviceVendor;\n//Filtering specific records associated with spikes as outliers\nlet TimeSeriesAlerts=TimeSeriesData\n| extend (anomalies, score, baseline) = series_decompose_anomalies(Total, scorethreshold, -1, 'linefit')\n| mv-expand Total to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double),score to typeof(double), baseline to typeof(long)\n| where anomalies \u003e 0 | extend score = round(score,2), AnomalyHour = TimeGenerated\n| project DeviceVendor,AnomalyHour, TimeGenerated, Total, baseline, anomalies, score;\n//Join anomalies with Base Data to popalate associated records for investigation - Results sorted by score in descending order \nTimeSeriesAlerts \n| join (\n    CommonSecurityLog \n| where isnotempty(DestinationIP) and isnotempty(SourceIP)\n| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))\n| summarize HourlyCount = count(), TimeGeneratedMax = arg_max(TimeGenerated, *), DestinationIPlist = make_set(DestinationIP), DestinationPortlist = make_set(DestinationPort) by DeviceVendor, SourceIP, TimeGeneratedHour= bin(TimeGenerated, 1h)\n| extend AnomalyHour = TimeGeneratedHour\n) on AnomalyHour, DeviceVendor \n| extend PercentTotal = round((HourlyCount / Total) * 100, 3)\n| where PercentTotal \u003e percentotalthreshold\n| project DeviceVendor , AnomalyHour, TimeGeneratedMax, SourceIP, DestinationIPlist, DestinationPortlist, HourlyCount, PercentTotal, Total, baseline, score, anomalies\n| summarize HourlyCount=sum(HourlyCount), StartTimeUtc=min(TimeGeneratedMax), EndTimeUtc=max(TimeGeneratedMax), SourceIPlist = make_set(SourceIP), SourceIPMax= arg_max(SourceIP, *), DestinationIPlist = make_set(DestinationIPlist), DestinationPortlist = make_set(DestinationPortlist) by DeviceVendor , AnomalyHour, Total, baseline, score, anomalies\n| project DeviceVendor , AnomalyHour, EndTimeUtc, SourceIPMax ,SourceIPlist, DestinationIPlist, DestinationPortlist, HourlyCount, Total, baseline, score, anomalies\n| extend timestamp= EndTimeUtc , IPCustomEntity = SourceIPMax\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_20')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "Wazuh - Large Number of Web errors from an IP",
                                             "query":  "//Identifies instances where Wazuh logged over 400 403 Web Errors from one IP Address. To onboard Wazuh data into Sentinel please view: https://github.com/wazuh/wazuh-documentation/blob/master/source/azure/monitoring%20activity.rst\n//\n\nlet incidentTime = ago(1d);\nCommonSecurityLog\n| where TimeGenerated \u003e incidentTime\n| where DeviceProduct =~ \"Wazuh\"\n| where Activity has \"Web server 400 error code.\"\n| where Message has \"403\"\n| extend HostName=substring(split(DeviceCustomString1,\")\")[0],1)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), NumberOfErrors = count(SourceIP) by HostName, SourceIP\n| where NumberOfErrors \u003e 400\n| sort by NumberOfErrors desc\n| extend timestamp = StartTime, HostCustomEntity = HostName, IPCustomEntity = SourceIP\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_21')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "Request for single resource on domain",
                                             "query":  "//This will look for connections to a domain where only a single file is requested, this is unusual as most modern web applications require additional recources. This type of activity is often assocaited with malware beaconing or tracking URLs delivered in emails. Developed for Zscaler but applicable to any outbound web logging.\n//\n\nlet timeRange = 1d;\n//The number of URI's seen to be suspicious, higher = less likely to be suspicious\nlet uriThreshold = 1;\nlet suspiciousURLs =\nCommonSecurityLog\n| where TimeGenerated \u003e= ago(timeRange)\n// Only look at connections that were allowed through the web proxy. Comment line out for all events including those which were blocked\n| where DeviceVendor =~ \"Zscaler\" and DeviceAction =~ \"Allowed\"\n// Only look where some data was exchanged. Comment out to see 0 byte connections\n| where SentBytes \u003e 0 and ReceivedBytes \u003e 0\n// Extract the Domain\n| extend Domain = iff(countof(DestinationHostName,'.') \u003e= 2, strcat(split(DestinationHostName,'.')[-2], '.',split(DestinationHostName,'.')[-1]), DestinationHostName)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), makelist(RequestURL), makelist(DestinationIP), makelist(SourceIP), numOfConnections = count() by Domain\n// Determine the number of URIs that have been visited for the domain\n| extend destinationURI = arraylength(list_RequestURL)\n| where destinationURI \u003c= uriThreshold\n| where tostring(list_RequestURL) has_any (\".php\",\".aspx\")\n;\nsuspiciousURLs\n| mvexpand list_RequestURL, list_DestinationIP\n| extend RequestURL = tostring(list_RequestURL), DestinationIP = tostring(list_DestinationIP), ClientIP = tostring(list_SourceIP)\n| extend timestamp = StartTimeUtc, IPCustomEntity = DestinationIP\n| project-away list_RequestURL, list_DestinationIP, list_SourceIP, destinationURI, Domain, StartTimeUtc, EndTimeUtc, numOfConnections \n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_22')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Failed AzureAD logons but success logon to host",
                                             "query":  "//Identifies a list of IP addresses with a minimum number (default of 5) of failed logon attempts to Azure Active Directory.\n//Uses that list to identify any successful remote logons to hosts from these IPs within the same timeframe.\n//\n\nlet timeframe = 1d;\n//Adjust this threshold to fit the environment\nlet signin_threshold = 5;\n//Make a list of all IPs with failed signins to AAD above our threshold\nlet suspicious_signins =\nSigninLogs\n| where TimeGenerated \u003e= ago(timeframe)\n| where ResultType !in (\"0\", \"50125\", \"50140\")\n| where IPAddress != \"127.0.0.1\"\n| summarize count() by IPAddress\n| where count_ \u003e signin_threshold\n| summarize make_list(IPAddress);\n//See if any of these IPs have sucessfully logged into *nix hosts\nlet linux_logons =\nSyslog\n| where TimeGenerated \u003e= ago(timeframe)\n| where Facility contains \"auth\" and ProcessName != \"sudo\"\n| where SyslogMessage has \"Accepted\"\n| extend SourceIP = extract(\"(([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.(([0-9]{1,3})))\",1,SyslogMessage)\n| where SourceIP in (suspicious_signins)\n| extend Reason = \"Multiple failed AAD logins from IP address\"\n| project TimeGenerated, Computer, HostIP, IpAddress = SourceIP, SyslogMessage, Facility, ProcessName, Reason;\n//See if any of these IPs have sucessfully logged into Windows hosts\nlet win_logons =\nSecurityEvent\n| where TimeGenerated \u003e= ago(timeframe)\n| where EventID == 4624\n| where LogonType in (10, 7, 3)\n| where IpAddress != \"-\"\n| where IpAddress in (suspicious_signins)\n| extend Reason = \"Multiple failed AAD logins from IP address\"\n| project TimeGenerated, Account, AccountType, Computer, Activity, EventID, LogonProcessName, IpAddress, LogonTypeName, TargetUserSid, Reason;\nunion isfuzzy=true linux_logons,win_logons\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, IPCustomEntity = IpAddress, HostCustomEntity = Computer\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_23')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "IP with multiple failed Azure AD logins successfully logs in to Palo Alto VPN",
                                             "query":  "//This query creates a list of IP addresses with a number failed login attempts to AAD \n//above a set threshold.  It then looks for any successful Palo Alto VPN logins from any\n//of these IPs within the same timeframe.\n//\nlet timeframe = 1d;\n//Set a threshold of failed AAD signins from an IP address within 1 day above which we want to deem those logins suspicious.\nlet signin_threshold = 5; \n//Make a list of IPs with AAD signin failures above our threshold.\nlet suspicious_signins = \n    SigninLogs\n    | where TimeGenerated \u003e= ago(timeframe)\n    //Looking for logon failure results\n    | where ResultType !in (\"0\", \"50125\", \"50140\")\n    //Exclude localhost addresses to reduce the chance of FPs\n    | where IPAddress != \"127.0.0.1\"\n    | summarize count() by IPAddress\n    | where count_ \u003e  signin_threshold\n    | summarize make_list(IPAddress);\n//See if any of those IPs have sucessfully logged into PA VPNs during the same timeperiod\nCommonSecurityLog\n    | where TimeGenerated \u003e ago(timeframe)\n    //Select only PA VPN sucessful logons\n    | where DeviceVendor == \"Palo Alto Networks\" and DeviceEventClassID == \"globalprotect\"\n    | where Message has \"GlobalProtect gateway user authentication succeeded\"\n    //Parse out the logon source IP from the Message field to match on\n    | extend SourceIP = extract(\"Login from: ([^,]+)\", 1, Message) \n    | where SourceIP in (suspicious_signins)\n    | extend Reason = \"Multiple failed AAD logins from SourceIP\"\n    //Parse out other useful information from Message field\n    | extend User = extract(\"User name: ([^,]+)\", 1, Message) \n    | extend ClientOS = extract(\"Client OS version: ([^,\\\"]+)\", 1, Message)\n    | extend Location = extract(\"Source region: ([^,]{2})\",1, Message)\n    | project TimeGenerated, Reason, SourceIP, User, ClientOS, Location, Message, DeviceName, ReceiptTime, DeviceVendor, DeviceEventClassID, Computer, FileName\n    | extend AccountCustomEntity = User, IPCustomEntity = SourceIP, timestamp = TimeGenerated, HostCustomEntity = DeviceName \n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_24')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Failed host logons but success logon to AzureAD",
                                             "query":  "//Identifies a list of IP addresses with a minimum number(default of 5) of failed logon attempts to remote hosts.\n//Uses that list to identify any successful logons to Azure Active Directory from these IPs within the same timeframe.\n//\n\nlet timeframe = 1d;\n//Adjust this threshold to fit environment\nlet signin_threshold = 5; \n//Make a list of IPs with failed Windows host logins above threshold\nlet win_fails = \nSecurityEvent\n| where TimeGenerated \u003e= ago(timeframe)\n| where EventID == 4625\n| where LogonType in (10, 7, 3)\n| where IpAddress != \"-\"\n| summarize count() by IpAddress\n| where count_ \u003e signin_threshold\n| summarize make_list(IpAddress);\n//Make a list of IPs with failed *nix host logins above threshold\nlet nix_fails = \nSyslog\n| where TimeGenerated \u003e ago(timeframe)\n| where Facility contains 'auth' and ProcessName != 'sudo'\n| extend SourceIP = extract(\"(([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.(([0-9]{1,3})))\",1,SyslogMessage)\n| where SourceIP != \"\" and SourceIP != \"127.0.0.1\"\n| summarize count() by SourceIP\n| where count_ \u003e signin_threshold\n| summarize make_list(SourceIP);\n//See if any of the IPs with failed host logins hve had a sucessful Azure AD login\nSigninLogs\n| where TimeGenerated \u003e ago(timeframe)\n| where ResultType !in (\"0\", \"50125\", \"50140\")\n| where IPAddress in (win_fails) or IPAddress in (nix_fails)\n| extend Reason=  \"Multiple failed host logins from IP address with successful Azure AD login\"\n| extend timstamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_25')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Network endpoint to host executable correlation",
                                             "query":  "//Correlates blocked URLs hosting [malicious] executables with host endpoint data\n//to identify potential instances of executables of the same name having been recently run.\n//\n\nlet timeframe = 1d;\nlet endpointData = \n(SecurityEvent\n  | where TimeGenerated \u003e= ago(timeframe) \n  | where EventID == 4688\n  | extend shortFileName = tostring(split(NewProcessName, '\\\\')[-1])\n  );\n// Correlate suspect executables seen in TrendMicro rule updates with similar activity on endpoints\nCommonSecurityLog\n| where TimeGenerated \u003e= ago(timeframe)\n| where DeviceVendor =~ \"Trend Micro\"\n| where Activity =~ \"Deny List updated\" \n| where RequestURL endswith \".exe\"\n| project TimeGenerated, Activity , RequestURL , SourceIP, DestinationIP\n| extend suspectExeName = tolower(tostring(split(RequestURL, '/')[-1]))\n| join (endpointData) on $left.suspectExeName == $right.shortFileName \n| extend timestamp = TimeGenerated, IPCustomEntity = DestinationIP, AccountCustomEntity = TargetUserName, HostCustomEntity = Computer, URLCustomEntity = RequestURL\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_26')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Cisco - firewall block but success logon to Azure AD",
                                             "query":  "//Correlate IPs blocked by a Cisco firewall appliance with successful Azure Active Directory signins. \n//Because the IP was blocked by the firewall, that same IP logging on successfully to AAD is potentially suspect\n//and could indicate credential compromise for the user account.\n//\n\nlet PrivateIPregex = @'^127\\.|^10\\.|^172\\.1[6-9]\\.|^172\\.2[0-9]\\.|^172\\.3[0-1]\\.|^192\\.168\\.';\nlet endtime = 1d;\nCommonSecurityLog\n| where TimeGenerated \u003e= ago(endtime) \n| where DeviceVendor =~ \"Cisco\"\n| where DeviceAction =~ \"denied\"\n| extend SourceIPType = iff(SourceIP matches regex PrivateIPregex,\"private\" ,\"public\" )\n| where SourceIPType == \"public\"\n| summarize count() by SourceIP\n| join (\n    // Successful signins from IPs blocked by the firewall solution are suspect\n    // Include fully successful sign-ins, but also ones that failed only at MFA stage\n    // as that supposes the password was sucessfully guessed.\n  SigninLogs\n  | where ResultType in (\"0\", \"50074\", \"50076\") \n) on $left.SourceIP == $right.IPAddress\n| extend timestamp = TimeGenerated, IPCustomEntity = SourceIP, AccountCustomEntity = UserPrincipalName\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_27')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Large Number of Distinct Failed User Logins",
                                             "query":  "//This creates an incident in the event a Pulse Secure VPN server experiences failed login attempts from a large number of distinct users.\n//\n\nlet timeframe = ago(1h);\nlet threshold = 100;\nPulseConnectSecure\n| where TimeGenerated \u003e= timeframe\n| where Messages startswith \"Login failed\"\n| summarize dcount(User) by Computer, bin(TimeGenerated, 15m)\n| where dcount_User \u003e threshold\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_28')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "Multiple Failed VPN User Logins",
                                             "query":  "//Creates an incident in the event of multiple unsuccessful attempts to log into the VPN server, which could indicate a potential brute force attack.\n//\n\nlet timeframe = ago(1h);\nlet threshold = 20;\nPulseConnectSecure\n| where TimeGenerated \u003e= timeframe\n| where Messages contains \"Login failed\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by User, Source_IP\n| where count_ \u003e threshold\n| extend timestamp = StartTime, AccountCustomEntity = User, IPCustomEntity = Source_IP\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_29')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Base64 encoded Windows process command-lines",
                                             "query":  "//Identifies instances of a base64 encoded PE file header seen in the process command line parameter.\n//\n\nlet timeframe = 1d;\nlet ProcessCreationEvents=() {\nlet processEvents=SecurityEvent\n| where EventID==4688\n| where isnotempty(CommandLine)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by Computer, Account = SubjectUserName, AccountDomain = SubjectDomainName,\nFileName = Process, CommandLine, ParentProcessName;\nprocessEvents};\nProcessCreationEvents\n| where CommandLine contains \"TVqQAAMAAAAEAAA\"\n| where StartTimeUtc \u003e= ago(timeframe)\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_30')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "Excessive Windows logon failures",
                                             "query":  "//User has over 50 Windows logon failures today and at least 33% of the count of logon failures over the previous 7 days.\n//\n\nlet starttime = 8d;\nlet endtime = 1d;\nlet threshold = 0.333;\nlet countlimit = 50;\nSecurityEvent\n| where TimeGenerated \u003e= ago(endtime)\n| where EventID == 4625 and AccountType =~ \"User\"\n| where IpAddress !in (\"127.0.0.1\", \"::1\")\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), CountToday = count() by EventID, Account, LogonTypeName, SubStatus, AccountType, Computer, WorkstationName, IpAddress\n| join kind=leftouter (\n    SecurityEvent \n    | where TimeGenerated between (ago(starttime) .. ago(endtime))\n    | where EventID == 4625 and AccountType =~ \"User\"\n    | where IpAddress !in (\"127.0.0.1\", \"::1\")\n    | summarize CountPrev7day = count() by EventID, Account, LogonTypeName, SubStatus, AccountType, Computer, WorkstationName, IpAddress\n) on EventID, Account, LogonTypeName, SubStatus, AccountType, Computer, WorkstationName, IpAddress\n| where CountToday \u003e= coalesce(CountPrev7day,0)*threshold and CountToday \u003e= countlimit\n| extend Reason = case(\nSubStatus == '0xc000005e', 'No logon servers available to service the logon request',\nSubStatus == '0xc0000062', 'Account name is not properly formatted',\nSubStatus == '0xc0000064', 'Account name does not exist',\nSubStatus == '0xc000006a', 'Incorrect password',    \nSubStatus == '0xc000006d', 'Bad user name or password',\nSubStatus == '0xc000006f', 'User logon blocked by account restriction',\nSubStatus == '0xc000006f', 'User logon outside of restricted logon hours',\nSubStatus == '0xc0000070', 'User logon blocked by workstation restriction',\nSubStatus == '0xc0000071', 'Password has expired',\nSubStatus == '0xc0000072', 'Account is disabled',\nSubStatus == '0xc0000133', 'Clocks between DC and other computer too far out of sync',\nSubStatus == '0xc000015b', 'The user has not been granted the requested logon right at this machine',\nSubStatus == '0xc0000193', 'Account has expirated',\nSubStatus == '0xc0000224', 'User is required to change password at next logon',\nSubStatus == '0xc0000234', 'Account is currently locked out',\nstrcat('Unknown reason substatus: ', SubStatus))\n| extend WorkstationName = iff(WorkstationName == \"-\" or isempty(WorkstationName), Computer , WorkstationName) \n| project StartTimeUtc, EndTimeUtc, EventID, Account, LogonTypeName, SubStatus, Reason, AccountType, Computer, WorkstationName, IpAddress, CountToday, CountPrev7day, Avg7Day = CountPrev7day/7\n| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc), Computer = make_set(Computer,128), IpAddressList = make_set(IpAddress,128), sum(CountToday), sum(CountPrev7day), avg(Avg7Day) \nby EventID, Account, LogonTypeName, SubStatus, Reason, AccountType, WorkstationName\n| order by sum_CountToday desc nulls last \n| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = WorkstationName\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_31')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Process executed from binary hidden in Base64 encoded file",
                                             "query":  "//Encoding malicious software is a technique used to obfuscate files from detection. \n//The first CommandLine component is looking for Python decoding base64. \n//The second CommandLine component is looking for Bash/sh command line base64 decoding.\n//The third one is looking for Ruby decoding base64.\n//\n\nlet timeframe = 1d;\nlet ProcessCreationEvents=() {\nlet processEvents=SecurityEvent\n| where EventID==4688\n| where isnotempty(CommandLine)\n| project TimeGenerated, Computer, Account = SubjectUserName, AccountDomain = SubjectDomainName, FileName = Process, CommandLine, ParentProcessName;\nprocessEvents;\n};\nProcessCreationEvents \n| where TimeGenerated \u003e ago(timeframe) \n| where CommandLine contains \".decode('base64')\"\n        or CommandLine contains \"base64 --decode\"\n        or CommandLine contains \".decode64(\" \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), CountToday = count() by Computer, Account, AccountDomain, FileName, CommandLine, ParentProcessName \n| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_32')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Group added to built in domain local or global group",
                                             "query":  "//Identifies when a recently created Group was added to a privileged built in domain local group or global group such as the \n//Enterprise Admins, Cert Publishers or DnsAdmins.  Be sure to verify this is an expected addition.\n//References: For AD SID mappings - https://docs.microsoft.com/windows/security/identity-protection/access-control/active-directory-security-groups.\n//\n\nlet timeframe = 1h;\nlet WellKnownLocalSID = \"S-1-5-32-5[0-9][0-9]$\";\nlet WellKnownGroupSID = \"S-1-5-21-[0-9]*-[0-9]*-[0-9]*-5[0-9][0-9]$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1102$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1103$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-498$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1000$\";\nlet GroupAddition = SecurityEvent \n| where TimeGenerated \u003e ago(timeframe)\n// 4728 - A member was added to a security-enabled global group\n// 4732 - A member was added to a security-enabled local group\n// 4756 - A member was added to a security-enabled universal group  \n| where EventID in (\"4728\", \"4732\", \"4756\") \n| where AccountType =~ \"User\" and MemberName == \"-\"\n// Exclude Remote Desktop Users group: S-1-5-32-555\n| where TargetSid !in (\"S-1-5-32-555\")\n| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID\n| project GroupAddTime = TimeGenerated, GroupAddEventID = EventID, GroupAddActivity = Activity, GroupAddComputer = Computer, \nGroupAddTargetUserName = TargetUserName, GroupAddTargetDomainName = TargetDomainName, GroupAddTargetSid = TargetSid,  \nGroupAddSubjectUserName = SubjectUserName, GroupAddSubjectUserSid = SubjectUserSid, GroupSid = MemberSid;\nlet GroupCreated = SecurityEvent\n| where TimeGenerated \u003e ago(timeframe)\n// 4727 - A security-enabled global group was created\n// 4731 - A security-enabled local group was created\n// 4754 - A security-enabled universal group was created\n| where EventID in (\"4727\", \"4731\", \"4754\")\n| where AccountType =~ \"User\"\n| project GroupCreateTime = TimeGenerated, GroupCreateEventID = EventID, GroupCreateActivity = Activity, GroupCreateComputer = Computer, \nGroupCreateTargetUserName = TargetUserName, GroupCreateTargetDomainName = TargetDomainName, GroupCreateSubjectUserName = SubjectUserName, \nGroupCreateSubjectDomainName = SubjectDomainName, GroupCreateSubjectUserSid = SubjectUserSid, GroupSid = TargetSid;\nGroupCreated\n| join (\nGroupAddition\n) on GroupSid \n| extend timestamp = GroupCreateTime, AccountCustomEntity = GroupCreateSubjectUserName, HostCustomEntity = GroupCreateComputer\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_33')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "Failed logon attempts within 10 mins",
                                             "query":  "//Identifies when failed logon attempts are 20 or higher during a 10 minute period (2 failed logons per minute minimum).\n//\n\nlet timeframe = 10m;\nlet threshold = 20;\nSecurityEvent \n| where TimeGenerated \u003e= ago(timeframe)\n| where EventID == 4625\n| where AccountType =~ \"User\"\n| summarize min(TimeGenerated), max(TimeGenerated), FailedLogonCount = count() by EventID, Activity, Computer, Account, \nTargetAccount, TargetUserName, TargetDomainName, LogonType, LogonTypeName, LogonProcessName, Status, SubStatus\n| where FailedLogonCount \u003e= threshold\n| project StartTimeUtc = min_TimeGenerated, EndTimeUtc = max_TimeGenerated, FailedLogonCount, EventID, Activity, Computer, \nAccount, TargetAccount, TargetUserName, TargetDomainName, LogonType, LogonTypeName, LogonProcessName, Status, SubStatus\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_34')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Malware in the recycle bin",
                                             "query":  "//Identifies malware that has been hidden in the recycle bin.\n//References: https://azure.microsoft.com/blog/how-azure-security-center-helps-reveal-a-cyberattack/.\n//\n\nlet timeframe = 1d;\nlet procList = dynamic([\"cmd.exe\",\"ftp.exe\",\"schtasks.exe\",\"powershell.exe\",\"rundll32.exe\",\"regsvr32.exe\",\"msiexec.exe\"]);\nlet ProcessCreationEvents=() {\nlet processEvents=SecurityEvent\n| where EventID==4688\n| where isnotempty(CommandLine)\n| project TimeGenerated, Computer, Account = SubjectUserName, AccountDomain = SubjectDomainName, NewProcessName,\nFileName = Process, CommandLine,  ParentProcessName;\nprocessEvents};\nProcessCreationEvents \n| where TimeGenerated \u003e= ago(timeframe)\n| where FileName in~ (procList)\n| where CommandLine contains \":\\\\recycler\"\n| project StartTimeUtc = TimeGenerated, Computer, Account, NewProcessName, FileName, CommandLine, ParentProcessName\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_35')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "SecurityEvent - Multiple authentication failures followed by a success",
                                             "query":  "//Identifies accounts who have failed to logon to the domain multiple times in a row, followed by a successful authentication\n//within a short time frame. Multiple failed attempts followed by a success can be an indication of a brute force attempt or\n//possible mis-configuration of a service account within an environment.\n//The lookback is set to 6h and the authentication window and threshold are set to 1h and 5, meaning we need to see a minimum\n//of 5 failures followed by a success for an account within 1 hour to surface an alert.\n//\n\nlet timeRange = 6h;\nlet authenticationWindow = 1h;\nlet authenticationThreshold = 5;\nSecurityEvent\n| where TimeGenerated \u003e ago(timeRange)\n| where EventID == 4624 or EventID == 4625\n| where IpAddress != \"-\" and isnotempty(Account)\n| extend Outcome = iff(EventID == 4624, \"Success\", \"Failure\")\n// bin outcomes into 5 minute windows to reduce the volume of data\n| summarize OutcomeCount=count() by Account, IpAddress, Computer, Outcome, bin(TimeGenerated, 5m)\n| project TimeGenerated, Account, IpAddress, Computer, Outcome, OutcomeCount\n// sort ready for sessionizing - by account and time of the authentication outcome\n| sort by Account asc, TimeGenerated asc\n| serialize \n// sessionize into failure groupings until either the account changes or there is a success\n| extend SessionStartedUtc = row_window_session(TimeGenerated, timeRange, authenticationWindow, Account != prev(Account) or prev(Outcome) == \"Success\")\n// count the failures in each session\n| summarize FailureCountBeforeSuccess=sumif(OutcomeCount, Outcome == \"Failure\"), StartTime=min(TimeGenerated), EndTime=max(TimeGenerated), makelist(Outcome), makeset(Computer), makeset(IpAddress) by SessionStartedUtc, Account\n// the session must not start with a success, and must end with one\n| where array_index_of(list_Outcome, \"Success\") != 0\n| where array_index_of(list_Outcome, \"Success\") == array_length(list_Outcome) - 1\n| project-away SessionStartedUtc, list_Outcome \n// where the number of failures before the success is above the threshold \n| where FailureCountBeforeSuccess \u003e= authenticationThreshold\n// expand out ip and computer for customer entity assignment\n| mvexpand set_IpAddress, set_Computer\n| extend IpAddress = tostring(set_IpAddress), Computer = tostring(set_Computer)\n| extend timestamp=StartTime, AccountCustomEntity=Account, HostCustomEntity=Computer, IPCustomEntity=IpAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_36')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "AD account with don't expire password - disabled",
                                             "query":  "//Identifies whenever a user account has the setting \"Password Never Expires\" in the user account properties selected.\n//This is indicated in Security event 4738 in the EventData item labeled UserAccountControl with an included value of %%2089 \n//%%2089 resolves to \"Dont Expire Password - Disabled\".\n//\n\nlet timeframe = 1d;\nSecurityEvent\n| where TimeGenerated \u003e= ago(timeframe) \n| where EventID == 4738\n// 2089 value indicates the Don't Expire Password value has been set\n| where UserAccountControl has \"%%2089\" \n| extend Value_2089 = iff(UserAccountControl has \"%%2089\",\"'Don't Expire Password' - Disabled\", \"Not Changed\")\n// 2050 indicates that the Password Not Required value is NOT set, this often shows up at the same time as a 2089 and is the recommended value.  This value may not be in the event. \n| extend Value_2050 = iff(UserAccountControl has \"%%2050\",\"'Password Not Required' - Disabled\", \"Not Changed\")\n// If value %%2082 is present in the 4738 event, this indicates the account has been configured to logon WITHOUT a password. Generally you should only see this value when an account is created and only in Event 4720: Account Creation Event.  \n| extend Value_2082 = iff(UserAccountControl has \"%%2082\",\"'Password Not Required' - Enabled\", \"Not Changed\")\n| project StartTimeUtc = TimeGenerated, EventID, Computer, TargetUserName, TargetDomainName, AccountType, UserAccountControl, Value_2089, Value_2050, Value_2082\n| extend timestamp = StartTimeUtc, AccountCustomEntity = TargetUserName, HostCustomEntity = Computer\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_37')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "AD user created password not set within 24-48 hours",
                                             "query":  "//Identifies whenever a new account is created with a default password and password is not changed within 24-48 hours.\n//Simple version, can be more precise with Windowing, but not necessary if run as an alert on a daily basis.\n//Effectively, there is an event 4722 indicating a user enabled and no event 4723 indicating a password was changed within in that day or the next day.\n//\n\nlet starttime = 2d;\nlet endtime = 1d;\nSecurityEvent\n// include yesterday and not today, so we can confirm a match occurs within the next day\n| where TimeGenerated \u003e= startofday(ago(starttime)) and TimeGenerated \u003c= startofday(ago(endtime))  \n// 4722: User Account Enabled\n| where EventID == 4722 \n// Removing Machine Accounts\n| where TargetUserName !endswith \"$\" \n| join kind= leftanti (\n  SecurityEvent\n  //verify over the last 2 days\n  | where TimeGenerated \u003e= startofday(ago(starttime))\n  // Attempt made to change password\n  | where EventID == 4723\n  // Removing Machine Accounts\n  | where TargetUserName !endswith \"$\"\n) on TargetUserName, TargetDomainName\n| project StartTimeUtc = TimeGenerated, EventID, Computer, TargetUserName, TargetDomainName, SubjectUserName\n| extend timestamp = StartTimeUtc, AccountCustomEntity = TargetUserName, HostCustomEntity = Computer\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_38')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Potential Kerberoasting",
                                             "query":  "//A service principal name (SPN) is used to uniquely identify a service instance in a Windows environment. \n//Each SPN is usually associated with a service account. Organizations may have used service accounts with weak passwords in their environment. \n//An attacker can try requesting Kerberos ticket-granting service (TGS) service tickets for any SPN from a domain controller (DC) which contains \n//a hash of the Service account. This can then be used for offline cracking. This hunting query looks for accounts that are generating excessive \n//requests to different resources within the last hour compared with the previous 24 hours.  Normal users would not make an unusually large number \n//of request within a small time window. This is based on 4769 events which can be very noisy so environment based tweaking might be needed.\n//\n\nlet starttime = 1d;\nlet endtime = 1h;\nlet prev23hThreshold = 4;\nlet prev1hThreshold = 15;\nlet Kerbevent =\nSecurityEvent\n| where TimeGenerated \u003e= ago(starttime)\n| where EventID == 4769\n| parse EventData with * 'TicketEncryptionType\"\u003e' TicketEncryptionType \"\u003c\" *\n| where TicketEncryptionType == '0x17'\n| parse EventData with * 'TicketOptions\"\u003e' TicketOptions \"\u003c\" *\n| where TicketOptions == '0x40810000'\n| parse EventData with * 'Status\"\u003e' Status \"\u003c\" *\n| where Status == '0x0'\n| parse EventData with * 'ServiceName\"\u003e' ServiceName \"\u003c\" *\n| where ServiceName !contains \"$\" and ServiceName !contains \"krbtgt\" \n| parse EventData with * 'TargetUserName\"\u003e' TargetUserName \"\u003c\" *\n| where TargetUserName !contains \"$@\" and TargetUserName !contains ServiceName\n| parse EventData with * 'IpAddress\"\u003e::ffff:' ClientIPAddress \"\u003c\" *;\nlet Kerbevent23h = Kerbevent\n| where TimeGenerated \u003e= ago(starttime) and TimeGenerated \u003c ago(endtime)\n| summarize ServiceNameCountPrev23h = dcount(ServiceName), ServiceNameSet23h = makeset(ServiceName) \nby Computer, TargetUserName, ClientIPAddress, TicketOptions, TicketEncryptionType, Status\n| where ServiceNameCountPrev23h \u003c prev23hThreshold;\nlet Kerbevent1h = \nKerbevent\n| where TimeGenerated \u003e= ago(endtime)\n| summarize min(TimeGenerated), max(TimeGenerated), ServiceNameCountPrev1h = dcount(ServiceName), ServiceNameSet1h = makeset(ServiceName) \nby Computer, TargetUserName, ClientIPAddress, TicketOptions, TicketEncryptionType, Status;\nKerbevent1h \n| join kind=leftanti\n(\nKerbevent23h\n) on TargetUserName\n// Threshold value set above is based on testing, this value may need to be changed for your environment.\n| where ServiceNameCountPrev1h \u003e prev1hThreshold\n| project StartTimeUtc = min_TimeGenerated, EndTimeUtc = max_TimeGenerated, TargetUserName, Computer, ClientIPAddress, TicketOptions, \nTicketEncryptionType, Status, ServiceNameCountPrev1h, ServiceNameSet1h\n| extend timestamp = StartTimeUtc, AccountCustomEntity = TargetUserName, HostCustomEntity = Computer, IPCustomEntity = ClientIPAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_39')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Powershell Empire cmdlets seen in command line",
                                             "query":  "//Identifies instances of PowerShell Empire cmdlets in powershell process command line data.\n//\n\nlet timeframe = 1d;\nlet regexEmpire = @\"SetDelay|GetDelay|Set-LostLimit|Get-LostLimit|Set-Killdate|Get-Killdate|Set-WorkingHours|Get-WorkingHours|Get-Sysinfo|Add-Servers|Invoke-ShellCommand|Start-AgentJob|Update-Profile|Get-FilePart|Encrypt-Bytes|Decrypt-Bytes|Encode-Packet|Decode-Packet|Send-Message|Process-Packet|Process-Tasking|Get-Task|Start-Negotiate|Invoke-DllInjection|Invoke-ReflectivePEInjection|Invoke-Shellcode|Invoke-ShellcodeMSIL|Get-ChromeDump|Get-ClipboardContents|Get-IndexedItem|Get-Keystrokes|Invoke-Inveigh|Invoke-NetRipper|local:Invoke-PatchDll|Invoke-NinjaCopy|Get-Win32Types|Get-Win32Constants|Get-Win32Functions|Sub-SignedIntAsUnsigned|Add-SignedIntAsUnsigned|Compare-Val1GreaterThanVal2AsUInt|Convert-UIntToInt|Test-MemoryRangeValid|Write-BytesToMemory|Get-DelegateType|Get-ProcAddress|Enable-SeDebugPrivilege|Invoke-CreateRemoteThread|Get-ImageNtHeaders|Get-PEBasicInfo|Get-PEDetailedInfo|Import-DllInRemoteProcess|Get-RemoteProcAddress|Copy-Sections|Update-MemoryAddresses|Import-DllImports|Get-VirtualProtectValue|Update-MemoryProtectionFlags|Update-ExeFunctions|Copy-ArrayOfMemAddresses|Get-MemoryProcAddress|Invoke-MemoryLoadLibrary|Invoke-MemoryFreeLibrary|Out-Minidump|Get-VaultCredential|Invoke-DCSync|Translate-Name|Get-NetDomain|Get-NetForest|Get-NetForestDomain|Get-DomainSearcher|Get-NetComputer|Get-NetGroupMember|Get-NetUser|Invoke-Mimikatz|Invoke-PowerDump|Invoke-TokenManipulation|Exploit-JMXConsole|Exploit-JBoss|Invoke-Thunderstruck|Invoke-VoiceTroll|Set-WallPaper|Invoke-PsExec|Invoke-SSHCommand|Invoke-PSInject|Invoke-RunAs|Invoke-SendMail|Invoke-Rule|Get-OSVersion|Select-EmailItem|View-Email|Get-OutlookFolder|Get-EmailItems|Invoke-MailSearch|Get-SubFolders|Get-GlobalAddressList|Invoke-SearchGAL|Get-SMTPAddress|Disable-SecuritySettings|Reset-SecuritySettings|Get-OutlookInstance|New-HoneyHash|Set-MacAttribute|Invoke-PatchDll|Get-SecurityPackages|Install-SSP|Invoke-BackdoorLNK|New-ElevatedPersistenceOption|New-UserPersistenceOption|Add-Persistence|Invoke-CallbackIEX|Add-PSFirewallRules|Invoke-EventLoop|Invoke-PortBind|Invoke-DNSLoop|Invoke-PacketKnock|Invoke-CallbackLoop|Invoke-BypassUAC|Get-DecryptedCpassword|Get-GPPInnerFields|Invoke-WScriptBypassUAC|Get-ModifiableFile|Get-ServiceUnquoted|Get-ServiceFilePermission|Get-ServicePermission|Invoke-ServiceUserAdd|Invoke-ServiceCMD|Write-UserAddServiceBinary|Write-CMDServiceBinary|Write-ServiceEXE|Write-ServiceEXECMD|Restore-ServiceEXE|Invoke-ServiceStart|Invoke-ServiceStop|Invoke-ServiceEnable|Invoke-ServiceDisable|Get-ServiceDetail|Find-DLLHijack|Find-PathHijack|Write-HijackDll|Get-RegAlwaysInstallElevated|Get-RegAutoLogon|Get-VulnAutoRun|Get-VulnSchTask|Get-UnattendedInstallFile|Get-Webconfig|Get-ApplicationHost|Write-UserAddMSI|Invoke-AllChecks|Invoke-ThreadedFunction|Test-Login|Get-UserAgent|Test-Password|Get-ComputerDetails|Find-4648Logons|Find-4624Logons|Find-AppLockerLogs|Find-PSScriptsInPSAppLog|Find-RDPClientConnections|Get-SystemDNSServer|Invoke-Paranoia|Invoke-WinEnum{|Get-SPN|Invoke-ARPScan|Invoke-Portscan|Invoke-ReverseDNSLookup|Invoke-SMBScanner|New-InMemoryModule|Add-Win32Type|Export-PowerViewCSV|Get-MacAttribute|Copy-ClonedFile|Get-IPAddress|Convert-NameToSid|Convert-SidToName|Convert-NT4toCanonical|Get-Proxy|Get-PathAcl|Get-NameField|Convert-LDAPProperty|Get-NetDomainController|Add-NetUser|Add-NetGroupUser|Get-UserProperty|Find-UserField|Get-UserEvent|Get-ObjectAcl|Add-ObjectAcl|Invoke-ACLScanner|Get-GUIDMap|Get-ADObject|Set-ADObject|Get-ComputerProperty|Find-ComputerField|Get-NetOU|Get-NetSite|Get-NetSubnet|Get-DomainSID|Get-NetGroup|Get-NetFileServer|SplitPath|Get-DFSshare|Get-DFSshareV1|Get-DFSshareV2|Get-GptTmpl|Get-GroupsXML|Get-NetGPO|Get-NetGPOGroup|Find-GPOLocation|Find-GPOComputerAdmin|Get-DomainPolicy|Get-NetLocalGroup|Get-NetShare|Get-NetLoggedon|Get-NetSession|Get-NetRDPSession|Invoke-CheckLocalAdminAccess|Get-LastLoggedOn|Get-NetProcess|Find-InterestingFile|Invoke-CheckWrite|Invoke-UserHunter|Invoke-StealthUserHunter|Invoke-ProcessHunter|Invoke-EventHunter|Invoke-ShareFinder|Invoke-FileFinder|Find-LocalAdminAccess|Get-ExploitableSystem|Invoke-EnumerateLocalAdmin|Get-NetDomainTrust|Get-NetForestTrust|Find-ForeignUser|Find-ForeignGroup|Invoke-MapDomainTrust|Get-Hex|Create-RemoteThread|Get-FoxDump|Decrypt-CipherText|Get-Screenshot|Start-HTTP-Server|Local:Invoke-CreateRemoteThread|Local:Get-Win32Functions|Local:Inject-NetRipper|GetCommandLine|ElevatePrivs|Get-RegKeyClass|Get-BootKey|Get-HBootKey|Get-UserName|Get-UserHashes|DecryptHashes|DecryptSingleHash|Get-UserKeys|DumpHashes|Enable-SeAssignPrimaryTokenPrivilege|Enable-Privilege|Set-DesktopACLs|Set-DesktopACLToAllowEveryone|Get-PrimaryToken|Get-ThreadToken|Get-TokenInformation|Get-UniqueTokens|Find-GPOLocation|Find-GPOComputerAdmin|Get-DomainPolicy|Get-NetLocalGroup|Get-NetShare|Get-NetLoggedon|Get-NetSession|Get-NetRDPSession|Invoke-CheckLocalAdminAccess|Get-LastLoggedOn|Get-NetProcess|Find-InterestingFile|Invoke-CheckWrite|Invoke-UserHunter|Invoke-StealthUserHunter|Invoke-ProcessHunter|Invoke-EventHunter|Invoke-ShareFinder|Invoke-FileFinder|Find-LocalAdminAccess|Get-ExploitableSystem|Invoke-EnumerateLocalAdmin|Get-NetDomainTrust|Get-NetForestTrust|Find-ForeignUser|Find-ForeignGroup|Invoke-MapDomainTrust|Get-Hex|Create-RemoteThread|Get-FoxDump|Decrypt-CipherText|Get-Screenshot|Start-HTTP-Server|Local:Invoke-CreateRemoteThread|Local:Get-Win32Functions|Local:Inject-NetRipper|GetCommandLine|ElevatePrivs|Get-RegKeyClass|Get-BootKey|Get-HBootKey|Get-UserName|Get-UserHashes|DecryptHashes|DecryptSingleHash|Get-UserKeys|DumpHashes|Enable-SeAssignPrimaryTokenPrivilege|Enable-Privilege|Set-DesktopACLs|Set-DesktopACLToAllowEveryone|Get-PrimaryToken|Get-ThreadToken|Get-TokenInformation|Get-UniqueTokens|Invoke-ImpersonateUser|Create-ProcessWithToken|Free-AllTokens|Enum-AllTokens|Invoke-RevertToSelf|Set-Speaker(\\$Volume){\\$wshShell|Local:Get-RandomString|Local:Invoke-PsExecCmd|Get-GPPPassword|Local:Inject-BypassStuff|Local:Invoke-CopyFile\\(\\$sSource,|ind-Fruit|New-IPv4Range|New-IPv4RangeFromCIDR|Parse-Hosts|Parse-ILHosts|Exclude-Hosts|Get-TopPort|Parse-Ports|Parse-IpPorts|Remove-Ports|Write-PortscanOut|Convert-SwitchtoBool|Get-ForeignUser|Get-ForeignGroup\";\nlet ProcessCreationEvents=() {\nlet processEvents=SecurityEvent\n| where EventID==4688\n| where isnotempty(CommandLine)\n| project TimeGenerated, Computer, Account = SubjectUserName, AccountDomain = SubjectDomainName, FileName = Process, CommandLine, ParentProcessName;\nprocessEvents};\nlet decodedPS = ProcessCreationEvents\n| where TimeGenerated \u003e= ago(timeframe) \n| where CommandLine contains \" -encodedCommand\"\n| parse kind=regex flags=i CommandLine with * \"-EncodedCommand \" encodedCommand\n| project StartTimeUtc = TimeGenerated, encodedCommand = tostring(split(encodedCommand, ' ')[0]), CommandLine\n// Note: currently the base64_decodestring function is limited to supporting UTF8\n| extend decodedCommand = translate('\\0','', base64_decodestring(substring(encodedCommand, 0, strlen(encodedCommand) -  (strlen(encodedCommand) %8)))), encodedCommand, CommandLine , strlen(encodedCommand);\n(decodedPS\n| union \n(ProcessCreationEvents\n| where TimeGenerated \u003e= ago(timeframe)\n| where FileName in~ (\"powershell.exe\",\"powershell_ise.exe\")\n| where CommandLine !contains \"-encodedcommand\")\n| extend StartTimeUtc = TimeGenerated\n)\n| where CommandLine matches regex regexEmpire\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_40')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "Multiple RDP connections from Single System",
                                             "query":  "//Identifies when an RDP connection is made to multiple systems and above the normal for the previous 7 days.  \n//Connections from the same system with the same account within the same day.\n//RDP connections are indicated by the EventID 4624 with LogonType = 10\n//\n\nlet endtime = 1d;\nlet starttime = 8d;\nlet threshold = 2.0;\nSecurityEvent\n| where TimeGenerated \u003e= ago(endtime) \n| where EventID == 4624 and LogonType == 10\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ComputerCountToday = dcount(Computer), ComputerSet = makeset(Computer), ProcessSet = makeset(ProcessName)  \nby Account, IpAddress, AccountType, Activity, LogonTypeName\n| join kind=inner (\nSecurityEvent\n| where TimeGenerated \u003e= ago(starttime) and TimeGenerated \u003c ago(endtime) \n| where EventID == 4624 and LogonType == 10\n| summarize ComputerCountPrev7Days = dcount(Computer) by Account, IpAddress\n) on Account, IpAddress\n| extend Ratio = ComputerCountToday/(ComputerCountPrev7Days*1.0)\n// Where the ratio of today to previous 7 days is more than double.\n| where Ratio \u003e threshold\n| project StartTimeUtc, EndTimeUtc, Account, IpAddress, ComputerSet, ComputerCountToday, ComputerCountPrev7Days, Ratio, AccountType, Activity, LogonTypeName, ProcessSet\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, IPCustomEntity = IpAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_41')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "RDP Nesting",
                                             "query":  "//Identifies when an RDP connection is made to a first system and then an RDP connection is made from the first system \n//to another system with the same account within the 60 minutes. Additionally, if historically daily  \n//RDP connections are indicated by the logged EventID 4624 with LogonType = 10\n//\n\nlet endtime = 1d;\nlet starttime = 8d;\n// The threshold below excludes matching on RDP connection computer counts of 5 or more by a given account and IP in a given day.  Change the threshold as needed.\nlet threshold = 5;\nSecurityEvent\n| where TimeGenerated \u003e= ago(endtime) \n| where EventID == 4624 and LogonType == 10\n// Labeling the first RDP connection time, computer and ip\n| extend FirstHop = TimeGenerated, FirstComputer = toupper(Computer), FirstIPAddress = IpAddress, Account = tolower(Account)  \n| join kind=inner (\nSecurityEvent\n| where TimeGenerated \u003e= ago(endtime) \n| where EventID == 4624 and LogonType == 10\n// Labeling the second RDP connection time, computer and ip\n| extend SecondHop = TimeGenerated, SecondComputer = toupper(Computer), SecondIPAddress = IpAddress, Account = tolower(Account)\n) on Account\n// Make sure that the first connection is after the second connection --\u003e SecondHop \u003e FirstHop\n// Then identify only RDP to another computer from within the first RDP connection by only choosing matches where the Computer names do not match --\u003e FirstComputer != SecondComputer\n// Then make sure the IPAddresses do not match by excluding connections from the same computers with first hop RDP connections to multiple computers --\u003e FirstIPAddress != SecondIPAddress\n| where FirstComputer != SecondComputer and FirstIPAddress != SecondIPAddress and SecondHop \u003e FirstHop\n// where the second hop occurs within 30 minutes of the first hop\n| where SecondHop \u003c= FirstHop+30m\n| distinct Account, FirstHop, FirstComputer, FirstIPAddress, SecondHop, SecondComputer, SecondIPAddress, AccountType, Activity, LogonTypeName, ProcessName\n// use left anti to exclude anything from the previous 7 days where the Account and IP has connected 5 or more computers.\n| join kind=leftanti (\nSecurityEvent\n| where TimeGenerated \u003e= ago(starttime) and TimeGenerated \u003c ago(endtime) \n| where EventID == 4624 and LogonType == 10\n| summarize makeset(Computer), ComputerCount = dcount(Computer) by bin(TimeGenerated, 1d), Account = tolower(Account), IpAddress\n// Connection count to computer by same account and IP to exclude counts of 5 or more on a given day\n| where ComputerCount \u003e= threshold\n| mvexpand set_Computer\n| extend Computer = toupper(set_Computer)\n) on Account, $left.SecondComputer == $right.Computer, $left.SecondIPAddress == $right.IpAddress\n| summarize FirstHopFirstSeen = min(FirstHop), FirstHopLastSeen = max(FirstHop) by Account, FirstComputer, FirstIPAddress, SecondHop, SecondComputer, \nSecondIPAddress, AccountType, Activity, LogonTypeName, ProcessName\n| extend timestamp = FirstHopFirstSeen, AccountCustomEntity = Account, HostCustomEntity = FirstComputer, IPCustomEntity = FirstIPAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_42')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Rare RDP Connections",
                                             "query":  "//Identifies when an RDP connection is new or rare related to any logon type by a given account today based on comparison with the previous 14 days.\n//RDP connections are indicated by the EventID 4624 with LogonType = 10\n//\n\nlet starttime = 14d;\nlet endtime = 1d;\nSecurityEvent\n| where TimeGenerated \u003e= ago(endtime) \n| where EventID == 4624 and LogonType == 10\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ConnectionCount = count() \nby Account = tolower(Account), Computer = toupper(Computer), IpAddress, AccountType, Activity, LogonTypeName, ProcessName\n// use left anti to exclude anything from the previous 14 days that is not rare\n| join kind=leftanti (\nSecurityEvent\n| where TimeGenerated between (ago(starttime) .. ago(endtime))\n| where EventID == 4624\n| summarize by Computer = toupper(Computer), IpAddress, Account = tolower(Account)\n) on Account, Computer\n| summarize StartTime = min(StartTime), EndTime = max(EndTime), ConnectionCount = sum(ConnectionCount)  \nby Account, Computer, IpAddress, AccountType, Activity, LogonTypeName, ProcessName\n| extend timestamp = StartTime, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_43')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Security Event log cleared",
                                             "query":  "//Checks for event id 1102 which indicates the security event log was cleared. \n//It uses Event Source Name \"Microsoft-Windows-Eventlog\" to avoid generating false positives from other sources, like AD FS servers for instance.\n//\n\nlet timeframe = 1d;\nSecurityEvent\n| where TimeGenerated \u003e= ago(timeframe)\n| where EventID == 1102 and EventSourceName == \"Microsoft-Windows-Eventlog\" \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), EventCount = count() by Computer, Account, EventID, Activity\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_44')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Process execution frequency anomaly",
                                             "query":  "//Identifies anomalous spike in frequency of executions of sensitive processes which are often leveraged as attack vectors. \n//The query leverages KQL built-in anomaly detection algorithms to find large deviations from baseline patterns. \n//Sudden increases in execution frequency of sensitive processes should be further investigated for malicious activity.\n//Tune the values from 1.5 to 3 in series_decompose_anomalies for further outliers or based on custom threshold values for score.\n//\n\nlet starttime = 14d;\nlet endtime = 1d;\nlet timeframe = 1h;\nlet TotalEventsThreshold = 5;\nlet ExeList = dynamic([\"powershell.exe\",\"cmd.exe\",\"wmic.exe\",\"psexec.exe\",\"cacls.exe\",\"rundll.exe\"]);\nlet TimeSeriesData = \nSecurityEvent\n| where EventID == 4688 | extend Process = tolower(Process)\n| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))\n| where Process in (ExeList)\n| project TimeGenerated, Computer, AccountType, Account, Process\n| make-series Total=count() on TimeGenerated from ago(starttime) to ago(endtime) step timeframe by Process;\nlet TimeSeriesAlerts = TimeSeriesData\n| extend (anomalies, score, baseline) = series_decompose_anomalies(Total, 1.5, -1, 'linefit')\n| mv-expand Total to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double), score to typeof(double), baseline to typeof(long)\n| where anomalies \u003e 0\n| project Process, TimeGenerated, Total, baseline, anomalies, score\n| where Total \u003e TotalEventsThreshold;\nTimeSeriesAlerts\n| join (\nSecurityEvent\n| where EventID == 4688 | extend Process = tolower(Process)\n| summarize CommandlineCount = count() by bin(TimeGenerated, 1h), Process, CommandLine, Computer, Account\n) on Process, TimeGenerated \n| project AnomalyHour = TimeGenerated, Computer, Account, Process, CommandLine, CommandlineCount, Total, baseline, anomalies, score \n| extend timestamp = AnomalyHour, AccountCustomEntity = Account, HostCustomEntity = Computer\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_45')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "Account added and removed from privileged groups",
                                             "query":  "//Identifies accounts that are added to privileged group and then quickly removed, which could be a sign of compromise. \n//\n\nlet timeframe = 1d;\nlet WellKnownLocalSID = \"S-1-5-32-5[0-9][0-9]$\";\nlet WellKnownGroupSID = \"S-1-5-21-[0-9]*-[0-9]*-[0-9]*-5[0-9][0-9]$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1102$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1103$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-498$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1000$\";\nlet AC_Add = \nSecurityEvent\n| where TimeGenerated \u003e= ago(timeframe)\n// Event ID related to member addition.\n| where EventID in (4728, 4732,4756) \n| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID  \n| parse EventData with * '\"MemberName\"\u003e' AccountAdded \",OU\" * \n| where isnotempty(AccountAdded)\n| extend GroupAddedTo = TargetUserName, AddingAccount = Account \n| extend  AccountAdded_GroupAddedTo_AddingAccount = strcat(AccountAdded, \"||\", GroupAddedTo, \"||\", AddingAccount )\n| project AccountAdded_GroupAddedTo_AddingAccount, AccountAddedTime = TimeGenerated;\nlet AC_Remove = \nSecurityEvent\n| where TimeGenerated \u003e= ago(timeframe)\n// Event IDs related to member removal.\n| where EventID in (4729,4733,4757)\n| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID \n| parse EventData with * '\"MemberName\"\u003e' AccountRemoved \",OU\" * \n| where isnotempty(AccountRemoved)\n| extend GroupRemovedFrom = TargetUserName, RemovingAccount = Account\n| extend AccountRemoved_GroupRemovedFrom_RemovingAccount = strcat(AccountRemoved, \"||\", GroupRemovedFrom, \"||\", RemovingAccount)\n| project AccountRemoved_GroupRemovedFrom_RemovingAccount, AccountRemovedTime = TimeGenerated, Computer, RemovedAccountId = tolower(AccountRemoved), \nRemovedByUser = SubjectUserName, RemovedByUserLogonId = SubjectLogonId,  GroupRemovedFrom = TargetUserName, TargetDomainName; \nAC_Add \n| join kind= inner AC_Remove on $left.AccountAdded_GroupAddedTo_AddingAccount == $right.AccountRemoved_GroupRemovedFrom_RemovingAccount \n| extend DurationinSecondAfter_Removed = datetime_diff ('second', AccountRemovedTime, AccountAddedTime)\n| where DurationinSecondAfter_Removed \u003e 0\n| project-away AccountRemoved_GroupRemovedFrom_RemovingAccount\n| extend timestamp = AccountAddedTime, AccountCustomEntity = RemovedAccountId, HostCustomEntity = Computer\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_46')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "User account added to built in domain local or global group",
                                             "query":  "//Identifies when a user account has been added to a privileged built in domain local group or global group \n//such as the Enterprise Admins, Cert Publishers or DnsAdmins. Be sure to verify this is an expected addition.\n//\n\nlet timeframe = 1d;\n// For AD SID mappings - https://docs.microsoft.com/windows/security/identity-protection/access-control/active-directory-security-groups\nlet WellKnownLocalSID = \"S-1-5-32-5[0-9][0-9]$\";\nlet WellKnownGroupSID = \"S-1-5-21-[0-9]*-[0-9]*-[0-9]*-5[0-9][0-9]$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1102$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1103$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-498$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1000$\";\nSecurityEvent \n| where TimeGenerated \u003e ago(timeframe)\n// When MemberName contains '-' this indicates addition of a group to a group\n| where AccountType == \"User\" and MemberName != \"-\"\n// 4728 - A member was added to a security-enabled global group\n// 4732 - A member was added to a security-enabled local group\n// 4756 - A member was added to a security-enabled universal group\n| where EventID in (4728, 4732, 4756)   \n| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID\n// Exclude Remote Desktop Users group: S-1-5-32-555\n| where TargetSid !in (\"S-1-5-32-555\")\n| extend SimpleMemberName = tostring(split(tostring(split(MemberName, \",\")[0]),\"CN=\")[1])\n| project StartTimeUtc = TimeGenerated, EventID, Activity, Computer, SimpleMemberName, MemberName, MemberSid, TargetUserName, TargetDomainName, TargetSid, UserPrincipalName, SubjectUserName, SubjectUserSid\n| extend timestamp = StartTimeUtc, AccountCustomEntity = SimpleMemberName, HostCustomEntity = Computer\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_47')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "User account created and deleted within 10 mins",
                                             "query":  "//Identifies when a user account is created and then deleted within 10 minutes. This can be an indication of compromise and\n//an adversary attempting to hide in the noise.\n//\n\nlet timeframe = 1d;\nlet spanoftime = 10m;\nlet threshold = 0;\nSecurityEvent \n| where TimeGenerated \u003e ago(2*timeframe) \n// A user account was created\n| where EventID == 4720\n| where AccountType =~ \"User\"\n| project creationTime = TimeGenerated, CreateEventID = EventID, Activity, Computer, TargetUserName, UserPrincipalName, \nAccountUsedToCreate = SubjectUserName, TargetSid, SubjectUserSid \n| join kind= inner (\n  SecurityEvent\n  | where TimeGenerated \u003e ago(timeframe) \n  // A user account was deleted \n  | where EventID == 4726\n| where AccountType == \"User\"\n| project deletionTime = TimeGenerated, DeleteEventID = EventID, Activity, Computer, TargetUserName, UserPrincipalName, \nAccountUsedToDelete = SubjectUserName, TargetSid, SubjectUserSid \n) on Computer, TargetUserName\n| where deletionTime - creationTime \u003c spanoftime\n| extend TimeDelta = deletionTime - creationTime\n| where tolong(TimeDelta) \u003e= threshold\n| project TimeDelta, creationTime, CreateEventID, Computer, TargetUserName, UserPrincipalName, AccountUsedToCreate, \ndeletionTime, DeleteEventID, AccountUsedToDelete\n| extend timestamp = creationTime, AccountCustomEntity = AccountUsedToCreate, HostCustomEntity = Computer\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_48')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "User account enabled and disabled within 10 mins",
                                             "query":  "//Identifies when a user account is enabled and then disabled within 10 minutes. This can be an indication of compromise and\n//an adversary attempting to hide in the noise.\n//\n\nlet timeframe = 1d;\nlet spanoftime = 10m;\nlet threshold = 0;\nSecurityEvent \n| where TimeGenerated \u003e ago(2*timeframe) \n// A user account was enabled\n| where EventID == 4722\n| where AccountType =~ \"User\"\n| project creationTime = TimeGenerated, CreateEventID = EventID, Activity, Computer, TargetUserName, UserPrincipalName, \nAccountUsedToCreate = SubjectUserName, TargetSid, SubjectUserSid \n| join kind= inner (\n  SecurityEvent\n  | where TimeGenerated \u003e ago(timeframe) \n  // A user account was disabled \n  | where EventID == 4725\n| where AccountType == \"User\"\n| project deletionTime = TimeGenerated, DeleteEventID = EventID, Activity, Computer, TargetUserName, UserPrincipalName, \nAccountUsedToDelete = SubjectUserName, TargetSid, SubjectUserSid \n) on Computer, TargetUserName\n| where deletionTime - creationTime \u003c spanoftime\n| extend TimeDelta = deletionTime - creationTime\n| where tolong(TimeDelta) \u003e= threshold\n| project TimeDelta, creationTime, CreateEventID, Computer, TargetUserName, UserPrincipalName, AccountUsedToCreate, \ndeletionTime, DeleteEventID, AccountUsedToDelete\n| extend timestamp = creationTime, AccountCustomEntity = AccountUsedToCreate, HostCustomEntity = Computer\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_49')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "New user created and added to the built-in administrators group",
                                             "query":  "//Identifies when a user account was created and then added to the builtin Administrators group in the same day.\n//This should be monitored closely and all additions reviewed.\n//\n\nlet timeframe = 1d;\nSecurityEvent\n| where TimeGenerated \u003e ago(timeframe) \n| where EventID == 4720\n| where AccountType == \"User\"\n| project CreatedUserTime = TimeGenerated, CreatedUserEventID = EventID, CreatedUserActivity = Activity, Computer = toupper(Computer), \nCreatedUser = tolower(TargetUserName), Domain = toupper(TargetDomainName), CreatedUserSid = TargetSid, AccountUsedToCreateUser = SubjectUserName\n|join (\nSecurityEvent \n| where TimeGenerated \u003e ago(timeframe) \n| where AccountType == \"User\"\n// 4732 - A member was added to a security-enabled local group\n| where EventID == 4732\n//TargetSid is the builin Admins group: S-1-5-32-544\n| where TargetSid == \"S-1-5-32-544\"\n| project GroupAddTime = TimeGenerated, GroupAddEventID = EventID, GroupAddActivity = Activity, Computer = toupper(Computer), GroupName = TargetUserName, \nDomain = toupper(TargetDomainName), GroupSid = TargetSid, UserAdded = SubjectUserName, UserAddedSid = SubjectUserSid, CreatedUser = tolower(SubjectUserName), \nCreatedUserSid = MemberSid\n)\non CreatedUserSid\n//Create User first, then the add to the group.\n| project Computer, CreatedUserTime, CreatedUserEventID, CreatedUserActivity, CreatedUser, CreatedUserSid, Domain, GroupAddTime, GroupAddEventID, \nGroupAddActivity, AccountUsedToCreateUser, GroupName, GroupSid, UserAdded, UserAddedSid \n| extend timestamp = CreatedUserTime, AccountCustomEntity = CreatedUser, HostCustomEntity = Computer\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_50')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Anomalous sign-in location by user account and authenticating application",
                                             "query":  "//This query over Azure Active Directory sign-in considers all user sign-ins for each Azure Active \n//Directory application and picks out the most anomalous change in location profile for a user within an \n//individual application. An alert is generated for recent sign-ins that have location counts that are anomalous\n//over last day but also over the last 7-day and 14-day periods.\n//\n\nlet lookBack_long = 14d;\nlet lookBack_med = 7d;\nlet lookBack = 1d;\nSigninLogs\n| where TimeGenerated \u003e= startofday(ago(lookBack_long))\n| extend locationString = strcat(tostring(LocationDetails[\"countryOrRegion\"]), \"/\", tostring(LocationDetails[\"state\"]), \"/\", tostring(LocationDetails[\"city\"]), \";\") \n| project TimeGenerated, AppDisplayName , UserPrincipalName, locationString \n// Create time series \n| make-series dLocationCount = dcount(locationString) on TimeGenerated in range(startofday(ago(lookBack_long)),now(), 1d) \nby UserPrincipalName, AppDisplayName \n// Compute best fit line for each entry \n| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dLocationCount) \n// Chart the 3 most interesting lines  \n// A 0-value slope corresponds to an account being completely stable over time for a given Azure Active Directory application\n| where Slope \u003e 0.3\n| top 50 by Slope desc\n| join kind = leftsemi (\nSigninLogs\n| where TimeGenerated \u003e= startofday(ago(lookBack_med))\n| extend locationString = strcat(tostring(LocationDetails[\"countryOrRegion\"]), \"/\", tostring(LocationDetails[\"state\"]), \"/\", tostring(LocationDetails[\"city\"]), \";\") \n| project TimeGenerated, AppDisplayName , UserPrincipalName, locationString \n| make-series dLocationCount = dcount(locationString) on TimeGenerated in range(startofday(ago(lookBack_med)) ,now(), 1d) \nby UserPrincipalName, AppDisplayName \n| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dLocationCount) \n| top 50 by Slope desc\n| where Slope \u003e 0.3\n) on UserPrincipalName, AppDisplayName\n| join kind = leftsemi (\nSigninLogs\n| where TimeGenerated \u003e= startofday(ago(lookBack))\n| extend locationString = strcat(tostring(LocationDetails[\"countryOrRegion\"]), \"/\", tostring(LocationDetails[\"state\"]), \"/\", tostring(LocationDetails[\"city\"]), \";\") \n| project TimeGenerated, AppDisplayName , UserPrincipalName, locationString \n| make-series dLocationCount = dcount(locationString) on TimeGenerated in range(startofday(ago(lookBack)) ,now(), 1d) \nby UserPrincipalName, AppDisplayName \n| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dLocationCount) \n| top 50 by Slope desc\n// Higher threshold requirement on last day anomaly\n| where Slope \u003e 5\n) on UserPrincipalName, AppDisplayName\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_51')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Brute Force Attack against GitHub Account",
                                             "query":  "//Attackers who are trying to guess your users passwords or use brute-force methods to get in. If your organization is using SSO with Azure Active Directory, authentication logs to GitHub.com will be generated. Using the following query can help you identify a sudden increase in failed logon attempt of users.\n//\n\nlet LearningPeriod = 7d; \nlet BinTime = 1h; \nlet RunTime = 1h; \nlet StartTime = 1h; \nlet NumberOfStds = 3; \nlet MinThreshold = 10.0; \nlet EndRunTime = StartTime - RunTime; \nlet EndLearningTime = StartTime + LearningPeriod; \nlet GitHubFailedSSOLogins = (SigninLogs \n| where AppDisplayName == \"GitHub.com\" \n| where ResultType == 50056); \nGitHubFailedSSOLogins \n| where TimeGenerated between (ago(EndLearningTime) .. ago(StartTime)) \n| summarize FailedLoginsCountInBinTime = count() by User = Identity, bin(TimeGenerated, BinTime) \n| summarize AvgOfFailedLoginsInLearning = avg(FailedLoginsCountInBinTime), StdOfFailedLoginsInLearning = stdev(FailedLoginsCountInBinTime) by User \n| extend LearningThreshold = max_of(AvgOfFailedLoginsInLearning + StdOfFailedLoginsInLearning * NumberOfStds, MinThreshold) \n| join kind=innerunique ( \n  GitHubFailedSSOLogins \n  | where TimeGenerated between (ago(StartTime) .. ago(EndRunTime)) \n  | summarize FailedLoginsCountInRunTime = count() by User = Identity \n) on User \n| where FailedLoginsCountInRunTime \u003e LearningThreshold\n//| extend AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_52')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "Attempt to bypass conditional access rule in Azure AD",
                                             "query":  "//Identifies an attempt to Bypass conditional access rule(s) in Azure Active Directory.\n//The ConditionalAccessStatus column value details if there was an attempt to bypass Conditional Access\n//or if the Conditional access rule was not satisfied (ConditionalAccessStatus == 1).\n//References: \n//https://docs.microsoft.com/azure/active-directory/conditional-access/overview\n//https://docs.microsoft.com/azure/active-directory/reports-monitoring/concept-sign-ins\n//https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes\n//ConditionalAccessStatus == 0 // Success\n//ConditionalAccessStatus == 1 // Failure\n//ConditionalAccessStatus == 2 // Not Applied\n//ConditionalAccessStatus == 3 // unknown\n//\n\nlet timeRange = ago(1d);\nlet threshold = 1;\nSigninLogs\n| where TimeGenerated \u003e= timeRange\n| where ConditionalAccessStatus == 1 or ConditionalAccessStatus =~ \"failure\"\n| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser \n| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails)\n| extend ConditionalAccessPol0Name = tostring(ConditionalAccessPolicies[0].displayName)\n| extend ConditionalAccessPol1Name = tostring(ConditionalAccessPolicies[1].displayName)\n| extend ConditionalAccessPol2Name = tostring(ConditionalAccessPolicies[2].displayName)\n| extend Status = strcat(StatusCode, \": \", ResultDescription) \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Status = makelist(Status), StatusDetails = makelist(StatusDetails), IPAddresses = makelist(IPAddress), IPAddressCount = dcount(IPAddress) , CorrelationIds = makelist(CorrelationId) by UserPrincipalName, AppDisplayName, tostring(Browser), tostring(OS), Location, ConditionalAccessPol0Name, ConditionalAccessPol1Name, ConditionalAccessPol2Name\n| where IPAddressCount \u003e threshold and StatusDetails !has \"MFA successfully completed\"\n| mvexpand IPAddresses, Status, StatusDetails, CorrelationIds\n| extend Status = strcat(Status, \" \", StatusDetails)\n| summarize IPAddresses = makeset(IPAddresses), Status = makeset(Status), CorrelationIds = makeset(CorrelationIds) by StartTimeUtc, EndTimeUtc, UserPrincipalName, AppDisplayName, tostring(Browser), tostring(OS), Location, ConditionalAccessPol0Name, ConditionalAccessPol1Name, ConditionalAccessPol2Name, IPAddressCount\n| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName, IPCustomEntity = tostring(IPAddresses)\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_53')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Attempts to sign in to disabled accounts",
                                             "query":  "//Identifies failed attempts to sign in to disabled accounts across multiple Azure Applications.\n//Default threshold for Azure Applications attempted to sign in to is 3.\n//References: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes\n//50057 - User account is disabled. The account has been disabled by an administrator.\n//\n\nlet timeframe = 1d;\nlet threshold = 3;\nSigninLogs\n| where TimeGenerated \u003e= ago(timeframe)\n| where ResultType == \"50057\"\n| where ResultDescription =~ \"User account is disabled. The account has been disabled by an administrator.\"\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count(), applicationCount = dcount(AppDisplayName), \napplicationSet = makeset(AppDisplayName) by UserPrincipalName, IPAddress\n| where applicationCount \u003e= threshold\n| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress \n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_54')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Distributed Password cracking attempts in AzureAD",
                                             "query":  "//Identifies distributed password cracking attempts from the Azure Active Directory SigninLogs.\n//The query looks for unusually high number of failed password attempts coming from multiple locations for a user account.\n//References: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes\n//50053   Account is locked because the user tried to sign in too many times with an incorrect user ID or password.\n//50055   Invalid password, entered expired password.\n//50056   Invalid or null password - Password does not exist in store for this user.\n//50126   Invalid username or password, or invalid on-premises username or password.\n//\n\nlet timeRange = 1d;\nlet s_threshold = 30;\nlet l_threshold = 3;\nSigninLogs\n| where TimeGenerated \u003e= ago(timeRange)\n| where OperationName =~ \"Sign-in activity\"\n// Error codes that we want to look at as they are related to the use of incorrect password.\n| where ResultType in (\"50126\", \"50053\" , \"50055\", \"50056\")\n| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser \n| extend LocationString= strcat(tostring(LocationDetails[\"countryOrRegion\"]), \"/\", tostring(LocationDetails[\"state\"]), \"/\", tostring(LocationDetails[\"city\"]))\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated),LocationCount=dcount(LocationString), Location = make_set(LocationString), \nIPAddress = make_set(IPAddress), IPAddressCount = dcount(IPAddress), AppDisplayName = make_set(AppDisplayName), ResultDescription = make_set(ResultDescription), \nBrowser = make_set(Browser), OS = make_set(OS), SigninCount = count() by UserPrincipalName                               \n// Setting a generic threshold - Can be different for different environment\n| where SigninCount \u003e s_threshold and LocationCount \u003e= l_threshold\n| extend tostring(Location), tostring(IPAddress), tostring(AppDisplayName), tostring(ResultDescription), tostring(Browser), tostring(OS)\n| distinct *\n| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_55')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "Failed login attempts to Azure Portal",
                                             "query":  "//Identifies failed login attempts in the Azure Active Directory SigninLogs to the Azure Portal.  Many failed logon \n//attempts or some failed logon attempts from multiple IPs could indicate a potential brute force attack.  \n//The following are excluded due to success and non-failure results:\n//References: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes\n//0 - successful logon\n//50125 - Sign-in was interrupted due to a password reset or password registration entry.\n//50140 - This error occurred due to Keep me signed in interrupt when the user was signing-in.\n//\n\nlet timeRange = 1d;\nlet lookBack = 7d;\nlet threshold_Failed = 5;\nlet threshold_FailedwithSingleIP = 20;\nlet threshold_IPAddressCount = 2;\nlet isGUID = \"[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}\";\nlet azPortalSignins = materialize(SigninLogs\n| where TimeGenerated \u003e= ago(lookBack)\n// Azure Portal only\n| where AppDisplayName =~ \"Azure Portal\")\n;\nlet successPortalSignins = azPortalSignins\n| where TimeGenerated \u003e= ago(timeRange)\n// Azure Portal only and exclude non-failure Result Types\n| where ResultType in (\"0\", \"50125\", \"50140\")\n// Tagging identities not resolved to friendly names\n//| extend Unresolved = iff(Identity matches regex isGUID, true, false)\n| distinct TimeGenerated, UserPrincipalName, Id, ResultType\n;\nlet failPortalSignins = azPortalSignins\n| where TimeGenerated \u003e= ago(timeRange)\n// Azure Portal only and exclude non-failure Result Types\n| where ResultType !in (\"0\", \"50125\", \"50140\")\n// Tagging identities not resolved to friendly names\n| extend Unresolved = iff(Identity matches regex isGUID, true, false)\n;\n// Verify there is no success for the same connection attempt after the fail\nlet failnoSuccess = failPortalSignins | join kind= leftouter (\n   successPortalSignins \n) on UserPrincipalName, Id\n| where TimeGenerated \u003e TimeGenerated1\n| project-away TimeGenerated1, UserPrincipalName1, Id1, ResultType1\n;\n// Lookup up resolved identities from last 7 days\nlet identityLookup = azPortalSignins\n| where TimeGenerated \u003e= ago(lookBack)\n| where not(Identity matches regex isGUID)\n| summarize by UserId, lu_UserDisplayName = UserDisplayName, lu_UserPrincipalName = UserPrincipalName;\n// Join resolved names to unresolved list from portal signins\nlet unresolvedNames = failnoSuccess | where Unresolved == true | join kind= inner (\n   identityLookup \n) on UserId\n| extend UserDisplayName = lu_UserDisplayName, UserPrincipalName = lu_UserPrincipalName\n| project-away lu_UserDisplayName, lu_UserPrincipalName;\n// Join Signins that had resolved names with list of unresolved that now have a resolved name\nlet u_azPortalSignins = failnoSuccess | where Unresolved == false | union unresolvedNames;\nu_azPortalSignins\n| extend Status = strcat(ResultType, \": \", ResultDescription), OS = tostring(DeviceDetail.operatingSystem), Browser = tostring(DeviceDetail.browser)\n| extend FullLocation = strcat(Location,'|', LocationDetails.state, '|', LocationDetails.city)\n| summarize TimeGenerated = makelist(TimeGenerated), Status = makelist(Status), IPAddresses = makelist(IPAddress), IPAddressCount = dcount(IPAddress), FailedLogonCount = count()\nby UserPrincipalName, UserId, UserDisplayName, AppDisplayName, Browser, OS, FullLocation\n| mvexpand TimeGenerated, IPAddresses, Status\n| extend TimeGenerated = todatetime(tostring(TimeGenerated)), IPAddress = tostring(IPAddresses), Status = tostring(Status)\n| project-away IPAddresses\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserPrincipalName, UserId, UserDisplayName, Status, FailedLogonCount, IPAddress, IPAddressCount, AppDisplayName, Browser, OS, FullLocation\n| where (IPAddressCount \u003e= threshold_IPAddressCount and FailedLogonCount \u003e= threshold_Failed) or FailedLogonCount \u003e= threshold_FailedwithSingleIP\n| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_56')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "GitHub Signin Burst from Multiple Locations",
                                             "query":  "//This alerts when there Signin burst from multiple locations in GitHub (AAD SSO).\n//\n\nlet RunTime = 1h;\nSigninLogs\n| where TimeGenerated \u003e ago(RunTime)\n| where AppDisplayName == \"GitHub.com\"\n| where ResultType == 0\n| summarize CountOfLocations = dcount(Location), Locations = make_set(Location) by User = Identity\n| where CountOfLocations \u003e 1\n//| extend AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_57')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Sign-ins from IPs that attempt sign-ins to disabled accounts",
                                             "query":  "//Identifies IPs with failed attempts to sign in to one or more disabled accounts signed in successfully to another account.\n//References: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes\n//50057 - User account is disabled. The account has been disabled by an administrator.\n//\n\nlet lookBack = 1d;\nSigninLogs \n| where TimeGenerated \u003e= ago(lookBack)\n| where ResultType == \"50057\" \n| where ResultDescription == \"User account is disabled. The account has been disabled by an administrator.\" \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), disabledAccountLoginAttempts = count(), \ndisabledAccountsTargeted = dcount(UserPrincipalName), applicationsTargeted = dcount(AppDisplayName), disabledAccountSet = makeset(UserPrincipalName), \napplicationSet = makeset(AppDisplayName) by IPAddress\n| order by disabledAccountLoginAttempts desc\n| join kind= leftouter (\n    // Consider these IPs suspicious - and alert any related  successful sign-ins\n    SigninLogs\n    | where TimeGenerated \u003e= ago(lookBack)\n    | where ResultType == 0\n    | summarize successfulAccountSigninCount = dcount(UserPrincipalName), successfulAccountSigninSet = makeset(UserPrincipalName, 15) by IPAddress\n    // Assume IPs associated with sign-ins from 100+ distinct user accounts are safe\n    | where successfulAccountSigninCount \u003c 100\n) on IPAddress  \n// IPs from which attempts to authenticate as disabled user accounts originated, and had a non-zero success rate for some other account\n| where successfulAccountSigninCount != 0\n| project StartTimeUtc, EndTimeUtc, IPAddress, disabledAccountLoginAttempts, disabledAccountsTargeted, disabledAccountSet, applicationSet, \nsuccessfulAccountSigninCount, successfulAccountSigninSet\n| order by disabledAccountLoginAttempts\n| extend timestamp = StartTimeUtc, IPCustomEntity = IPAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_58')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Brute force attack against Azure Portal",
                                             "query":  "//Identifies evidence of brute force activity against Azure Portal by highlighting multiple authentication failures \n//and by a successful authentication within a given time window. \n//(The query does not enforce any sequence - eg requiring the successful authentication to occur last.)\n//Default Failure count is 5, Default Success count is 1 and default Time Window is 20 minutes.\n//References: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes.\n//\n\nlet failureCountThreshold = 5;\nlet successCountThreshold = 1;\nlet timeRange = 1d;\nlet authenticationWindow = 20m;\nSigninLogs\n| where TimeGenerated \u003e= ago(timeRange)\n| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser\n| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails)\n| extend State = tostring(LocationDetails.state), City = tostring(LocationDetails.city)\n| where AppDisplayName contains \"Azure Portal\"\n// Split out failure versus non-failure types\n| extend FailureOrSuccess = iff(ResultType in (\"0\", \"50125\", \"50140\", \"70043\", \"70044\"), \"Success\", \"Failure\")\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), IPAddress = makeset(IPAddress), makeset(OS), makeset(Browser), makeset(City), \nmakeset(ResultType), FailureCount = countif(FailureOrSuccess==\"Failure\"), SuccessCount = countif(FailureOrSuccess==\"Success\") \nby bin(TimeGenerated, authenticationWindow), UserDisplayName, UserPrincipalName, AppDisplayName\n| where FailureCount \u003e= failureCountThreshold and SuccessCount \u003e= successCountThreshold\n| mvexpand IPAddress\n| extend IPAddress = tostring(IPAddress)\n| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress \n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_59')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Password spray attack against Azure AD application",
                                             "query":  "//Identifies evidence of password spray activity against Azure AD applications by looking for failures from multiple accounts from the same\n//IP address within a time window. If the number of accounts breaches the threshold just once, all failures from the IP address within the time range\n//are bought into the result. Details on whether there were successful authentications by the IP address within the time window are also included.\n//This can be an indicator that an attack was successful.\n//The default failure acccount threshold is 5, Default time window for failures is 20m and default look back window is 3 days\n//Note: Due to the number of possible accounts involved in a password spray it is not possible to map identities to a custom entity.\n//References: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes.\n//\n\nlet timeRange = 3d;\nlet lookBack = 7d;\nlet authenticationWindow = 20m;\nlet authenticationThreshold = 5;\nlet isGUID = \"[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}\";\nlet failureCodes = dynamic([50053, 50126, 50055]); // invalid password, account is locked - too many sign ins, expired password\nlet successCodes = dynamic([0, 50055, 50057, 50155, 50105, 50133, 50005, 50076, 50079, 50173, 50158, 50072, 50074, 53003, 53000, 53001, 50129]);\n// Lookup up resolved identities from last 7 days\nlet identityLookup = SigninLogs\n| where TimeGenerated \u003e= ago(lookBack)\n| where not(Identity matches regex isGUID)\n| where isnotempty(UserId)\n| summarize by UserId, lu_UserDisplayName = UserDisplayName, lu_UserPrincipalName = UserPrincipalName;\n// collect window threshold breaches\nSigninLogs\n| where TimeGenerated \u003e ago(timeRange)\n| where ResultType in(failureCodes)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), make_set(ClientAppUsed), count() by bin(TimeGenerated, authenticationWindow), IPAddress, AppDisplayName, UserPrincipalName\n| summarize FailedPrincipalCount = dcount(UserPrincipalName) by bin(TimeGenerated, authenticationWindow), IPAddress, AppDisplayName\n| where FailedPrincipalCount \u003e= authenticationThreshold\n| summarize WindowThresholdBreaches = count() by IPAddress\n| join kind= inner (\n// where we breached a threshold, join the details back on all failure data\n SigninLogs\n| where TimeGenerated \u003e ago(timeRange)\n| where ResultType in(failureCodes)\n| extend FullLocation = strcat(Location,'|', LocationDetails.state, '|', LocationDetails.city)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), make_set(ClientAppUsed), make_set(FullLocation), FailureCount = count() by IPAddress, AppDisplayName, UserPrincipalName, UserDisplayName, Identity, UserId\n// lookup any unresolved identities\n| extend UnresolvedUserId = iff(Identity matches regex isGUID, UserId, \"\")\n| join kind= leftouter (\n identityLookup \n) on $left.UnresolvedUserId==$right.UserId\n| extend UserDisplayName=iff(isempty(lu_UserDisplayName), UserDisplayName, lu_UserDisplayName)\n| extend UserPrincipalName=iff(isempty(lu_UserPrincipalName), UserPrincipalName, lu_UserPrincipalName)\n| summarize StartTime = min(StartTime), EndTime = max(EndTime), make_set(UserPrincipalName), make_set(UserDisplayName), make_set(set_ClientAppUsed), make_set(set_FullLocation), make_list(FailureCount) by IPAddress, AppDisplayName\n| extend FailedPrincipalCount = arraylength(set_UserPrincipalName)\n) on IPAddress\n| project IPAddress, StartTime, EndTime, TargetedApplication=AppDisplayName, FailedPrincipalCount, UserPrincipalNames=set_UserPrincipalName, UserDisplayNames=set_UserDisplayName, ClientAppsUsed=set_set_ClientAppUsed, Locations=set_set_FullLocation, FailureCountByPrincipal=list_FailureCount, WindowThresholdBreaches\n| join kind= inner (\nSigninLogs // get data on success vs. failure history for each IP\n| where TimeGenerated \u003e ago(timeRange)\n| where ResultType in(successCodes) or ResultType in(failureCodes) // success or failure types\n| summarize GlobalSuccessPrincipalCount = dcountif(UserPrincipalName, (ResultType in(successCodes))), ResultTypeSuccesses = make_set_if(ResultType, (ResultType in(successCodes))), GlobalFailPrincipalCount = dcountif(UserPrincipalName, (ResultType in(failureCodes))), ResultTypeFailures = make_set_if(ResultType, (ResultType in(failureCodes))) by IPAddress\n| where GlobalFailPrincipalCount \u003e GlobalSuccessPrincipalCount // where the number of failed principals is greater than success - eliminates FPs from IPs who authenticate successfully alot and as a side effect have alot of failures\n) on IPAddress\n| project-away IPAddress1\n| extend timestamp=StartTime, IPCustomEntity = IPAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_60')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Successful logon from IP and failure from a different IP",
                                             "query":  "//Identifies when a user account successfully logs onto an Azure App from one IP and within 10 mins failed to logon to the same App via a different IP.\n//This may indicate a malicious attempt at password guessing based on knowledge of the users account.\n//\n\nlet timeFrame = 1d;\nlet logonDiff = 10m;\nSigninLogs \n| where TimeGenerated \u003e= ago(timeFrame) \n| where ResultType == \"0\" \n| where AppDisplayName !in (\"Office 365 Exchange Online\", \"Skype for Business Online\")\n| project SuccessLogonTime = TimeGenerated, UserPrincipalName, SuccessIPAddress = IPAddress, AppDisplayName, SuccessIPBlock = strcat(split(IPAddress, \".\")[0], \".\", split(IPAddress, \".\")[1])\n| join kind= inner (\n    SigninLogs \n    | where TimeGenerated \u003e= ago(timeFrame) \n    | where ResultType !in (\"0\", \"50140\") \n    | where ResultDescription !~ \"Other\"  \n    | where AppDisplayName !in (\"Office 365 Exchange Online\", \"Skype for Business Online\")\n    | project FailedLogonTime = TimeGenerated, UserPrincipalName, FailedIPAddress = IPAddress, AppDisplayName, ResultType, ResultDescription\n) on UserPrincipalName, AppDisplayName \n| where SuccessLogonTime \u003c FailedLogonTime and FailedLogonTime - SuccessLogonTime \u003c= logonDiff and FailedIPAddress !startswith SuccessIPBlock\n| summarize FailedLogonTime = max(FailedLogonTime), SuccessLogonTime = max(SuccessLogonTime) by UserPrincipalName, SuccessIPAddress, AppDisplayName, FailedIPAddress, ResultType, ResultDescription \n| extend timestamp = SuccessLogonTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = SuccessIPAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_61')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Failed logon attempts in authpriv",
                                             "query":  "//Identifies failed logon attempts from unknown users in Syslog authpriv logs. The unknown user means the account that tried to log in \n//isnt provisioned on the machine. A few hits could indicate someone attempting to access a machine they arent authorized to access. \n//If there are many of hits, especially from outside your network, it could indicate a brute force attack. \n//Default threshold for logon attempts is 15.\n//\n\nlet startdate = 1d;\nlet threshold = 15;\n// Below pulls messages from syslog-authpriv logs where there was an authentication failure with an unknown user.\n// IP address of system attempting logon is also extracted from the SyslogMessage field. Some of these messages\n// are aggregated.\nlet authfail = Syslog\n| where TimeGenerated \u003e= ago(startdate)     \n| where Facility =~ \"authpriv\"   // looks at authpriv messages\n| where SyslogMessage contains \"authentication failure\" and SyslogMessage contains \" uid=0\"\n| parse SyslogMessage with * \"rhost=\" ExternalIP\n| project TimeGenerated, Computer, ProcessName, HostIP, ExternalIP, ProcessID;  \n// Below pulls messages from syslog-authpriv logs that show each instance an unknown user tried to logon. \nlet userfail = Syslog \n| where TimeGenerated \u003e= ago(startdate)\n| where Facility =~ \"authpriv\" \n| where SyslogMessage contains \"user unknown\"\n| project TimeGenerated, Computer, HostIP, ProcessID;\n// Join the two log messages above\nlet userauthfail = authfail | join (userfail) on Computer, HostIP, ProcessID\n| project TimeGenerated, Computer, HostIP, ExternalIP, ProcessID ;\n// Extract the EventTime of the first logon attempt\nlet firstfail = userauthfail\n| summarize arg_min(TimeGenerated, *) by Computer, ExternalIP\n| project Computer, ExternalIP, FirstLogonAttempt = TimeGenerated;\n// Extract the EventTime of the last logon attempt\nlet lastfail = userauthfail\n| summarize arg_max(TimeGenerated, *) by Computer, ExternalIP\n| project Computer, ExternalIP, LatestLogonAttempt = TimeGenerated;\n// Join first and last logon attempt data and calculate the time between them (AttemptPeriodLength).\nlet faildates = firstfail | join (lastfail) on Computer, ExternalIP\n| project ExternalIP, Computer, FirstLogonAttempt, LatestLogonAttempt, TimeBetweenLogonAttempts = LatestLogonAttempt - FirstLogonAttempt;\n// Count the number of failed logon attempts by External IP and internal machine\nlet totalfails = userauthfail\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), TotalLogonAttempts = count() by ExternalIP, Computer, HostIP\n| project StartTimeUtc, EndTimeUtc, ExternalIP, Computer, HostIP, TotalLogonAttempts;\n// Combine total attempts with timing data from above\nlet finalfails = totalfails | join (faildates) on Computer, ExternalIP\n| project StartTimeUtc, EndTimeUtc, SourceAddress = ExternalIP, DestinationHost = Computer, DestinationIP = HostIP, TotalLogonAttempts, FirstLogonAttempt, LatestLogonAttempt, TimeBetweenLogonAttempts\n| order by DestinationHost asc nulls last;\nfinalfails \n| where TotalLogonAttempts \u003e= threshold\n| extend timestamp = StartTimeUtc, HostCustomEntity = DestinationHost, IPCustomEntity = DestinationIP\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_62')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "Squid proxy events related to mining pools",
                                             "query":  "//Checks for Squid proxy events in Syslog associated with common mining pools .This query presumes the default Squid log format is being used. \n// http://www.squid-cache.org/Doc/config/access_log/\n//\n\nlet timeframe = 1d;\nlet DomainList = dynamic([\"monerohash.com\", \"do-dear.com\", \"xmrminerpro.com\", \"secumine.net\", \"xmrpool.com\", \"minexmr.org\", \"hashanywhere.com\", \"xmrget.com\", \n\"mininglottery.eu\", \"minergate.com\", \"moriaxmr.com\", \"multipooler.com\", \"moneropools.com\", \"xmrpool.eu\", \"coolmining.club\", \"supportxmr.com\",\n\"minexmr.com\", \"hashvault.pro\", \"xmrpool.net\", \"crypto-pool.fr\", \"xmr.pt\", \"miner.rocks\", \"walpool.com\", \"herominers.com\", \"gntl.co.uk\", \"semipool.com\", \n\"coinfoundry.org\", \"cryptoknight.cc\", \"fairhash.org\", \"baikalmine.com\", \"tubepool.xyz\", \"fairpool.xyz\", \"asiapool.io\", \"coinpoolit.webhop.me\", \"nanopool.org\", \n\"moneropool.com\", \"miner.center\", \"prohash.net\", \"poolto.be\", \"cryptoescrow.eu\", \"monerominers.net\", \"cryptonotepool.org\", \"extrmepool.org\", \"webcoin.me\", \n\"kippo.eu\", \"hashinvest.ws\", \"monero.farm\", \"supportxmr.com\", \"xmrpool.eu\", \"linux-repository-updates.com\", \"1gh.com\", \"dwarfpool.com\", \"hash-to-coins.com\", \n\"hashvault.pro\", \"pool-proxy.com\", \"hashfor.cash\", \"fairpool.cloud\", \"litecoinpool.org\", \"mineshaft.ml\", \"abcxyz.stream\", \"moneropool.ru\", \"cryptonotepool.org.uk\",\n\"extremepool.org\", \"extremehash.com\", \"hashinvest.net\", \"unipool.pro\", \"crypto-pools.org\", \"monero.net\", \"backup-pool.com\", \"mooo.com\", \"freeyy.me\", \"cryptonight.net\",\n\"shscrypto.net\"]);\nSyslog\n| where TimeGenerated \u003e= ago(timeframe)\n| where ProcessName contains \"squid\"\n| extend URL = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :]*)\",3,SyslogMessage), \n        SourceIP = extract(\"([0-9]+ )(([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3}))\",2,SyslogMessage), \n        Status = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))\",1,SyslogMessage), \n        HTTP_Status_Code = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))/([0-9]{3})\",8,SyslogMessage),\n        User = extract(\"(CONNECT |GET )([^ ]* )([^ ]+)\",3,SyslogMessage),\n        RemotePort = extract(\"(CONNECT |GET )([^ ]*)(:)([0-9]*)\",4,SyslogMessage),\n        Domain = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :\\\\/]*)\",3,SyslogMessage),\n        Bytes = toint(extract(\"([A-Z]+\\\\/[0-9]{3} )([0-9]+)\",2,SyslogMessage)),\n        contentType = extract(\"([a-z/]+$)\",1,SyslogMessage)\n| extend TLD = extract(\"\\\\.[a-z]*$\",0,Domain)\n| where HTTP_Status_Code == '200'\n| where Domain contains \".\"\n| where Domain has_any (DomainList)\n| extend timestamp = TimeGenerated, URLCustomEntity = URL, IPCustomEntity = SourceIP, AccountCustomEntity = User\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_63')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "Squid proxy events for ToR proxies",
                                             "query":  "//Check for Squid proxy events associated with common ToR proxies. This query presumes the default squid log format is being used.\n//http://www.squid-cache.org/Doc/config/access_log/\n//\n\nlet timeframe = 1d;\nlet DomainList = dynamic([\"tor2web.org\", \"tor2web.com\", \"torlink.co\", \"onion.to\", \"onion.ink\", \"onion.cab\", \"onion.nu\", \"onion.link\", \n\"onion.it\", \"onion.city\", \"onion.direct\", \"onion.top\", \"onion.casa\", \"onion.plus\", \"onion.rip\", \"onion.dog\", \"tor2web.fi\", \n\"tor2web.blutmagie.de\", \"onion.sh\", \"onion.lu\", \"onion.pet\", \"t2w.pw\", \"tor2web.ae.org\", \"tor2web.io\", \"tor2web.xyz\", \"onion.lt\", \n\"s1.tor-gateways.de\", \"s2.tor-gateways.de\", \"s3.tor-gateways.de\", \"s4.tor-gateways.de\", \"s5.tor-gateways.de\", \"hiddenservice.net\"]);\nSyslog\n| where TimeGenerated \u003e= ago(timeframe)\n| where ProcessName contains \"squid\"\n| extend URL = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :]*)\",3,SyslogMessage), \n        SourceIP = extract(\"([0-9]+ )(([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3}))\",2,SyslogMessage), \n        Status = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))\",1,SyslogMessage), \n        HTTP_Status_Code = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))/([0-9]{3})\",8,SyslogMessage),\n        User = extract(\"(CONNECT |GET )([^ ]* )([^ ]+)\",3,SyslogMessage),\n        RemotePort = extract(\"(CONNECT |GET )([^ ]*)(:)([0-9]*)\",4,SyslogMessage),\n        Domain = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :\\\\/]*)\",3,SyslogMessage),\n        Bytes = toint(extract(\"([A-Z]+\\\\/[0-9]{3} )([0-9]+)\",2,SyslogMessage)),\n        contentType = extract(\"([a-z/]+$)\",1,SyslogMessage)\n| extend TLD = extract(\"\\\\.[a-z]*$\",0,Domain)\n| where HTTP_Status_Code == \"200\"\n| where Domain contains \".\"\n| where Domain has_any (DomainList)\n| extend timestamp = TimeGenerated, URLCustomEntity = URL, IPCustomEntity = SourceIP, AccountCustomEntity = User\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_64')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "New internet-exposed SSH endpoints",
                                             "query":  "//Looks for SSH endpoints with a history of sign-ins only from private IP addresses are accessed from a public IP address.\n//\n\nlet PrivateIPregex = @'^127\\.|^10\\.|^172\\.1[6-9]\\.|^172\\.2[0-9]\\.|^172\\.3[0-1]\\.|^192\\.168\\.'; \nlet avgthreshold = 0;\nlet probabilityLimit = 0.01;\nlet startime = 7d;\nlet ssh_logins = Syslog\n| where TimeGenerated \u003e= ago(startime)\n| where Facility contains \"auth\" and ProcessName =~ \"sshd\"\n| where SyslogMessage has \"Accepted\"\n| extend SourceIP = extract(\"(([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.(([0-9]{1,3})))\",1,SyslogMessage) \n| where isnotempty(SourceIP)\n| extend ipType = iff(SourceIP matches regex PrivateIPregex,\"private\" ,\"public\");\nssh_logins \n| summarize privatecount=countif(ipType==\"private\"), publiccount=countif(ipType==\"public\") by HostName, HostIP, bin(EventTime, 1d)\n| summarize \npublicIPLoginHistory  = make_list(pack('IPCount', publiccount,  'logon_time', EventTime)),\nprivateIPLoginHistory = make_list(pack('IPCount', privatecount, 'logon_time', EventTime)) by HostName, HostIP\n| mv-apply publicIPLoginHistory = publicIPLoginHistory on\n(\n    order by todatetime(publicIPLoginHistory['logon_time']) asc\n    | summarize publicIPLoginCountList=make_list(toint(publicIPLoginHistory['IPCount'])), publicAverage=avg(toint(publicIPLoginHistory['IPCount'])), publicStd=stdev(toint(publicIPLoginHistory['IPCount'])), maxPublicLoginCount=max(toint(publicIPLoginHistory['IPCount']))\n)\n| mv-apply privateIPLoginHistory = privateIPLoginHistory on\n(\n    order by todatetime(privateIPLoginHistory['logon_time']) asc\n    | summarize privateIPLoginCountList=make_list(toint(privateIPLoginHistory['IPCount'])), privateAverage=avg(toint(privateIPLoginHistory['IPCount'])), privateStd=stdev(toint(privateIPLoginHistory['IPCount']))\n)\n// Some logins from private IPs\n| where privateAverage \u003e avgthreshold\n// There is a non-zero number of logins from public IPs\n| where publicAverage \u003e avgthreshold\n// Approximate probability of seeing login from a public IP is \u003c 1%\n| extend probabilityPublic = publicAverage / (privateAverage + publicAverage)\n| where probabilityPublic \u003c probabilityLimit\n// Today has the highest number of logins from public IPs that we've seen in the last week\n| extend publicLoginCountToday = publicIPLoginCountList[-1]\n| where publicLoginCountToday \u003e= maxPublicLoginCount\n| extend HostCustomEntity = HostName\n// Optionally retrieve the original raw data for those logins that we've identified as potentially suspect\n// | join kind=rightsemi (\n//   ssh_logins\n//  | where ipType == \"public\"\n//  ) on HostName\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_65')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "SSH - Potential Brute Force",
                                             "query":  "//Identifies an IP address that had 15 failed attempts to sign in via SSH in a 4 hour block during a 24 hour time period.\n//\n\nlet timeframe = 1d;\nlet threshold = 15;\nSyslog\n| where TimeGenerated \u003e= ago(timeframe)\n| where SyslogMessage contains \"Failed password for invalid user\"\n| where ProcessName =~ \"sshd\" \n| parse kind=relaxed SyslogMessage with * \"invalid user\" user \" from \" ip \" port\" port \" ssh2\"\n| project user, ip, port, SyslogMessage, EventTime\n| summarize EventTimes = make_list(EventTime), PerHourCount = count() by ip, bin(EventTime, 4h), user\n| where PerHourCount \u003e threshold\n| mvexpand EventTimes\n| extend EventTimes = tostring(EventTimes) \n| summarize StartTimeUtc = min(EventTimes), EndTimeUtc = max(EventTimes), UserList = makeset(user), sum(PerHourCount) by IPAddress = ip\n| extend UserList = tostring(UserList) \n| extend timestamp = StartTimeUtc, IPCustomEntity = IPAddress, AccountCustomEntity = UserList\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_66')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Microsoft COVID-19 file hash indicator matches",
                                             "query":  "//Identifies a match in CommonSecurityLog Event data from any FileHash published in the Microsoft COVID-19 Threat Intel Feed - as described at https://www.microsoft.com/security/blog/2020/05/14/open-sourcing-covid-threat-intelligence/\n//\n\nlet dt_lookBack = 1h;\nlet covidIndicators = (externaldata(TimeGenerated:datetime, FileHashValue:string, FileHashType: string, TlpLevel: string, Product: string, ThreatType: string, Description: string )\n[@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Microsoft.Covid19.Indicators.csv\"] with (format=\"csv\"));\nlet fileHashIndicators = covidIndicators\n| where isnotempty(FileHashValue);\n// Handle matches against both lower case and uppercase versions of the hash:\n( fileHashIndicators | extend FileHashValue = tolower(FileHashValue)\n  | union (fileHashIndicators | extend FileHashValue = toupper(FileHashValue)))\n|  join (\n   CommonSecurityLog | where TimeGenerated \u003e= ago(dt_lookBack) \n   | where isnotempty(FileHash)\n   | extend CommonSecurityLog_TimeGenerated = TimeGenerated\n)\non $left.FileHashValue == $right.FileHash\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by FileHashValue\n| project LatestIndicatorTime, FileHashValue, FileHashType, Description, ThreatType,  \nCommonSecurityLog_TimeGenerated, SourceIP, SourcePort, DestinationIP, DestinationPort, SourceUserID, SourceUserName, DeviceName, DeviceAction, \nRequestURL, DestinationUserName, DestinationUserID, ApplicationProtocol, Activity\n| extend timestamp = CommonSecurityLog_TimeGenerated, IPCustomEntity = SourceIP, HostCustomEntity = DeviceName, AccountCustomEntity = SourceUserName\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_67')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Low-severity",
                                             "displayName":  "Anomalous User Agent connection attempt",
                                             "query":  "//Identifies connection attempts (success or fail) from clients with very short or very long User Agent strings and with less than 100 connection attempts.\n//\n\nlet timeFrame = 1d;\nlet short_uaLength = 5;\nlet long_uaLength = 1000;\nlet c_threshold = 100;\nW3CIISLog \n| where TimeGenerated \u003e= ago(timeFrame)\n// Exclude local IPs as these create noise\n| where cIP !startswith \"192.168.\" and cIP != \"::1\"\n| where isnotempty(csUserAgent) and csUserAgent !in~ (\"-\", \"MSRPC\") and (string_size(csUserAgent) \u003c= short_uaLength or string_size(csUserAgent) \u003e= long_uaLength)\n| extend csUserAgent_size = string_size(csUserAgent)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ConnectionCount = count() by Computer, sSiteName, sPort, csUserAgent, csUserAgent_size, csUserName , csMethod, csUriStem, sIP, cIP, scStatus, scSubStatus, scWin32Status\n| where ConnectionCount \u003c c_threshold\n| extend timestamp = StartTimeUtc, AccountCustomEntity = csUserName, HostCustomEntity = Computer, IPCustomEntity = cIP\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_68')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "High count of failed attempts from same client IP",
                                             "query":  "//Identifies when 20 or more failed attempts from a given client IP in 1 minute occur on the IIS server.\n//This could be indicative of an attempted brute force. This could also simply indicate a misconfigured service or device.\n//Recommendations: Validate that these are expected connections from the given Client IP.  If the client IP is not recognized, \n//potentially block these connections at the edge device.\n//If these are expected connections, verify the credentials are properly configured on the system, service, application or device \n//that is associated with the client IP.\n//References:\n//IIS status code mapping: https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0\n//Win32 Status code mapping: https://msdn.microsoft.com/library/cc231199.aspx\n//\n\nlet timeFrame = 1d;\nlet timeBin = 1m;\nlet failedThreshold = 20;\nW3CIISLog\n| where TimeGenerated \u003e= ago(timeFrame)\n| where scStatus in (\"401\",\"403\")\n| where csUserName != \"-\"\n| extend scStatusFull = strcat(scStatus, \".\",scSubStatus) \n// Map common IIS codes\n| extend scStatusFull_Friendly = case(\nscStatusFull == \"401.0\", \"Access denied.\",\nscStatusFull == \"401.1\", \"Logon failed.\",\nscStatusFull == \"401.2\", \"Logon failed due to server configuration.\",\nscStatusFull == \"401.3\", \"Unauthorized due to ACL on resource.\",\nscStatusFull == \"401.4\", \"Authorization failed by filter.\",\nscStatusFull == \"401.5\", \"Authorization failed by ISAPI/CGI application.\",\nscStatusFull == \"403.0\", \"Forbidden.\",\nscStatusFull == \"403.4\", \"SSL required.\",\n\"See - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0\")\n// Mapping to Hex so can be mapped using website in comments above\n| extend scWin32Status_Hex = tohex(tolong(scWin32Status)) \n// Map common win32 codes\n| extend scWin32Status_Friendly = case(\nscWin32Status_Hex =~ \"775\", \"The referenced account is currently locked out and cannot be logged on to.\",\nscWin32Status_Hex =~ \"52e\", \"Logon failure: Unknown user name or bad password.\",\nscWin32Status_Hex =~ \"532\", \"Logon failure: The specified account password has expired.\",\nscWin32Status_Hex =~ \"533\", \"Logon failure: Account currently disabled.\", \nscWin32Status_Hex =~ \"2ee2\", \"The request has timed out.\", \nscWin32Status_Hex =~ \"0\", \"The operation completed successfully.\", \nscWin32Status_Hex =~ \"1\", \"Incorrect function.\", \nscWin32Status_Hex =~ \"2\", \"The system cannot find the file specified.\", \nscWin32Status_Hex =~ \"3\", \"The system cannot find the path specified.\", \nscWin32Status_Hex =~ \"4\", \"The system cannot open the file.\", \nscWin32Status_Hex =~ \"5\", \"Access is denied.\", \nscWin32Status_Hex =~ \"8009030e\", \"SEC_E_NO_CREDENTIALS\", \nscWin32Status_Hex =~ \"8009030C\", \"SEC_E_LOGON_DENIED\", \n\"See - https://msdn.microsoft.com/library/cc231199.aspx\")\n// decode URI when available\n| extend decodedUriQuery = url_decode(csUriQuery)\n// Count of failed attempts from same client IP\n| summarize makeset(decodedUriQuery), makeset(csUserName), makeset(sSiteName), makeset(sPort), makeset(csUserAgent), makeset(csMethod), makeset(csUriQuery), makeset(scStatusFull), makeset(scStatusFull_Friendly), makeset(scWin32Status_Hex), makeset(scWin32Status_Friendly), FailedConnectionsCount = count() by bin(TimeGenerated, timeBin), cIP, Computer, sIP\n| where FailedConnectionsCount \u003e= failedThreshold\n| project TimeGenerated, cIP, set_csUserName, set_decodedUriQuery, Computer, set_sSiteName, sIP, set_sPort, set_csUserAgent, set_csMethod, set_scStatusFull, set_scStatusFull_Friendly, set_scWin32Status_Hex, set_scWin32Status_Friendly, FailedConnectionsCount\n| order by FailedConnectionsCount\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = cIP\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_69')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "High count of failed logons by a user",
                                             "query":  "//Identifies when 100 or more failed attempts by a given user in 10 minutes occur on the IIS Server.\n//This could be indicative of attempted brute force based on known account information.\n//This could also simply indicate a misconfigured service or device. \n//References:\n//IIS status code mapping - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0\n//Win32 Status code mapping - https://msdn.microsoft.com/library/cc231199.aspx\n//\n\nlet timeFrame = 1d;\nlet timeBin = 10m;\nlet failedThreshold = 100;\nW3CIISLog\n| where TimeGenerated \u003e= ago(timeFrame)\n| where scStatus in (\"401\",\"403\")\n| where csUserName != \"-\"\n// Handling Exchange specific items in IIS logs to remove the unique log identifier in the URI\n| extend csUriQuery = iff(csUriQuery startswith \"MailboxId=\", tostring(split(csUriQuery, \"\u0026\")[0]) , csUriQuery )\n| extend csUriQuery = iff(csUriQuery startswith \"X-ARR-CACHE-HIT=\", strcat(tostring(split(csUriQuery, \"\u0026\")[0]),tostring(split(csUriQuery, \"\u0026\")[1])) , csUriQuery )\n| extend scStatusFull = strcat(scStatus, \".\",scSubStatus) \n// Map common IIS codes\n| extend scStatusFull_Friendly = case(\nscStatusFull == \"401.0\", \"Access denied.\",\nscStatusFull == \"401.1\", \"Logon failed.\",\nscStatusFull == \"401.2\", \"Logon failed due to server configuration.\",\nscStatusFull == \"401.3\", \"Unauthorized due to ACL on resource.\",\nscStatusFull == \"401.4\", \"Authorization failed by filter.\",\nscStatusFull == \"401.5\", \"Authorization failed by ISAPI/CGI application.\",\nscStatusFull == \"403.0\", \"Forbidden.\",\nscStatusFull == \"403.4\", \"SSL required.\",\n\"See - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0\")\n// Mapping to Hex so can be mapped using website in comments above\n| extend scWin32Status_Hex = tohex(tolong(scWin32Status)) \n// Map common win32 codes\n| extend scWin32Status_Friendly = case(\nscWin32Status_Hex =~ \"775\", \"The referenced account is currently locked out and cannot be logged on to.\",\nscWin32Status_Hex =~ \"52e\", \"Logon failure: Unknown user name or bad password.\",\nscWin32Status_Hex =~ \"532\", \"Logon failure: The specified account password has expired.\",\nscWin32Status_Hex =~ \"533\", \"Logon failure: Account currently disabled.\", \nscWin32Status_Hex =~ \"2ee2\", \"The request has timed out.\", \nscWin32Status_Hex =~ \"0\", \"The operation completed successfully.\", \nscWin32Status_Hex =~ \"1\", \"Incorrect function.\", \nscWin32Status_Hex =~ \"2\", \"The system cannot find the file specified.\", \nscWin32Status_Hex =~ \"3\", \"The system cannot find the path specified.\", \nscWin32Status_Hex =~ \"4\", \"The system cannot open the file.\", \nscWin32Status_Hex =~ \"5\", \"Access is denied.\", \nscWin32Status_Hex =~ \"8009030e\", \"SEC_E_NO_CREDENTIALS\", \nscWin32Status_Hex =~ \"8009030C\", \"SEC_E_LOGON_DENIED\", \n\"See - https://msdn.microsoft.com/library/cc231199.aspx\")\n// decode URI when available\n| extend decodedUriQuery = url_decode(csUriQuery)\n// Count of failed logons by a user\n| summarize makeset(decodedUriQuery), makeset(cIP), makeset(sSiteName), makeset(sPort), makeset(csUserAgent), makeset(csMethod), makeset(csUriQuery), makeset(scStatusFull), makeset(scStatusFull_Friendly), makeset(scWin32Status_Hex), makeset(scWin32Status_Friendly), FailedConnectionsCount = count() by bin(TimeGenerated, timeBin), csUserName, Computer, sIP\n| where FailedConnectionsCount \u003e= failedThreshold\n| project TimeGenerated, csUserName, set_decodedUriQuery, Computer, set_sSiteName, sIP, set_cIP, set_sPort, set_csUserAgent, set_csMethod, set_scStatusFull, set_scStatusFull_Friendly, set_scWin32Status_Hex, set_scWin32Status_Friendly, FailedConnectionsCount\n| order by FailedConnectionsCount\n| extend timestamp = TimeGenerated, AccountCustomEntity = csUserName, HostCustomEntity = Computer\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_70')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "High count of connections by client IP on many ports",
                                             "query":  "//Identifies when 30 or more ports are used for a given client IP in 10 minutes occurring on the IIS server.\n//This could be indicative of attempted port scanning or exploit attempt at internet facing web applications.  \n//This could also simply indicate a misconfigured service or device.\n//References:\n//IIS status code mapping - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0\n//Win32 Status code mapping - https://msdn.microsoft.com/library/cc231199.aspx\n//\n\nlet timeFrame = 1d;\nlet timeBin = 10m;\nlet portThreshold = 30;\nW3CIISLog\n| where TimeGenerated \u003e= ago(timeFrame)\n| extend scStatusFull = strcat(scStatus, \".\",scSubStatus) \n// Map common IIS codes\n| extend scStatusFull_Friendly = case(\nscStatusFull == \"401.0\", \"Access denied.\",\nscStatusFull == \"401.1\", \"Logon failed.\",\nscStatusFull == \"401.2\", \"Logon failed due to server configuration.\",\nscStatusFull == \"401.3\", \"Unauthorized due to ACL on resource.\",\nscStatusFull == \"401.4\", \"Authorization failed by filter.\",\nscStatusFull == \"401.5\", \"Authorization failed by ISAPI/CGI application.\",\nscStatusFull == \"403.0\", \"Forbidden.\",\nscStatusFull == \"403.4\", \"SSL required.\",\n\"See - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0\")\n// Mapping to Hex so can be mapped using website in comments above\n| extend scWin32Status_Hex = tohex(tolong(scWin32Status)) \n// Map common win32 codes\n| extend scWin32Status_Friendly = case(\nscWin32Status_Hex =~ \"775\", \"The referenced account is currently locked out and cannot be logged on to.\",\nscWin32Status_Hex =~ \"52e\", \"Logon failure: Unknown user name or bad password.\",\nscWin32Status_Hex =~ \"532\", \"Logon failure: The specified account password has expired.\",\nscWin32Status_Hex =~ \"533\", \"Logon failure: Account currently disabled.\", \nscWin32Status_Hex =~ \"2ee2\", \"The request has timed out.\", \nscWin32Status_Hex =~ \"0\", \"The operation completed successfully.\", \nscWin32Status_Hex =~ \"1\", \"Incorrect function.\", \nscWin32Status_Hex =~ \"2\", \"The system cannot find the file specified.\", \nscWin32Status_Hex =~ \"3\", \"The system cannot find the path specified.\", \nscWin32Status_Hex =~ \"4\", \"The system cannot open the file.\", \nscWin32Status_Hex =~ \"5\", \"Access is denied.\", \nscWin32Status_Hex =~ \"8009030e\", \"SEC_E_NO_CREDENTIALS\", \nscWin32Status_Hex =~ \"8009030C\", \"SEC_E_LOGON_DENIED\", \n\"See - https://msdn.microsoft.com/library/cc231199.aspx\")\n// decode URI when available\n| extend decodedUriQuery = url_decode(csUriQuery)\n// Count of attempts by client IP on many ports\n| summarize makeset(sPort), makeset(decodedUriQuery), makeset(csUserName), makeset(sSiteName), makeset(sPort), makeset(csUserAgent), makeset(csMethod), makeset(csUriQuery), makeset(scStatusFull), makeset(scStatusFull_Friendly), makeset(scWin32Status_Hex), makeset(scWin32Status_Friendly), ConnectionsCount = count() by bin(TimeGenerated, timeBin), cIP, Computer, sIP\n| extend portCount = arraylength(set_sPort)\n| where portCount \u003e= portThreshold\n| project TimeGenerated, cIP, set_sPort, set_csUserName, set_decodedUriQuery, Computer, set_sSiteName, sIP, set_csUserAgent, set_csMethod, set_scStatusFull, set_scStatusFull_Friendly, set_scWin32Status_Hex, set_scWin32Status_Friendly, ConnectionsCount, portCount\n| order by portCount\n| extend timestamp = TimeGenerated, IPCustomEntity = cIP\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_71')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Detection-Medium-severity",
                                             "displayName":  "Malicious web application requests linked with MDATP alerts",
                                             "query":  "//Takes MDATP alerts where web scripts are present in the evidence and correlates with requests made to those scripts\n//in the WCSIISLog to surface new alerts for potentially malicious web request activity.\n//The lookback for alerts is set to 1h and the lookback for W3CIISLogs is set to 7d. A sample set of popular web script extensions\n//has been provided in scriptExtensions that should be tailored to your environment.\n//\n\nlet alertTimeWindow = 1h;\nlet logTimeWindow = 7d;\n// Define script extensions that suit your web application environment - a sample are provided below\nlet scriptExtensions = dynamic([\".php\", \".jsp\", \".js\", \".aspx\", \".asmx\", \".asax\", \".cfm\", \".shtml\"]); \nlet alertData = materialize(SecurityAlert \n| where TimeGenerated \u003e ago(alertTimeWindow) \n| where ProviderName == \"MDATP\" \n// Parse and expand the alert JSON \n| extend alertData = parse_json(Entities) \n| mvexpand alertData);\nlet fileData = alertData\n// Extract web script files from MDATP alerts - our malicious web scripts - candidate webshells\n| where alertData.Type =~ \"file\" \n| where alertData.Name has_any(scriptExtensions) \n| extend FileName = tostring(alertData.Name), Directory = tostring(alertData.Directory);\nlet hostData = alertData\n// Extract server details from alerts and map to alert id\n| where alertData.Type =~ \"host\"\n| project HostName = tostring(alertData.HostName), DnsDomain = tostring(alertData.DnsDomain), SystemAlertId\n| distinct HostName, DnsDomain, SystemAlertId;\n// Join the files on their impacted servers\nlet webshellData = fileData\n| join kind=inner (hostData) on SystemAlertId \n| project TimeGenerated, FileName, Directory, HostName, DnsDomain;\nwebshellData\n| join (  \n// Find requests that were made to this file on the impacted server in the W3CIISLog table \nW3CIISLog  \n| where TimeGenerated \u003e ago(logTimeWindow) \n// Restrict to accesses to script extensions \n| where csUriStem has_any(scriptExtensions)\n| extend splitUriStem = split(csUriStem, \"/\")  \n| extend FileName = splitUriStem[-1], HostName = sComputerName\n// Summarize potential attacker activity\n| summarize count(), StartTime=min(TimeGenerated), EndTime=max(TimeGenerated), RequestUserAgents=make_set(csUserAgent), ReqestMethods=make_set(csMethod), RequestStatusCodes=make_set(scStatus), RequestCookies=make_set(csCookie), RequestReferers=make_set(csReferer), RequestQueryStrings=make_set(csUriQuery) by AttackerIP=cIP, SiteName=sSiteName, ShellLocation=csUriStem, tostring(FileName), HostName  \n) on FileName, HostName\n| project StartTime, EndTime, AttackerIP, RequestUserAgents, HostName, SiteName, ShellLocation, ReqestMethods, RequestStatusCodes, RequestCookies, RequestReferers, RequestQueryStrings, RequestCount = count_\n// Expose the attacker ip address as a custom entity\n| extend timestamp=StartTime, IPCustomEntity = AttackerIP, HostCustomEntity = HostName\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'detection_query_72')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-AuditLogs",
                                             "displayName":  "Consent to Application discovery",
                                             "query":  "//This query looks at the last 14 days for any \"Consent to application\" operation\n//occurs by a user or app. This could indicate that permissions to access the listed AzureApp\n//was provided to a malicious actor. Consent to appliction, Add service principal and \n//Add OAuth2PermissionGrant events should be rare. If available, additional context is added \n//from the AuditLogs based on CorrleationId from the same account that performed \"Consent to \n//application\".\n//For further information on AuditLogs please see \n//https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities\n//This may help detect the Oauth2 attack that can be initiated by this publicly available tool\n//https://github.com/fireeye/PwnAuth\n//\n\nlet auditLookback = 14d;\n// Setting threshold to 3 as a default, change as needed.  Any operation that has been initiated by a user or app more than 3 times in the past 30 days will be exluded\nlet threshold = 3;\n// Helper function to extract relevant fields from AuditLog events\nlet auditLogEvents = view (startTimeSpan:timespan)  {\n    AuditLogs | where TimeGenerated \u003e= ago(auditLookback)\n    | extend ModProps = TargetResources.[0].modifiedProperties\n    | extend IpAddress = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)), \n    tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), tostring(parse_json(tostring(InitiatedBy.app)).ipAddress))\n    | extend InitiatedBy = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), \n    tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))\n    | extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))\n    | mvexpand ModProps\n    | extend PropertyName = tostring(ModProps.displayName), newValue = replace(\"\\\"\",\"\",tostring(ModProps.newValue));\n};\n// Get just the InitiatedBy and CorrleationId so we can look at associated audit activity\n// 2 other operations that can be part of malicious activity in this situation are \n// \"Add OAuth2PermissionGrant\" and \"Add service principal\", replace the below if you are interested in those as starting points for OperationName\nlet HistoricalConsent = auditLogEvents(auditLookback)  \n| where OperationName == \"Consent to application\"\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), OperationCount = count() \nby Type, InitiatedBy, IpAddress, TargetResourceName, Category, OperationName, PropertyName, newValue, CorrelationId, Id\n// Remove comment below to only include operations initiated by a user or app that is above the threshold for the last 30 days\n//| where OperationCount \u003e threshold\n;\nlet Correlate = HistoricalConsent \n| summarize by InitiatedBy, CorrelationId;\n// 2 other operations that can be part of malicious activity in this situation are \n// \"Add OAuth2PermissionGrant\" and \"Add service principal\", replace the below if you changed the starting OperationName above\nlet allOtherEvents = auditLogEvents(auditLookback) \n| where OperationName != \"Consent to application\";\n// Gather associated activity based on audit activity for \"Consent to application\" and InitiatedBy and CorrleationId\nlet CorrelatedEvents = Correlate \n| join allOtherEvents on InitiatedBy, CorrelationId\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) \nby Type, InitiatedBy, IpAddress, TargetResourceName, Category, OperationName, PropertyName, newValue, CorrelationId, Id\n;\n// Union the results\nlet Results = union isfuzzy=true HistoricalConsent,CorrelatedEvents;\n// newValues that are simple semi-colon separated, make those dynamic for easy viewing and Aggregate into the PropertyUpdate set based on CorrelationId and Id(DirectoryId)\nResults\n| extend newValue = split(newValue, \";\")\n| extend PropertyUpdate = pack(PropertyName, newValue, \"Id\", Id)\n| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc), PropertyUpdateSet = make_bag(PropertyUpdate) \nby InitiatedBy, IpAddress, TargetResourceName, OperationName, CorrelationId\n| extend timestamp = StartTimeUtc, AccountCustomEntity = InitiatedBy, HostCustomEntity = TargetResourceName, IPCustomEntity = IpAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_1')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-AuditLogs",
                                             "displayName":  "Rare Audit activity initiated by App",
                                             "query":  "//Compares the current day to the last 14 days of audits to identify new audit activities by \n//OperationName, InitiatedByApp, UserPrincipalName, PropertyName, newValue\n//This can be useful when attempting to track down malicious activity related to additions of new users,\n//additions to groups, removal from groups by Azure Apps and automated approvals.\n//\n\nlet current = 1d;\nlet auditLookback = 14d;\nlet AuditTrail = AuditLogs \n| where TimeGenerated \u003e= ago(auditLookback) and TimeGenerated \u003c ago(current) \n| extend InitiatedByApp = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| where isnotempty(InitiatedByApp)\n| extend ModProps = TargetResources.[0].modifiedProperties\n| extend IpAddress = tostring(parse_json(tostring(InitiatedBy.app)).ipAddress)\n| extend UserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))\n| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))\n| mvexpand ModProps\n| extend PropertyName = tostring(ModProps.displayName), newValue = replace(\"\\\"\",\"\",tostring(ModProps.newValue))\n| where isnotempty(newValue) and newValue != \"\\\"\\\"\"\n| summarize  by OperationName, InitiatedByApp, UserPrincipalName, IpAddress, TargetResourceName, PropertyName, newValue;\nlet AccountMods = AuditLogs \n| where TimeGenerated \u003e= ago(current)\n| extend InitiatedByApp = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| where isnotempty(InitiatedByApp)\n| extend ModProps = TargetResources.[0].modifiedProperties\n| extend IpAddress = tostring(parse_json(tostring(InitiatedBy.app)).ipAddress)\n| extend UserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))\n| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))\n| mvexpand ModProps\n| extend PropertyName = tostring(ModProps.displayName), newValue = replace(\"\\\"\",\"\",tostring(ModProps.newValue))\n| where isnotempty(newValue) and newValue != \"\\\"\\\"\"\n| where PropertyName != \"TargetId.UserType\"\n| extend ModifiedProps = pack(\"PropertyName\",PropertyName,\"newValue\",newValue, \"Id\", Id, \"CorrelationId\", CorrelationId) \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Activity = make_bag(ModifiedProps) by Type, InitiatedByApp, UserPrincipalName, IpAddress, TargetResourceName, Category, OperationName, PropertyName, newValue;\nlet RareAudits = AccountMods | join kind= leftanti (\n   AuditTrail \n) on OperationName, InitiatedByApp, UserPrincipalName, PropertyName, newValue;\nRareAudits\n| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc),Activity = make_set(Activity) by InitiatedByApp, OperationName, UserPrincipalName, IpAddress, TargetResourceName\n| order by UserPrincipalName asc, StartTimeUtc asc\n| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName, HostCustomEntity = TargetResourceName, IPCustomEntity = IpAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_2')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-AuditLogs",
                                             "displayName":  "Rare Audit activity initiated by User",
                                             "query":  "//Compares the current day to the last 14 days of audits to identify new audit activities by \n//OperationName, InitiatedByUser, UserPrincipalName, PropertyName, newValue\n//This can be useful when attempting to track down malicious activity related to additions of \n//new users, additions to groups, removal from groups by specific users.\n//\n\nlet current = 1d;\nlet auditLookback = 14d;\nlet AuditTrail = AuditLogs \n| where TimeGenerated \u003e= ago(auditLookback) and TimeGenerated \u003c ago(current) \n| extend InitiatedByUser = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| where isnotempty(InitiatedByUser)\n| extend InitiatedByIPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| extend ModProps = TargetResources.[0].modifiedProperties\n| extend UserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))\n| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))\n| mvexpand ModProps\n| extend PropertyName = tostring(ModProps.displayName), newValue = replace(\"\\\"\",\"\",tostring(ModProps.newValue))\n| summarize count() by OperationName, InitiatedByUser, InitiatedByIPAddress, UserPrincipalName, PropertyName, newValue, TargetResourceName;\nlet AccountMods = AuditLogs \n| where TimeGenerated \u003e= ago(current)\n| extend InitiatedByUser = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| where isnotempty(InitiatedByUser)\n| extend InitiatedByIPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| extend ModProps = TargetResources.[0].modifiedProperties\n| extend UserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))\n| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))\n| mvexpand ModProps\n| extend PropertyName = tostring(ModProps.displayName), newValue = replace(\"\\\"\",\"\",tostring(ModProps.newValue))\n| where PropertyName !in (\"TargetId.UserType\", \"StsRefreshTokensValidFrom\", \"LastDirSyncTime\") and (PropertyName != \"Action Client Name\" and newValue != \"\\\"DirectorySync\\\"\") and (PropertyName != \"Included Updated Properties\" and newValue != \"\\\"LastDirSyncTime\\\"\")\n| extend ModifiedProps = pack(\"PropertyName\",PropertyName,\"newValue\",newValue, \"Id\", Id, \"CorrelationId\", CorrelationId) \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Activity = make_bag(ModifiedProps) by Type, InitiatedByUser, InitiatedByIPAddress, UserPrincipalName, Category, OperationName, PropertyName, newValue, TargetResourceName;\nlet RareAudits = AccountMods | join kind= leftanti (\n   AuditTrail \n) on OperationName, InitiatedByUser, InitiatedByIPAddress, UserPrincipalName, PropertyName, newValue;\nRareAudits \n| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc), make_set(Activity) by InitiatedByUser, InitiatedByIPAddress, OperationName, UserPrincipalName, TargetResourceName\n| order by UserPrincipalName asc, StartTimeUtc asc\n| extend timestamp = StartTimeUtc, AccountCustomEntity = InitiatedByUser, HostCustomEntity = TargetResourceName, IPCustomEntity = InitiatedByIPAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_3')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-AuditLogs",
                                             "displayName":  "User Granted Access and associated audit activity",
                                             "query":  "//Identifies when a new user is granted access and any subsequent audit related activity.  This can help you identify rogue or malicious user behavior.\n//\nlet auditLookback = 14d;\nlet opName = dynamic([\"Add user\", \"Invite external user\"]);\n// Setting threshold to 3 as a default, change as needed.  Any operation that has been initiated by a user or app more than 3 times in the past 14 days will be excluded\nlet threshold = 3;\n// Helper function to extract relevant fields from AuditLog events\nlet auditLogEvents = view (startTimeSpan:timespan)  {\n    AuditLogs | where TimeGenerated \u003e= ago(auditLookback)\n    | extend ModProps = iff(TargetResources.[0].modifiedProperties != \"[]\", TargetResources.[0].modifiedProperties, todynamic(\"NoValues\"))\n    | extend IpAddress = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)), \n    tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), tostring(parse_json(tostring(InitiatedBy.app)).ipAddress))\n    | extend InitiatedByFull = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), \n    tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))\n    | extend InitiatedBy = replace(\"_\",\"@\",tostring(split(InitiatedByFull, \"#\")[0]))\n    | extend TargetUserPrincipalName = tostring(TargetResources[0].userPrincipalName)\n    | extend TargetUserName = replace(\"_\",\"@\",tostring(split(TargetUserPrincipalName, \"#\")[0]))\n    | extend TargetResourceName = case(\n    isempty(tostring(TargetResources.[0].displayName)), TargetUserPrincipalName,\n    isnotempty(tostring(TargetResources.[0].displayName)) and tostring(TargetResources.[0].displayName) startswith \"upn:\", tolower(tostring(TargetResources.[0].displayName)),\n    tolower(tostring(TargetResources.[0].displayName))\n    )\n    | extend TargetUserName = replace(\"_\",\"@\",tostring(split(TargetUserPrincipalName, \"#\")[0]))\n    | extend TargetUserName = iff(isempty(TargetUserName), tostring(split(split(TargetResourceName, \",\")[0], \" \")[1]), TargetUserName ) \n    | mvexpand ModProps\n    | extend PropertyName = tostring(ModProps.displayName), newValue = replace(\"\\\"\",\"\",tostring(ModProps.newValue));\n};\nlet HistoricalAdd = auditLogEvents(auditLookback)\n| where OperationName in~ (opName)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), OperationCount = count() \nby Type, InitiatedBy, IpAddress, TargetUserName, TargetResourceName, Category, OperationName, PropertyName, newValue, CorrelationId, Id\n// Remove comment below to only include operations initiated by a user or app that is above the threshold for the last 14 days\n| where OperationCount \u003e threshold\n;\n// Get list of new added users to correlate with all other events\nlet Correlate = HistoricalAdd \n| summarize by InitiatedBy, TargetUserName, CorrelationId;\n// Get all other events related to list of newly added users\nlet allOtherEvents = auditLogEvents(auditLookback);\n// Join the new added user list to get the list of associated events\nlet CorrelatedEvents = Correlate \n| join allOtherEvents on InitiatedBy, TargetUserName\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) \nby Type, InitiatedBy, IpAddress, TargetUserName, TargetResourceName, Category, OperationName, PropertyName, newValue, CorrelationId, Id\n;\n// Union the results so we can see when the user was added and any associated events that occurred during the same time.\nlet Results = union isfuzzy=true HistoricalAdd,CorrelatedEvents;\n// newValues that are simple semi-colon separated, make those dynamic for easy viewing and Aggregate into the PropertyUpdate set based on CorrelationId and Id(DirectoryId)\nResults\n| extend newValue = split(newValue, \";\")\n| extend PropertyUpdate = pack(PropertyName, newValue, \"Id\", Id)\n| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc), PropertyUpdateSet = make_bag(PropertyUpdate) \nby InitiatedBy, IpAddress, TargetUserName, TargetResourceName, OperationName, CorrelationId\n| extend timestamp = StartTimeUtc, AccountCustomEntity = InitiatedBy, HostCustomEntity = TargetResourceName, IPCustomEntity = IpAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_4')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-AuditLogs",
                                             "displayName":  "User Granted Access and Grants others Access",
                                             "query":  "//Identifies when a new user is granted access and starts granting access to other users.  This can help you identify rogue or malicious user behavior.\n//\nlet auditLookback = 14d;\nlet opName = dynamic([\"Add user\", \"Invite external user\"]);\n// Helper function to extract relevant fields from AuditLog events\nlet auditLogEvents = view (startTimeSpan:timespan, operation:dynamic)  {\n    AuditLogs | where TimeGenerated \u003e= ago(auditLookback)\n    | where OperationName in~ (operation)\n    | extend ModProps = iff(TargetResources.[0].modifiedProperties != \"[]\", TargetResources.[0].modifiedProperties, todynamic(\"NoValues\"))\n    | extend IpAddress = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)), \n    tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), tostring(parse_json(tostring(InitiatedBy.app)).ipAddress))\n    | extend InitiatedByFull = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), \n    tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))\n    | extend InitiatedBy = replace(\"_\",\"@\",tostring(split(InitiatedByFull, \"#\")[0]))\n    | extend TargetUserPrincipalName = tostring(TargetResources[0].userPrincipalName)\n    | extend TargetUserName = replace(\"_\",\"@\",tostring(split(TargetUserPrincipalName, \"#\")[0]))\n    | extend TargetResourceName = case(\n    isempty(tostring(TargetResources.[0].displayName)), TargetUserPrincipalName,\n    isnotempty(tostring(TargetResources.[0].displayName)) and tostring(TargetResources.[0].displayName) startswith \"upn:\", tolower(tostring(TargetResources.[0].displayName)),\n    tolower(tostring(TargetResources.[0].displayName))\n    )\n    | extend TargetUserName = replace(\"_\",\"@\",tostring(split(TargetUserPrincipalName, \"#\")[0]))\n    | extend TargetUserName = iff(isempty(TargetUserName), tostring(split(split(TargetResourceName, \",\")[0], \" \")[1]), TargetUserName ) \n    | mvexpand ModProps\n    | extend PropertyName = tostring(ModProps.displayName), newValue = replace(\"\\\"\",\"\",tostring(ModProps.newValue));\n};\n// Assigning time for First TargetUserName that was added\nlet FirstAdd = auditLogEvents(auditLookback, opName)  \n| project FirstAddTimeUtc = TimeGenerated, Type, FirstInitiatedBy = InitiatedBy, IpAddress, FirstTargetUserName = TargetUserName, FirstTargetResourceName = TargetResourceName, \nFirstOperationName = OperationName, FirstPropertyName = PropertyName, FirstnewValue = newValue, FirstCorrelationId = CorrelationId, FirstId = Id;\n// Assigning time for second TargetUserName that was added, which will allow us to see if a first TargetUserName added in is the Initiated by on the second in the later join\nlet SecondAdd = auditLogEvents(auditLookback, opName)  \n| project SecondAddTimeUtc = TimeGenerated, Type, SecondInitiatedBy = InitiatedBy, IpAddress, SecondTargetUserName = TargetUserName, SecondTargetResourceName = TargetResourceName, \nSecondOperationName = OperationName, SecondPropertyName = PropertyName, SecondnewValue = newValue, SecondCorrelationId = CorrelationId, SecondId = Id;\n//  Joining the FirstAdd with SecondAdd where the FirstAdd TargetUserName value matches the SecondAdd InitiatedBy.  This shows the new user adding a user.\nlet NewUserAddsUser = FirstAdd | join SecondAdd on $left.FirstTargetUserName == $right.SecondInitiatedBy\n// we only want items where the FirstAddTimeUtc is before the SecondAddTimeUtc\n| where FirstAddTimeUtc \u003c SecondAddTimeUtc\n;\n// Build out some of the properties for context\nNewUserAddsUser\n| extend FirstnewValue = split(FirstnewValue, \";\"), SecondnewValue = split(SecondnewValue, \";\")\n| extend PropertyUpdate = pack(FirstPropertyName, FirstnewValue, SecondPropertyName, SecondnewValue, \"FirstCorrelationId\", FirstCorrelationId, \"FirstId\", FirstId, \"SecondCorrelationId\", SecondCorrelationId, \"SecondId\", SecondId)\n| summarize PropertyUpdateSet = make_bag(PropertyUpdate) by FirstAddTimeUtc, FirstInitiatedBy, FirstTargetUserName, SecondAddTimeUtc, SecondInitiatedBy, SecondTargetUserName, \nIpAddress, FirstTargetResourceName, SecondTargetResourceName, FirstOperationName, SecondOperationName\n| extend timestamp = FirstAddTimeUtc, AccountCustomEntity = FirstInitiatedBy, HostCustomEntity = FirstTargetResourceName, IPCustomEntity = IpAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_5')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-AzureActivity",
                                             "displayName":  "Azure Sentinel Analytics Rules Administrative Operations",
                                             "query":  "//Identifies set of Azure Sentinel Analytics Rules administrative operational detection queries for hunting activites\n//\n\nlet timeframe = 1d;\nlet opValues = dynamic([\"Microsoft.SecurityInsights/alertRules/write\", \"Microsoft.SecurityInsights/alertRules/delete\"]);\n// Azure Sentinel Analytics - Rule Create / Update / Delete\nAzureActivity\n| where TimeGenerated \u003e= ago(timeframe)\n| where Category == \"Administrative\"\n| where OperationNameValue in (opValues)\n| where ActivitySubstatusValue in (\"Created\", \"OK\")\n| sort by TimeGenerated desc\n| extend AccountCustomEntity = Caller\n| extend IPCustomEntity = CallerIpAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_6')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-AzureActivity",
                                             "displayName":  "Azure storage key enumeration",
                                             "query":  "//Listing of storage keys is an interesting operation in Azure which might expose additional \n//secrets and PII to callers as well as granting access to VMs. While there are many benign operations of this\n//type, it would be interesting to see if the account performing this activity or the source IP address from \n//which it is being done is anomalous. \n//The query below generates known clusters of ip address per caller, notice that users which only had single\n//operations do not appear in this list as we cannot learn from it their normal activity (only based on a single\n//event). The activities for listing storage account keys is correlated with this learned \n//clusters of expected activities and activity which is not expected is returned. \n//\n\nlet timeframe = 7d;\nAzureActivity\n| where TimeGenerated \u003e= ago(timeframe)\n| where OperationName == \"List Storage Account Keys\"\n| where ActivityStatus == \"Succeeded\" \n| join kind= inner (\n    AzureActivity\n    | where TimeGenerated \u003e= ago(timeframe)\n    | where OperationName == \"List Storage Account Keys\"\n    | where ActivityStatus == \"Succeeded\" \n    | project ExpectedIpAddress=CallerIpAddress, Caller \n    | evaluate autocluster()\n) on Caller \n| where CallerIpAddress != ExpectedIpAddress\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ResourceIds = makeset(ResourceId), ResourceIdCount = dcount(ResourceId) by OperationName, Caller, CallerIpAddress\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_7')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-AzureActivity",
                                             "displayName":  "Azure Network Security Group NSG Administrative Operations",
                                             "query":  "//Identifies set of Azure NSG administrative operational detection queries for hunting activites\n//\n\nlet timeframe = 1d;\nlet opValues = dynamic([\"Microsoft.Network/networkSecurityGroups/write\", \"Microsoft.Network/networkSecurityGroups/delete\"]);\n// Azure NSG Create / Update / Delete\nAzureActivity\n| where TimeGenerated \u003e= ago(timeframe)\n| where Category == \"Administrative\"\n| where OperationNameValue in (opValues)\n| where ActivitySubstatusValue in (\"Created\", \"OK\")\n| sort by TimeGenerated desc\n| extend AccountCustomEntity = Caller\n| extend IPCustomEntity = CallerIpAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_8')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-AzureActivity",
                                             "displayName":  "Azure Sentinel Connectors Administrative Operations",
                                             "query":  "//Identifies set of Azure Sentinel Data Connectors administrative operational detection queries for hunting activites\n//\n\nlet timeframe = 1d;\nlet opValues = dynamic([\"Microsoft.SecurityInsights/dataConnectors/write\", \"Microsoft.SecurityInsights/dataConnectors/delete\"]);\n// Azure Sentinel Data Connectors Update / Delete\nAzureActivity\n| where TimeGenerated \u003e= ago(timeframe)\n| where Category == \"Administrative\"\n| where OperationNameValue in (opValues)\n| where ActivitySubstatusValue in (\"Created\", \"OK\")\n| sort by TimeGenerated desc\n| extend AccountCustomEntity = Caller\n| extend IPCustomEntity = CallerIpAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_9')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-AzureActivity",
                                             "displayName":  "Azure Sentinel Workbooks Administrative Operations",
                                             "query":  "//Identifies set of Azure Sentinel Workbooks administrative operational detection queries for hunting activites\n//\n\nlet timeframe = 1d;\nlet opValues = dynamic([\"microsoft.insights/workbooks/write\", \"microsoft.insights/workbooks/delete\"]);\n// Azure Sentinel Workbook Create / Update / Delete\nAzureActivity\n| where TimeGenerated \u003e= ago(timeframe)\n| where Category == \"Administrative\"\n| where OperationNameValue in (opValues)\n| where ActivitySubstatusValue in (\"Created\", \"OK\")\n| sort by TimeGenerated desc\n| extend AccountCustomEntity = Caller\n| extend IPCustomEntity = CallerIpAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_10')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-AzureActivity",
                                             "displayName":  "Azure Virtual Network Subnets Administrative Operations",
                                             "query":  "//Identifies set of Azure Virtual Network Subnets administrative operational detection queries for hunting activites\n//\n\nlet timeframe = 1d;\nlet opValues = dynamic([\"Microsoft.Network/virtualNetworks/subnets/write\"]);\n// Creating Virtual Network Subnets\nAzureActivity\n| where TimeGenerated \u003e= ago(timeframe)\n| where Category == \"Administrative\"\n| where OperationNameValue in (opValues)\n| where ActivitySubstatusValue == \"Created\"\n| sort by TimeGenerated desc\n| extend AccountCustomEntity = Caller\n| extend IPCustomEntity = CallerIpAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_11')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-AzureActivity",
                                             "displayName":  "Common deployed resources",
                                             "query":  "//This query looks for common deployed resources (resource name and resource groups) and can be used\n//in combination with other signals that show suspicious deployment to evaluate if the resource is one\n//that is commonly being deployed/created or unique. \n//\n\nlet timeframe = 7d;\nAzureActivity\n| where TimeGenerated \u003e= ago(timeframe)\n| where OperationName == \"Create or Update Virtual Machine\" or OperationName == \"Create Deployment\" \n| where ActivityStatus == \"Succeeded\" \n| project Resource, ResourceGroup \n| evaluate basket()\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_12')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-AzureActivity",
                                             "displayName":  "Creation of an anomalous number of resources",
                                             "query":  "//Looks for anomalous number of resources creation or deployment activities in azure activity log.\n//It is best to run this query on a look back period which is at least 7 days.\n//\n\nlet timeframe = 7d;\nAzureActivity\n| where TimeGenerated \u003e= ago(timeframe)\n| where OperationName == \"Create or Update Virtual Machine\" or OperationName == \"Create Deployment\" \n| where ActivityStatus == \"Succeeded\" \n| make-series dcount(ResourceId)  default=0 on EventSubmissionTimestamp in range(ago(7d), now(), 1d) by Caller\n| extend AccountCustomEntity = Caller\n| render timechart \n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_13')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-AzureActivity",
                                             "displayName":  "Granting permissions to account",
                                             "query":  "//Shows the most prevalent users who grant access to others on azure resources and for each account \n//their common source ip address. If an operation is not from this IP address it may be worthy of investigation.\n//\n\nlet timeframe = 7d;\nAzureActivity\n| where TimeGenerated \u003e= ago(timeframe)\n| where OperationName == \"Create role assignment\"\n| where ActivityStatus == \"Succeeded\" \n| project Caller, CallerIpAddress\n| evaluate basket()\n| extend AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_14')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-AzureActivity",
                                             "displayName":  "Port opened for an Azure Resource",
                                             "query":  "//Identifies what ports may have been opened for a given Azure Resource over the last 7 days \n//\n\nlet timeframe = 7d;\nAzureActivity\n| where TimeGenerated \u003e= ago(timeframe)\n| where OperationName has_any (\"Create\", \"Update\") and OperationName has_any (\"Ip\", \"Security Rule\")\n// Choosing Accepted here because it has the Rule Attributes included\n| where ActivityStatus == \"Accepted\" \n// If there is publicIP info, include it\n| extend publicIPAddress_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).ipAddress) \n| extend publicIPAddressVersion_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAddressVersion) \n| extend publicIPAllocationMethod_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAllocationMethod) \n// Include rule attributes for context\n| extend access = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).access) \n| extend description = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).description) \n| extend destinationPortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).destinationPortRange) \n| extend direction = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).direction) \n| extend protocol = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).protocol) \n| extend sourcePortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).sourcePortRange) \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ResourceIds = makeset(ResourceId) by Caller, CallerIpAddress, Resource, ResourceGroup, \nActivityStatus, ActivitySubstatus, SubscriptionId, access, description, destinationPortRange, direction, protocol, sourcePortRange  \n| extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_15')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-AzureActivity",
                                             "displayName":  "Rare Custom Script Extension",
                                             "query":  "//The Custom Script Extension downloads and executes scripts on Azure virtual machines. This extension is useful for post deployment configuration, software installation, or any other configuration or management tasks. \n// Scripts could be downloaded from external links, Azure storage, GitHub, or provided to the Azure portal at extension run time. This could also be used maliciously by an attacker. \n// The query tries to identify rare custom script extensions that have been executed in your envioenment\n//\nlet current = 1d;\nlet Lookback = 14d;\nlet CustomScriptExecution = AzureActivity \n| where TimeGenerated \u003e= ago(Lookback) \n| where OperationName =~ \"Create or Update Virtual Machine Extension\"\n| extend Settings = tostring(parse_json(tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).settings)))\n| parse Settings with * 'fileUris\":[' FileURI \"]\" *\n| parse Settings with * 'commandToExecute\":' commandToExecute '}' *\n| extend message_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).statusMessage)).error)).message);\nlet LookbackCustomScriptExecution = CustomScriptExecution\n| where TimeGenerated \u003e= ago(Lookback) and TimeGenerated \u003c ago(current)\n| where isnotempty(FileURI) and isnotempty(commandToExecute)\n| summarize max(TimeGenerated), OperationCount = count() by Caller, Resource, CallerIpAddress, FileURI, commandToExecute;\nlet CurrentCustomScriptExecution = CustomScriptExecution\n| where TimeGenerated \u003e= ago(current)\n| where isnotempty(FileURI) and isnotempty(commandToExecute)\n| project TimeGenerated, ActivityStatus, OperationId, CorrelationId, ResourceId, CallerIpAddress, Caller, OperationName, Resource, ResourceGroup, FileURI, commandToExecute, FailureMessage = message_, HTTPRequest, Settings;\nlet RareCustomScriptExecution =  CurrentCustomScriptExecution\n| join kind= leftanti (LookbackCustomScriptExecution) on Caller, CallerIpAddress, FileURI, commandToExecute;\nlet IPCheck = RareCustomScriptExecution \n| summarize arg_max(TimeGenerated, OperationName), OperationIds = makeset(OperationId), CallerIpAddresses = makeset(CallerIpAddress) by ActivityStatus, CorrelationId, ResourceId, Caller, Resource, ResourceGroup, FileURI, commandToExecute, FailureMessage\n| extend IPArray = arraylength(CallerIpAddresses);\n//Get IPs for later summarization so all associated CorrelationIds and Caller actions have an IP.  Success and Fails do not always have IP\nlet multiIP = IPCheck | where IPArray \u003e 1\n| mvexpand CallerIpAddresses | extend CallerIpAddress = tostring(CallerIpAddresses)\n| where isnotempty(CallerIpAddresses);\nlet singleIP = IPCheck | where IPArray \u003c= 1\n| mvexpand CallerIpAddresses | extend CallerIpAddress = tostring(CallerIpAddresses);\nlet FullDetails = singleIP | union multiIP;\n//Get IP address associated with successes and fails with no IP listed\nlet IPList = FullDetails | where isnotempty(CallerIpAddress) | summarize by CorrelationId, Caller, CallerIpAddress;\nlet EmptyIP = FullDetails | where isempty(CallerIpAddress) | project-away CallerIpAddress;\nlet IpJoin = EmptyIP | join kind= leftouter (IPList) on CorrelationId, Caller | project-away CorrelationId1, Caller1;\nlet nonEmptyIP = FullDetails | where isnotempty(CallerIpAddress);\nnonEmptyIP | union IpJoin\n// summarize all activities with a given CorrelationId and Caller together so we can provide a singular result\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ActivityStatusSet = makeset(ActivityStatus), OperationIds = makeset(OperationIds), FailureMessages = makeset(FailureMessage) by CorrelationId, ResourceId, CallerIpAddress, Caller, Resource, ResourceGroup, FileURI, commandToExecute\n| extend timestamp = StartTime, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_16')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-AzureDiagnostics",
                                             "displayName":  "Check critical ports opened to the entire internet",
                                             "query":  "//Discover all critical ports from a list having rules like Any for sourceIp, which means that they are opened to everyone. Critial ports should not be opened to everyone, and should be filtered.\n//\n\n//Check critical ports opened to the entire internet\nAzureDiagnostics\n| where Category == \"NetworkSecurityGroupEvent\" \n| where direction_s == \"In\" \n| where conditions_destinationPortRange_s in (\n\"22\",\"22-22\"          //SSH\n,\"3389\",\"3389-3389\"   //RDP\n,\"137\",\"137-137\"      //NetBIOS\n,\"138\",\"138-138\"      //NetBIOS\n,\"139\",\"139-139\"      //SMB\n,\"53\",\"53-53\"         //DNS\n,\"3020\",\"3020-3020\"   //CIFS\n,\"3306\",\"3306-3306\"   //MySQL\n,\"1521\",\"1521-1521\"   //Oracle Database\n,\"2483\",\"2483-2483\"   //Oracle Database\n,\"5432\",\"5432-5432\"   //PostgreSQL\n,\"389\",\"389-389\"      //LDAP\n,\"27017\",\"27017-27017\"//MongoDB\n,\"20\",\"20-20\"         //FTP\n,\"21\",\"21-21\"         //FTP\n,\"445\",\"445-445\"      //Active Directory\n,\"161\",\"161-161\"      //SNMP\n,\"25\",\"25-25\"         //SMTP\n)\n or (conditions_destinationPortRange_s == \"0-65535\" and conditions_sourcePortRange_s == \"0-65535\")\n| where priority_d \u003c 65000    //Not to check the Azure defaults\n| where conditions_sourceIP_s == \"0.0.0.0/0,0.0.0.0/0\" or conditions_sourceIP_s == \"0.0.0.0/0\" //With rules Any/Any\n| where type_s !~ \"block\"\n| order by TimeGenerated desc\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by OperationName, systemId_g, vnetResourceGuid_g, subnetPrefix_s, macAddress_s, primaryIPv4Address_s, ruleName_s,\n direction_s, priority_d, type_s, conditions_destinationIP_s, conditions_destinationPortRange_s, conditions_sourceIP_s, conditions_sourcePortRange_s, ResourceId\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_17')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-MultipleDataSources",
                                             "displayName":  "Failed service logon attempt by user account with available AuditData",
                                             "query":  "//User account failed to logon in current period (default last 1 day). Excludes Windows Sign in attempts due to noise and limits to only more than 10 failed logons or 3 different IPs used.\n//Additionally, Azure Audit Log data from the last several days(default 7 days) related to the given UserPrincipalName will be joined if available.\n//This can help to understand any events for this same user related to User or Group Management.\n//Results may indicate a potential malicious use of an account that is rarely used. It is possible this is an account that is new or newly enabled.\n//The associated Azure Audit data should help determine any recent changes to this account and may help you understand why the logons are failing.\n//Receiving no results indicates that there were no less than 10 failed logons or that the Auditlogs related to this UserPrincipalName in the default 7 days.\n//\n\nlet current = 1d;\nlet failLimit = 10;\nlet ipLimit = 3;\nlet auditLookback = 7d;\nlet FailedSignins = SigninLogs \n| where TimeGenerated \u003e= ago(current)\n| where ResultType != \"0\" and AppDisplayName != \"Windows Sign In\"\n| extend UserPrincipalName = tolower(UserPrincipalName)\n| extend CityState = strcat(tostring(LocationDetails.city),\"|\", tostring(LocationDetails.state))\n| extend Result = strcat(ResultType,\"-\",ResultDescription) \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), DistinctIPAddressCount = dcount(IPAddress), IPAddresses = makeset(IPAddress), \nCityStates = makeset(CityState), DistinctResultCount = dcount(Result), Results = makeset(Result), AppDisplayNames = makeset(AppDisplayName), \nFailedLogonCount = count() by Type, OperationName, Category, UserPrincipalName = tolower(UserPrincipalName), ClientAppUsed, Location, CorrelationId\n| project Type, StartTimeUtc, EndTimeUtc, OperationName, Category, UserPrincipalName, AppDisplayNames, DistinctIPAddressCount, IPAddresses, DistinctResultCount, \nResults, FailedLogonCount, Location, CityStates \n| where FailedLogonCount \u003e= failLimit or DistinctIPAddressCount \u003e= ipLimit\n| extend Activity = pack(\"IPAddresses\", IPAddresses, \"AppDisplayNames\", AppDisplayNames, \"Results\", Results, \"Location\", Location, \"CityStates\", CityStates)\n| project Type, StartTimeUtc, EndTimeUtc, OperationName, Category, UserPrincipalName, FailedLogonCount, DistinctIPAddressCount, DistinctResultCount, Activity\n| extend AccountCustomEntity = UserPrincipalName;\nlet AccountMods = AuditLogs | where TimeGenerated \u003e= ago(current+auditLookback)\n| where Category == \"UserManagement\" or Category == \"GroupManagement\"\n| extend ModProps = TargetResources.[0].modifiedProperties\n| extend InitiatedBy = case(\nisnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName),\nisnotempty(tostring(parse_json(tostring(InitiatedBy.app)).displayName)), tostring(parse_json(tostring(InitiatedBy.app)).displayName),\n\"\")\n| extend UserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))\n| mvexpand ModProps\n| extend PropertyName = tostring(ModProps.displayName), oldValue = tostring(ModProps.oldValue), newValue = tostring(ModProps.newValue)\n| extend ModifiedProps = pack(\"PropertyName\",PropertyName,\"oldValue\",oldValue,\"newValue\",newValue) \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Activity = make_bag(ModifiedProps) by Type, InitiatedBy, UserPrincipalName, Category, OperationName, CorrelationId, Id\n| extend AccountCustomEntity = UserPrincipalName;\n// Gather only Audit data for UserPrincipalNames that we have Audit data for\nlet AccountNameOnly = FailedSignins | project UserPrincipalName;\nlet AuditMods = AccountNameOnly\n| join kind= innerunique (\nAccountMods\n) on UserPrincipalName;\nlet AvailableAudits = AuditMods | project UserPrincipalName;\nlet SigninsWithAudit = AvailableAudits\n| join kind= innerunique (\nFailedSignins\n) on UserPrincipalName;\n// Union the Current Signin failures so we do not lose them with the Auditing data we do have\nlet Activity = (union isfuzzy=true\nSigninsWithAudit, AuditMods)\n| order by StartTimeUtc, UserPrincipalName;\nActivity\n| project StartTimeUtc, EndTimeUtc, DataType = Type, Category, OperationName, UserPrincipalName, InitiatedBy, Activity, FailedLogonCount, DistinctIPAddressCount, DistinctResultCount, CorrelationId, Id\n| order by UserPrincipalName, StartTimeUtc\n| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_18')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-MultipleDataSources",
                                             "displayName":  "Failed Login Attempt by Expired account",
                                             "query":  "//This query looks at Account Logon events found through Windows Event Ids as well as SigninLogs to discover \n//login attempts by accounts that have expired.\n//\n\nlet timeframe = 1d;\n(union isfuzzy=true\n(SecurityEvent\n| where TimeGenerated \u003e= ago(timeframe) \n| where EventID == 4625\n//4625: An account failed to log on\n| where AccountType == 'User' \n| where SubStatus == '0xc0000193' \n| extend Reason = \ncase\n( SubStatus == '0xc0000193', 'Windows EventID (4625) - Account has expired', \"Unknown\")\n| project Computer, Account,  Reason , TimeGenerated\n),\n(\nSecurityEvent\n| where TimeGenerated \u003e= ago(timeframe) \n| where EventID == 4769\n//4769: A Kerberos service ticket was requested ( Kerberos Auth)\n| parse EventData with * 'Status\"\u003e' Status \"\u003c\" *\n| parse EventData with * 'TargetUserName\"\u003e' TargetUserName \"\u003c\" *\n| where Status == '0x12'\n| where TargetUserName !has \"$\" and isnotempty(TargetUserName)\n| extend Reason = \ncase(\nStatus == '0x12', 'Windows EventID (4769) - Account disabled, expired, locked out',\n'Unknown'), Account = TargetUserName \n| project Computer, Account, Reason , TimeGenerated\n),\n(\nSecurityEvent\n| where TimeGenerated \u003e= ago(timeframe) \n| where EventID == 4776 \n// 4776: The domain controller attempted to validate the credentials for an account ( NTLM Auth)\n| where Status == \"0xc0000193\"\n| extend Reason = \ncase(\nErrorCode == '0xc0000193', 'Windows EventID (4776) - Account has expired',\n'Unknown'), Account = TargetAccount \n| parse EventData with * 'Workstation\"\u003e' Workstation \"\u003c\" *\n| extend Workstation = trim_start(@\"[\\\\]*\", Workstation)\n| extend Computer = iff(isnotempty(Workstation), Workstation, Computer ) \n| project Computer, Account, Reason , TimeGenerated\n) ,\n(\nSigninLogs\n| where TimeGenerated \u003e= ago(timeframe) \n| where ResultType == \"50057\" \n| extend Reason = \ncase(\nResultType == '50057', 'SigninLogs( Result Code- 50057) - User account is disabled. The account has been disabled by an administrator.',\n'Unknown'), Account = UserPrincipalName \n| project Computer, Account, Reason , TimeGenerated\n) )\n| summarize StartTimeUtc = min(TimeGenerated), EndTImeUtc = max(TimeGenerated), EventCount = count() by Computer, Account, Reason\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer\n| order by EventCount desc \n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_19')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-MultipleDataSources",
                                             "displayName":  "Retrospective hunt for STRONTIUM IP IOCs",
                                             "query":  "//Matches domain name IOCs related to Strontium group activity with CommonSecurityLog and SecurityAlert dataTypes.\n//The query is scoped in the time window that these IOCs were active.\n//References: https://blogs.microsoft.com/on-the-issues/2019/07/17/new-cyberthreats-require-new-ways-to-protect-democracy.\n//\n\nlet STRONTIUM_IPS = dynamic([\"82.118.242.171\" , \"167.114.153.55\" , \"94.237.37.28\", \"31.220.61.251\" , \"128.199.199.187\" ]);\n(union isfuzzy=true\n(CommonSecurityLog\n| where TimeGenerated between (startofday(datetime(2019-02-01)) .. endofday(datetime(2019-08-05)))\n| where SourceIP in (STRONTIUM_IPS) or DestinationIP in (STRONTIUM_IPS)\n| extend IPCustomEntity = SourceIP\n),\n(SecurityAlert\n| where TimeGenerated between (startofday(datetime(2019-02-01)) .. endofday(datetime(2019-08-05)))\n| extend RemoteAddress = iff(ExtendedProperties has \"RemoteAddress\", tostring(parse_json(ExtendedProperties)[\"RemoteAddress\"]), \"None\")\n| where RemoteAddress != \"None\"\n| where RemoteAddress in (STRONTIUM_IPS)\n| extend IPCustomEntity = RemoteAddress\n) \n)\n| extend timestamp = TimeGenerated\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_20')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-MultipleDataSources",
                                             "displayName":  "User Granted Access and created resources",
                                             "query":  "//Identifies when a new user is granted access and starts creating resources in Azure.  This can help you identify rogue or malicious user behavior.\n//\n\nlet auditLookback = 14d;\nlet opName = dynamic([\"Add user\", \"Invite external user\"]);\n// Helper function to extract relevant fields from AuditLog events\nlet auditLogEvents = view (startTimeSpan:timespan, operation:dynamic)  {\n    AuditLogs | where TimeGenerated \u003e= ago(auditLookback)\n    | where OperationName in~ (operation)\n    | extend ModProps = iff(TargetResources.[0].modifiedProperties != \"[]\", TargetResources.[0].modifiedProperties, todynamic(\"NoValues\"))\n    | extend IpAddress = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)), \n    tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), tostring(parse_json(tostring(InitiatedBy.app)).ipAddress))\n    | extend InitiatedByFull = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), \n    tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))\n    | extend InitiatedBy = replace(\"_\",\"@\",tostring(split(InitiatedByFull, \"#\")[0]))\n    | extend TargetUserPrincipalName = tostring(TargetResources[0].userPrincipalName)\n    | extend TargetUserName = replace(\"_\",\"@\",tostring(split(TargetUserPrincipalName, \"#\")[0]))\n    | extend TargetResourceName = case(\n    isempty(tostring(TargetResources.[0].displayName)), TargetUserPrincipalName,\n    isnotempty(tostring(TargetResources.[0].displayName)) and tostring(TargetResources.[0].displayName) startswith \"upn:\", tolower(tostring(TargetResources.[0].displayName)),\n    tolower(tostring(TargetResources.[0].displayName))\n    )\n    | extend TargetUserName = replace(\"_\",\"@\",tostring(split(TargetUserPrincipalName, \"#\")[0]))\n    | extend TargetUserName = iff(isempty(TargetUserName), tostring(split(split(TargetResourceName, \",\")[0], \" \")[1]), TargetUserName ) \n    | mvexpand ModProps\n    | extend PropertyName = tostring(ModProps.displayName), newValue = replace(\"\\\"\",\"\",tostring(ModProps.newValue));\n};\nlet UserAdd = auditLogEvents(auditLookback, opName) \n| project Action = \"User Added\", TimeGenerated, Type, InitiatedBy_Caller = InitiatedBy, IpAddress, TargetUserName = tolower(TargetUserName), OperationName, PropertyName_ResourceId = PropertyName, Value = newValue;\n// Get the simple list of creatd users so we can use later to get just the associated resource creation events\nlet SimpleUserList = UserAdd | project TimeGenerated, TargetUserName;\nlet ResourceCreation = AzureActivity\n| where TimeGenerated \u003e= ago(auditLookback)\n// We look for any Operation that created and then succeeded where ActivityStatus has a value so that we can provide context\n| where OperationName has \"Create\"\n| where ActivityStatus has \"Succeeded\"\n| project Action = \"Resource Created\", ResourceCreationTimeGenerated = TimeGenerated, Type, InitiatedBy_Caller = tolower(Caller), IpAddress = CallerIpAddress, OperationName, Value = OperationNameValue, PropertyName_ResourceId = ResourceId;\n// Get just the Resources added by the new user\nlet ResourceMatch = SimpleUserList | join kind= innerunique (\n   ResourceCreation\n) on $left.TargetUserName == $right.InitiatedBy_Caller\n// where the resource creation is after (greater than) the user addition\n| where TimeGenerated \u003c ResourceCreationTimeGenerated\n| project-away TimeGenerated \n| project-rename TimeGenerated = ResourceCreationTimeGenerated\n;\nlet SimpleResourceMatch = ResourceMatch | project InitiatedBy_Caller;\n// Get only resource add, remove, change by the new user\nlet UserAddWithResource = SimpleResourceMatch | join kind= rightsemi (\n   UserAdd \n) on $left.InitiatedBy_Caller == $right.TargetUserName;\n// union the user addition events and resource addition events and provide common column names, additionally pack the value, property and resource info to reduce result set.\nUserAddWithResource \n| union isfuzzy=true ResourceMatch\n| extend PropertySet = pack(\"Value\", Value, \"PropertyName_ResourceId\", PropertyName_ResourceId) \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), makeset(PropertySet)  by Action, Type, TargetUserName, InitiatedBy_Caller, IpAddress, OperationName\n| order by StartTimeUtc asc \n| extend timestamp = StartTimeUtc, AccountCustomEntity = TargetUserName, IPCustomEntity = IpAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_21')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityAlert",
                                             "displayName":  "Alerts related to IP",
                                             "query":  "//Any Alerts that fired related to a given IpAddress during the range of +6h and -3d\n//\n\nlet GetAllAlertsWithIp = (suspiciousEventTime:datetime, v_ipAddress:string){\n//-3d and +6h as some alerts fire after accumulation of events\nlet v_StartTime = suspiciousEventTime-3d;\nlet v_EndTime = suspiciousEventTime+6h;\nSecurityAlert\n| where TimeGenerated between (v_StartTime .. v_EndTime)\n// expand JSON properties\n| where ExtendedProperties contains v_ipAddress or Entities contains v_ipAddress\n| extend Extprop = parsejson(ExtendedProperties)\n| extend Computer = iff(isnotempty(toupper(tostring(Extprop[\"Compromised Host\"]))), toupper(tostring(Extprop[\"Compromised Host\"])), tostring(parse_json(Entities)[0].HostName))\n| extend Account = iff(isnotempty(tolower(tostring(Extprop[\"User Name\"]))), tolower(tostring(Extprop[\"User Name\"])), tolower(tostring(Extprop[\"user name\"])))\n| extend IpAddress = tostring(parse_json(ExtendedProperties).[\"Client Address\"]) \n| project StartTimeUtc = StartTime, EndTimeUtc = EndTime, AlertName, Computer, Account, IpAddress, ExtendedProperties, Entities\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress\n};\n// change datetime value and \u003cipaddress\u003e value below\nGetAllAlertsWithIp(datetime('2019-02-05T10:02:51.000'), (\"\u003cipaddress\u003e\"))\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_22')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityAlert",
                                             "displayName":  "Alerts related to account",
                                             "query":  "//Any Alerts that fired related to a given account during the range of +6h and -3d\n//\n\nlet GetAllAlertsForUser = (suspiciousEventTime:datetime, v_User:string){\n//-3d and +6h as some alerts fire after accumulation of events\nlet v_StartTime = suspiciousEventTime-3d;\nlet v_EndTime = suspiciousEventTime+6h;\nSecurityAlert\n| where TimeGenerated between (v_StartTime .. v_EndTime)\n| where Account contains v_User\n// expand JSON properties\n| extend Extprop = parsejson(ExtendedProperties)\n| extend Computer = iff(isnotempty(toupper(tostring(Extprop[\"Compromised Host\"]))), toupper(tostring(Extprop[\"Compromised Host\"])), tostring(parse_json(Entities)[0].HostName))\n| extend Account = iff(isnotempty(tolower(tostring(Extprop[\"User Name\"]))), tolower(tostring(Extprop[\"User Name\"])), tolower(tostring(Extprop[\"user name\"])))\n| extend IpAddress = tostring(parse_json(ExtendedProperties).[\"Client Address\"]) \n| project TimeGenerated, AlertName, Computer, Account, IpAddress, ExtendedProperties \n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress\n};\n// change datetime value and username value below\nGetAllAlertsForUser(datetime('2019-01-20T10:02:51.000'), toupper(\"\u003cusername\u003e\"))\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_23')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityAlert",
                                             "displayName":  "Alerts On Host",
                                             "query":  "//Any Alerts that fired on a given host during the range of +6h and -3d\n//\n\nlet GetAllAlertsOnHost = (suspiciousEventTime:datetime, v_Host:string){\n//-3d and +6h as some alerts fire after accumulation of events\nlet v_StartTime = suspiciousEventTime-3d;\nlet v_EndTime = suspiciousEventTime+6h;\nSecurityAlert\n| where TimeGenerated between (v_StartTime .. v_EndTime)\n| where Computer contains v_Host\n// expand JSON properties\n| extend Extprop = parsejson(ExtendedProperties)\n| extend Computer = iff(isnotempty(toupper(tostring(Extprop[\"Compromised Host\"]))), toupper(tostring(Extprop[\"Compromised Host\"])), tostring(parse_json(Entities)[0].HostName))\n| extend Account = iff(isnotempty(tolower(tostring(Extprop[\"User Name\"]))), tolower(tostring(Extprop[\"User Name\"])), tolower(tostring(Extprop[\"user name\"])))\n| extend IpAddress = tostring(parse_json(ExtendedProperties).[\"Client Address\"]) \n| project TimeGenerated, AlertName, Computer, Account, IpAddress, ExtendedProperties\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress\n};\n// change datetime value and hostname value below\nGetAllAlertsOnHost(datetime('2019-01-20T10:02:51.000'), toupper(\"\u003chostname\u003e\"))\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_24')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityAlert",
                                             "displayName":  "Alerts related to File",
                                             "query":  "//Any Alerts that fired related to a given File during the range of +6h and -3d\n//\n\nlet GetAllAlertsWithFile = (suspiciousEventTime:datetime, v_File:string){\nlet v_StartTime = suspiciousEventTime-1d;\nlet v_EndTime = suspiciousEventTime+1d;\nSecurityAlert\n| where TimeGenerated between (v_StartTime .. v_EndTime)\n| where ExtendedProperties has v_File\n| extend Computer = iff(isnotempty(toupper(tostring(Extprop[\"Compromised Host\"]))), toupper(tostring(Extprop[\"Compromised Host\"])), tostring(parse_json(Entities)[0].HostName))\n| extend Account = iff(isnotempty(tolower(tostring(Extprop[\"User Name\"]))), tolower(tostring(Extprop[\"User Name\"])), tolower(tostring(Extprop[\"user name\"])))\n| extend IpAddress = tostring(parse_json(ExtendedProperties).[\"Client Address\"]) \n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress\n};\n// change datetime value and \u003cfilename\u003e value below\nGetAllAlertsWithFile(datetime('2019-01-18T10:36:07Z'), \"\u003cfilename\u003e\")\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_25')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityAlert",
                                             "displayName":  "Alerts With This Process",
                                             "query":  "//Any Alerts that fired on any host with this same process in the range of +-1d\n//\n\nlet GetAllAlertsWithProcess = (suspiciousEventTime:datetime, v_Process:string){\nlet v_StartTime = suspiciousEventTime-1d;\nlet v_EndTime = suspiciousEventTime+1d;\nSecurityAlert\n| where TimeGenerated between (v_StartTime .. v_EndTime)\n| where ProcessName has v_Process\n| extend Extprop = parsejson(ExtendedProperties)\n| extend ProcessName = parse_json(ExtendedProperties).[\"Suspicious Process\"]\n| extend Computer = iff(isnotempty(toupper(tostring(Extprop[\"Compromised Host\"]))), toupper(tostring(Extprop[\"Compromised Host\"])), tostring(parse_json(Entities)[0].HostName))\n| extend Account = iff(isnotempty(tolower(tostring(Extprop[\"User Name\"]))), tolower(tostring(Extprop[\"User Name\"])), tolower(tostring(Extprop[\"user name\"])))\n| extend IpAddress = tostring(parse_json(ExtendedProperties).[\"Client Address\"]) \n| project TimeGenerated, AlertName, ProcessName, Computer, Account, IpAddress, ExtendedProperties \n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress\n| top 10 by TimeGenerated desc nulls last\n};\n// change datetime value and \u003cprocessname\u003e value below\nGetAllAlertsWithProcess(datetime('2019-01-18T10:36:07Z'), \"\u003cprocessname\u003e\")\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_26')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityAlert",
                                             "displayName":  "Web shell command alert enrichment",
                                             "query":  "//Extracts MDATP Alerts that indicate a command was executed by a web shell. Uses time window based querying to idneitfy the potential web shell location on the server, then enriches with Attacker IP and User Agent\n//\nlet scriptExtensions = dynamic([\".php\", \".jsp\", \".js\", \".aspx\", \".asmx\", \".asax\", \".cfm\", \".shtml\"]);\nlet timeRange = 3d; \nlet lookupWindow = 1m;  \nlet lookupBin = lookupWindow / 2.0; \nlet distinctIpThreshold = 3; \nlet alerts = SecurityAlert  \n| where TimeGenerated \u003e ago(timeRange) \n| extend alertData = parse_json(Entities), recordGuid = new_guid(); \nlet shellAlerts = alerts \n| where ProviderName =~ \"MDATP\"  \n| mvexpand alertData \n| where alertData.Type =~ \"file\" and alertData.Name =~ \"w3wp.exe\" \n| distinct SystemAlertId \n| join kind=inner (alerts) on SystemAlertId; \nlet alldata = shellAlerts  \n| mvexpand alertData \n| extend Type = alertData.Type; \nlet filedata = alldata  \n| extend id = tostring(alertData.$id)  \n| extend ImageName = alertData.Name  \n| where Type =~ \"file\" and ImageName != \"w3wp.exe\" \n| extend imagefileref = id;  \nlet commanddata = alldata  \n| extend CommandLine = tostring(alertData.CommandLine)  \n| extend creationtime = tostring(alertData.CreationTimeUtc)  \n| where Type =~ \"process\"  \n| where isnotempty(CommandLine)  \n| extend imagefileref = tostring(alertData.ImageFile.$ref); \nlet hostdata = alldata \n| where Type =~ \"host\" \n| project HostName = tostring(alertData.HostName), DnsDomain = tostring(alertData.DnsDomain), SystemAlertId \n| distinct HostName, DnsDomain, SystemAlertId; \nlet commandKeyedData = filedata \n| join kind=inner (  \ncommanddata  \n) on imagefileref \n| join kind=inner (hostdata) on SystemAlertId \n| project recordGuid, TimeGenerated, ImageName, CommandLine, TimeKey = bin(TimeGenerated, lookupBin), HostName, DnsDomain \n| extend Start = TimeGenerated; \nlet baseline = W3CIISLog  \n| where TimeGenerated \u003e ago(timeRange) \n| project-rename SourceIP=cIP, PageAccessed=csUriStem \n| summarize dcount(SourceIP) by PageAccessed \n| where dcount_SourceIP \u003c= distinctIpThreshold; \ncommandKeyedData \n| join kind=inner ( \nW3CIISLog  \n| where TimeGenerated \u003e ago(timeRange) \n| where csUriStem has_any(scriptExtensions)  \n| extend splitUriStem = split(csUriStem, \"/\")  \n| extend FileName = splitUriStem[-1] | extend firstDir = splitUriStem[-2] | extend TimeKey = range(bin(TimeGenerated-lookupWindow, lookupBin), bin(TimeGenerated, lookupBin),lookupBin)  \n| mv-expand TimeKey to typeof(datetime)  \n| summarize StartTime=min(TimeGenerated), EndTime=max(TimeGenerated) by Site=sSiteName, HostName=sComputerName, AttackerIP=cIP, AttackerUserAgent=csUserAgent, csUriStem, filename=tostring(FileName), tostring(firstDir), TimeKey \n) on TimeKey, HostName \n| where (StartTime - EndTime) between (0min .. lookupWindow) \n| extend IPCustomEntity = AttackerIP, timestamp = StartTime\n| extend attackerP = pack(AttackerIP, AttackerUserAgent)  \n| summarize Site=make_set(Site), Attacker=make_bag(attackerP) by csUriStem, filename, tostring(ImageName), CommandLine, HostName, IPCustomEntity, timestamp\n| project Site, ShellLocation=csUriStem, ShellName=filename, ParentProcess=ImageName, CommandLine, Attacker, HostName, IPCustomEntity, timestamp\n| join kind=inner (baseline) on $left.ShellLocation == $right.PageAccessed\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_27')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityAlert",
                                             "displayName":  "Web shell file alert enrichment",
                                             "query":  "//Extracts MDATP Alert for a web shell being placed on the server and then enriches this event with information from W3CIISLog to idnetigy the Attacker that placed the shell\n//\nlet timeWindow = 3d;\nlet scriptExtensions = dynamic([\".php\", \".jsp\", \".js\", \".aspx\", \".asmx\", \".asax\", \".cfm\", \".shtml\"]);  \nSecurityAlert  \n| where TimeGenerated \u003e ago(timeWindow)  \n| where ProviderName =~ \"MDATP\" \n| extend alertData = parse_json(Entities)  \n| mvexpand alertData  \n// Get only the file type from the JSON, this gives us the file name\n| where alertData.Type =~ \"file\"  \n// This can be expanded to include other script extensions \n| where alertData.Name has_any(scriptExtensions)\n| extend FileName = alertData.Name \n| project TimeGenerated, tostring(FileName), alertData.Directory \n| join (  \nW3CIISLog  \n| where TimeGenerated \u003e ago(timeWindow)  \n| where csUriStem has_any(scriptExtensions) \n| extend splitUriStem = split(csUriStem, \"/\")  \n| extend FileName = splitUriStem[-1] \n| summarize StartTime=min(TimeGenerated), EndTime=max(TimeGenerated) by AttackerIP=cIP, AttackerUserAgent=csUserAgent, SiteName=sSiteName, ShellLocation=csUriStem, tostring(FileName)  \n) on FileName \n| project StartTime, EndTime, AttackerIP, AttackerUserAgent, SiteName, ShellLocation\n| extend timestamp = StartTime, IPCustomEntity = AttackerIP  \n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_28')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "AD Account Lockout",
                                             "query":  "//Detects Active Directory account lockouts\n//\nlet timeframe = 7d;\nSecurityEvent\n| where TimeGenerated \u003e= ago(timeframe)\n| where EventID == 4740\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), LockoutsCount = count() by Activity, Account, TargetSid, TargetDomainName, SourceComputerId, SourceDomainController = Computer\n| extend timestamp = StartTime, AccountCustomEntity = Account, HostCustomEntity = TargetDomainName\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_29')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "Cscript script daily summary breakdown",
                                             "query":  "//breakdown of scripts running in the environment\n//\n\nlet timeframe = 1d;\nlet ProcessCreationEvents=() {\nlet processEvents=SecurityEvent\n| where EventID==4688\n| project EventTime=TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName, AccountDomain=SubjectDomainName,\nFileName=tostring(split(NewProcessName, '\\\\')[-1]),  ProcessCommandLine = CommandLine, \nInitiatingProcessFileName=ParentProcessName,InitiatingProcessCommandLine=\"\",InitiatingProcessParentFileName=\"\";\nprocessEvents;\n};\n// Daily summary of cscript activity ? extracting script name and parameters from commandline:\nProcessCreationEvents \n| where EventTime \u003e= ago(timeframe)\n| where FileName =~ \"cscript.exe\"\n// remove commandline switches\n| project EventTime, ComputerName, AccountName, removeSwitches = replace(@\"/+[a-zA-Z0-9:]+\", \"\", ProcessCommandLine)\n// remove the leading cscript.exe process name \n| project EventTime, ComputerName, AccountName, CommandLine = trim(@\"[a-zA-Z0-9\\\\:\"\"]*cscript(.exe)?(\"\")?(\\s)+\", removeSwitches)\n// extract the script name:\n| project EventTime, ComputerName, AccountName, \n// handle case where script name is enclosed in \" characters or is not enclosed in quotes \nScriptName= iff(CommandLine startswith @\"\"\"\", \nextract(@\"([:\\\\a-zA-Z_\\-\\s0-9\\.()]+)(\"\"?)\", 0, CommandLine), \nextract(@\"([:\\\\a-zA-Z_\\-0-9\\.()]+)(\"\"?)\", 0, CommandLine)), CommandLine \n| project EventTime, ComputerName, AccountName, ScriptName=trim(@\"\"\"\", ScriptName) , ScriptNameLength=strlen(ScriptName), CommandLine \n// extract remainder of commandline as script parameters: \n| project EventTime, ComputerName, AccountName, ScriptName, ScriptParams = iff(ScriptNameLength \u003c strlen(CommandLine), substring(CommandLine, ScriptNameLength +1), \"\")\n| summarize min(EventTime), count() by ComputerName, AccountName, ScriptName, ScriptParams\n| order by count_ asc nulls last \n| extend timestamp = min_EventTime, HostCustomEntity = ComputerName, AccountCustomEntity = AccountName\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_30')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "VIP account more than 6 failed logons in 10",
                                             "query":  "//VIP Account with more than 6 failed logon attempts in 10 minutes, include your own VIP list in the table below\n// NTSTATUS codes - https://docs.microsoft.com/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55\n//\n\n// Create DataTable with your own values, example below shows dummy usernames and domain\nlet List = datatable(VIPUser:string, Domain:string)[\"Bob\", \"Domain\", \"joe\", \"domain\", \"MATT\", \"DOMAIN\", \"administrator\", \"\"];\nlet timeframe = 10m;\nList\n| project TargetUserName = tolower(VIPUser), TargetDomainName = toupper(Domain)\n| join kind= rightsemi ( \nSecurityEvent \n| where TimeGenerated \u003e ago(2*timeframe) \n| where EventID == \"4625\"\n| where AccountType == \"User\"\n) on TargetUserName, TargetDomainName\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), FailedVIPLogons = count() by EventID, Activity, WorkstationName, Account, TargetAccount, TargetUserName, TargetDomainName, LogonType, LogonTypeName, LogonProcessName, Status, SubStatus\n| where FailedVIPLogons \u003e= 6\n// map the most common ntstatus codes\n| extend StatusDesc = case(\nStatus =~ \"0x80090302\", \"SEC_E_UNSUPPORTED_FUNCTION\",\nStatus =~ \"0x80090308\", \"SEC_E_INVALID_TOKEN\",\nStatus =~ \"0x8009030E\", \"SEC_E_NO_CREDENTIALS\",\nStatus =~ \"0xC0000008\", \"STATUS_INVALID_HANDLE\",\nStatus =~ \"0xC0000017\", \"STATUS_NO_MEMORY\",\nStatus =~ \"0xC0000022\", \"STATUS_ACCESS_DENIED\",\nStatus =~ \"0xC0000034\", \"STATUS_OBJECT_NAME_NOT_FOUND\",\nStatus =~ \"0xC000005E\", \"STATUS_NO_LOGON_SERVERS\",\nStatus =~ \"0xC000006A\", \"STATUS_WRONG_PASSWORD\",\nStatus =~ \"0xC000006D\", \"STATUS_LOGON_FAILURE\",\nStatus =~ \"0xC000006E\", \"STATUS_ACCOUNT_RESTRICTION\",\nStatus =~ \"0xC0000073\", \"STATUS_NONE_MAPPED\",\nStatus =~ \"0xC00000FE\", \"STATUS_NO_SUCH_PACKAGE\",\nStatus =~ \"0xC000009A\", \"STATUS_INSUFFICIENT_RESOURCES\",\nStatus =~ \"0xC00000DC\", \"STATUS_INVALID_SERVER_STATE\",\nStatus =~ \"0xC0000106\", \"STATUS_NAME_TOO_LONG\",\nStatus =~ \"0xC000010B\", \"STATUS_INVALID_LOGON_TYPE\",\nStatus =~ \"0xC000015B\", \"STATUS_LOGON_TYPE_NOT_GRANTED\",\nStatus =~ \"0xC000018B\", \"STATUS_NO_TRUST_SAM_ACCOUNT\",\nStatus =~ \"0xC0000224\", \"STATUS_PASSWORD_MUST_CHANGE\",\nStatus =~ \"0xC0000234\", \"STATUS_ACCOUNT_LOCKED_OUT\",\nStatus =~ \"0xC00002EE\", \"STATUS_UNFINISHED_CONTEXT_DELETED\",\n\"See - https://docs.microsoft.com/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55\"\n)\n| extend SubStatusDesc = case(\nSubStatus =~ \"0x80090325\", \"SEC_E_UNTRUSTED_ROOT\",\nSubStatus =~ \"0xC0000008\", \"STATUS_INVALID_HANDLE\",\nSubStatus =~ \"0xC0000022\", \"STATUS_ACCESS_DENIED\",\nSubStatus =~ \"0xC0000064\", \"STATUS_NO_SUCH_USER\",\nSubStatus =~ \"0xC000006A\", \"STATUS_WRONG_PASSWORD\",\nSubStatus =~ \"0xC000006D\", \"STATUS_LOGON_FAILURE\",\nSubStatus =~ \"0xC000006E\", \"STATUS_ACCOUNT_RESTRICTION\",\nSubStatus =~ \"0xC000006F\", \"STATUS_INVALID_LOGON_HOURS\",\nSubStatus =~ \"0xC0000070\", \"STATUS_INVALID_WORKSTATION\",\nSubStatus =~ \"0xC0000071\", \"STATUS_PASSWORD_EXPIRED\",\nSubStatus =~ \"0xC0000072\", \"STATUS_ACCOUNT_DISABLED\",\nSubStatus =~ \"0xC0000073\", \"STATUS_NONE_MAPPED\",\nSubStatus =~ \"0xC00000DC\", \"STATUS_INVALID_SERVER_STATE\",\nSubStatus =~ \"0xC0000133\", \"STATUS_TIME_DIFFERENCE_AT_DC\",\nSubStatus =~ \"0xC000018D\", \"STATUS_TRUSTED_RELATIONSHIP_FAILURE\",\nSubStatus =~ \"0xC0000193\", \"STATUS_ACCOUNT_EXPIRED\",\nSubStatus =~ \"0xC0000380\", \"STATUS_SMARTCARD_WRONG_PIN\",\nSubStatus =~ \"0xC0000381\", \"STATUS_SMARTCARD_CARD_BLOCKED\",\nSubStatus =~ \"0xC0000382\", \"STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED\",\nSubStatus =~ \"0xC0000383\", \"STATUS_SMARTCARD_NO_CARD\",\nSubStatus =~ \"0xC0000384\", \"STATUS_SMARTCARD_NO_KEY_CONTAINER\",\nSubStatus =~ \"0xC0000385\", \"STATUS_SMARTCARD_NO_CERTIFICATE\",\nSubStatus =~ \"0xC0000386\", \"STATUS_SMARTCARD_NO_KEYSET\",\nSubStatus =~ \"0xC0000387\", \"STATUS_SMARTCARD_IO_ERROR\",\nSubStatus =~ \"0xC0000388\", \"STATUS_DOWNGRADE_DETECTED\",\nSubStatus =~ \"0xC0000389\", \"STATUS_SMARTCARD_CERT_REVOKED\",\n\"See - https://docs.microsoft.com/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55\"\n)\n| project StartTimeUtc, EndTimeUtc, FailedVIPLogons, EventID, Activity, WorkstationName, Account, TargetAccount, TargetUserName, TargetDomainName, LogonType, LogonTypeName, LogonProcessName, Status, StatusDesc, SubStatus, SubStatusDesc\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Account\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_31')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "Enumeration of users and groups",
                                             "query":  "//Finds attempts to list users or groups using the built-in Windows net tool \n//\n\nlet timeframe = 1d;\nlet ProcessCreationEvents=() {\nlet processEvents=SecurityEvent\n| where EventID==4688\n| project TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName,        AccountDomain=SubjectDomainName,\nFileName=tostring(split(NewProcessName, '\\\\')[-1]),\nProcessCommandLine = CommandLine, \nFolderPath = \"\",\nInitiatingProcessFileName=ParentProcessName,InitiatingProcessCommandLine=\"\",InitiatingProcessParentFileName=\"\";\nprocessEvents};\nProcessCreationEvents\n| where TimeGenerated \u003e= ago(timeframe)\n| where FileName == 'net.exe' and AccountName != \"\" and ProcessCommandLine !contains '\\\\'  and ProcessCommandLine !contains '/add' \n| where (ProcessCommandLine contains ' user ' or ProcessCommandLine contains ' group ') and (ProcessCommandLine endswith ' /do' or ProcessCommandLine endswith ' /domain') \n| extend Target = extract(\"(?i)[user|group] (\\\"*[a-zA-Z0-9-_ ]+\\\"*)\", 1, ProcessCommandLine) | filter Target  != '' \n| summarize minTimeGenerated=min(TimeGenerated), maxTimeGenerated=max(TimeGenerated), count() by AccountName, Target, ProcessCommandLine, ComputerName\n| project minTimeGenerated, maxTimeGenerated, count_, AccountName, Target, ProcessCommandLine, ComputerName\n| sort by AccountName, Target\n| extend timestamp = minTimeGenerated, AccountCustomEntity = AccountName, HostCustomEntity = ComputerName\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_32')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "Summary of failed user logons by reason of failure",
                                             "query":  "//A summary of failed logons can be used to infer lateral movement with the intention of discovering credentials and sensitive data\n//\n\nlet timeframe = 1d;\nSecurityEvent\n| where TimeGenerated \u003e= ago(timeframe)\n| where AccountType == 'User' and EventID == 4625\n| extend Reason = case(\nSubStatus == '0xc000005e', 'No logon servers available to service the logon request',\nSubStatus == '0xc0000062', 'Account name is not properly formatted',\nSubStatus == '0xc0000064', 'Account name does not exist',\nSubStatus == '0xc000006a', 'Incorrect password',    SubStatus == '0xc000006d', 'Bad user name or password',\nSubStatus == '0xc000006f', 'User logon blocked by account restriction',\nSubStatus == '0xc000006f', 'User logon outside of restricted logon hours',\nSubStatus == '0xc0000070', 'User logon blocked by workstation restriction',\nSubStatus == '0xc0000071', 'Password has expired',\nSubStatus == '0xc0000072', 'Account is disabled',\nSubStatus == '0xc0000133', 'Clocks between DC and other computer too far out of sync',\nSubStatus == '0xc000015b', 'The user has not been granted the requested logon right at this machine',\nSubStatus == '0xc0000193', 'Account has expirated',\nSubStatus == '0xc0000224', 'User is required to change password at next logon',\nSubStatus == '0xc0000234', 'Account is currently locked out',\nstrcat('Unknown reason substatus: ', SubStatus))\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by Reason\n| extend timestamp = StartTimeUtc\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_33')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "Group added to Built in Domain Local or Global Group",
                                             "query":  "//A Group created in the last 7 days was added to a privileged built in domain local group or global group such as the \n//Enterprise Admins, Cert Publishers or DnsAdmins.  Be sure to verify this is an expected addition\n//\n\nlet timeframe = 7d;\n// For AD SID mappings - https://docs.microsoft.com/windows/security/identity-protection/access-control/active-directory-security-groups\nlet WellKnownLocalSID = \"S-1-5-32-5[0-9][0-9]$\";\n// The SIDs for DnsAdmins and DnsUpdateProxy can be different than *-1102 and -*1103. Check these SIDs in your domain before running the query \nlet WellKnownGroupSID = \"S-1-5-21-[0-9]*-[0-9]*-[0-9]*-5[0-9][0-9]$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1102$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1103$\";\nlet GroupAddition = SecurityEvent \n| where TimeGenerated \u003e ago(timeframe)\n// 4728 - A member was added to a security-enabled global group\n// 4732 - A member was added to a security-enabled local group\n// 4756 - A member was added to a security-enabled universal group  \n| where EventID in (\"4728\", \"4732\", \"4756\") \n| where AccountType == \"User\" and MemberName == \"-\"\n// Exclude Remote Desktop Users group: S-1-5-32-555\n| where TargetSid !in (\"S-1-5-32-555\")\n| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID\n| project GroupAddTime = TimeGenerated, GroupAddEventID = EventID, GroupAddActivity = Activity, GroupAddComputer = Computer, \nGroupAddTargetUserName = TargetUserName, GroupAddTargetDomainName = TargetDomainName, GroupAddTargetSid = TargetSid,  \nGroupAddSubjectUserName = SubjectUserName, GroupAddSubjectUserSid = SubjectUserSid, GroupSid = MemberSid, Account, Computer\n| extend AccountCustomEntity = Account, HostCustomEntity = Computer;\nlet GroupCreated = SecurityEvent\n| where TimeGenerated \u003e ago(timeframe)\n// 4727 - A security-enabled global group was created\n// 4731 - A security-enabled local group was created\n// 4754 - A security-enabled universal group was created\n| where EventID in (\"4727\", \"4731\", \"4754\")\n| where AccountType == \"User\"\n| project GroupCreateTime = TimeGenerated, GroupCreateEventID = EventID, GroupCreateActivity = Activity, GroupCreateComputer = Computer, \nGroupCreateTargetUserName = TargetUserName, GroupCreateTargetDomainName = TargetDomainName, GroupCreateSubjectUserName = SubjectUserName, \nGroupCreateSubjectDomainName = SubjectDomainName, GroupCreateSubjectUserSid = SubjectUserSid, GroupSid = TargetSid, Account, Computer;\nGroupCreated\n| join (\nGroupAddition\n) on GroupSid\n| extend timestamp = GroupCreateTime, AccountCustomEntity = Account, HostCustomEntity = Computer\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_34')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "Hosts with new logons",
                                             "query":  "//Shows new accounts that have logged onto a host for the first time - this may clearly be benign activity but an account \n//logging onto multiple hosts for the first time can also be used to look for evidence of that account being used to move \n//laterally across a network.\n//\n\nlet starttime = 7d;\nlet endtime = 1d;\nlet LogonEvents=() { \nlet logonSuccess=SecurityEvent \n| where EventID==4624 \n| project TimeGenerated, ComputerName=Computer, AccountName=TargetUserName, AccountDomain=TargetDomainName, IpAddress, ActionType='Logon';\nlet logonFail=SecurityEvent \n| where EventID==4625 \n| project TimeGenerated, ComputerName=Computer, AccountName=TargetUserName, AccountDomain=TargetDomainName, IpAddress, ActionType='LogonFailure';\nlogonFail \n| union logonSuccess\n};\nLogonEvents \n| where TimeGenerated \u003e ago(endtime) \n| where ActionType == 'Logon' \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by ComputerName, AccountName \n| join kind=leftanti ( \nLogonEvents \n| where TimeGenerated between(ago(starttime)..ago(endtime)) \n| where ActionType == 'Logon' \n| summarize count() by ComputerName, AccountName \n) on ComputerName, AccountName \n| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc), HostCount=dcount(ComputerName), HostSet=makeset(ComputerName, 10)  by AccountName, ComputerName\n| extend timestamp = StartTimeUtc, AccountCustomEntity = AccountName\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_35')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "Least Common Parent And Child Process Pairs",
                                             "query":  "//Looks across your environment for least common Parent/Child process combinations.  \n//Will possibly find some malicious activity disguised as well known process names.  \n//By ZanCo\n//\n\nlet Allowlist = dynamic (['foo.exe', 'baz.exe']);\nlet Sensitivity = 5;\nlet StartDate = ago(7d);\nlet Duration = 7d;\nSecurityEvent\n| where EventID == 4688 and TimeGenerated \u003e StartDate and TimeGenerated \u003c (StartDate + Duration) and isnotnull(ParentProcessName)\n| extend ProcArray = split(NewProcessName, '\\\\'), ParentProcArray = split(ParentProcessName, '\\\\')\n// ProcArrayLength is Folder Depth\n| extend ProcArrayLength = arraylength(ProcArray), ParentProcArrayLength = arraylength(ParentProcArray)\n| extend LastIndex = ProcArrayLength - 1, ParentLastIndex = ParentProcArrayLength - 1\n| extend Proc = ProcArray[LastIndex], ParentProc = ParentProcArray[ParentLastIndex]\n| where Proc !in (Allowlist)\n| extend ParentChildPair = strcat(ParentProc , ' \u003e ', Proc)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), TimesSeen = count(), HostCount = dcount(Computer), Hosts = makeset(Computer), UserCount = dcount(SubjectUserName), Users = makeset(SubjectUserName) by ParentChildPair\n| where TimesSeen \u003c Sensitivity\n| extend timestamp = StartTimeUtc\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_36')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "Least Common Processes by Command Line",
                                             "query":  "//Looks across your environment for least common Process Command Lines, may be noisy and require allowlisting.  By ZanCo\n//\n\nlet Allowlist = dynamic (['foo.exe', 'baz.exe']);\nlet Sensitivity = 5;\nlet StartDate = ago(7d);\nlet Duration = 7d;\nSecurityEvent\n| where EventID == 4688 and TimeGenerated \u003e StartDate and TimeGenerated \u003c (StartDate + Duration) and NewProcessName !endswith 'conhost.exe'\n| extend ProcArray = split(NewProcessName, '\\\\')\n// ProcArrayLength is Folder Depth\n| extend ProcArrayLength = arraylength(ProcArray)\n| extend LastIndex = ProcArrayLength - 1\n| extend Proc = ProcArray[LastIndex]\n| where Proc !in (Allowlist)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), TimesSeen = count(), HostCount = dcount(Computer), Hosts = makeset(Computer), UserCount = dcount(SubjectUserName), Users = makeset(SubjectUserName) by CommandLine\n| where TimesSeen \u003c Sensitivity\n| extend timestamp = StartTimeUtc\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_37')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "Least Common Processes Including Folder Depth",
                                             "query":  "//Looks across your environment for least common Process Command Lines, may be noisy and require allowlisting.  By ZanCo\n//\n\nlet Allowlist = dynamic (['foo.exe', 'baz.exe']);\nlet Sensitivity = 15;\nlet StartDate = ago(7d);\nlet Duration = 7d;\nSecurityEvent\n| where EventID == 4688 and TimeGenerated \u003e StartDate and TimeGenerated \u003c (StartDate + Duration)\n| extend ProcArray = split(NewProcessName, '\\\\')\n// ProcArrayLength is Folder Depth\n| extend ProcArrayLength = arraylength(ProcArray)\n| extend LastIndex = ProcArrayLength - 1\n| extend Proc = ProcArray[LastIndex]\n| where Proc !in (Allowlist)\n// ProcArray[0] is the proc's Drive\n| extend DriveDepthProc = strcat(ProcArray[0], '-', ProcArrayLength, '-', Proc)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), TimesSeen = count(), HostCount = dcount(Computer), Hosts = makeset(Computer), UserCount = dcount(SubjectUserName), Users = makeset(SubjectUserName) by DriveDepthProc\n| where TimesSeen \u003c Sensitivity\n| extend timestamp = StartTimeUtc\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_38')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "Masquerading files",
                                             "query":  "//Malware writers often use windows system process names for their malicious process names to make them blend \n//in with other legitimate commands that the Windows system executes.\n//An analyst can create a simple query looking for a process named svchost.exe. \n//It is recommended to filter out well-known security identifiers (SIDs) that are used to launch the legitimate svchost.exe process. \n//The query also filters out the legitimate locations from which svchost.exe is launched.\n//\n\nlet timeframe = 1d;\nSecurityEvent\n| where TimeGenerated \u003e= ago(timeframe)\n| where NewProcessName endswith \"\\\\svchost.exe\"\n| where SubjectUserSid !in (\"S-1-5-18\", \"S-1-5-19\", \"S-1-5-20\")\n| where NewProcessName !contains \":\\\\Windows\\\\System32\"\n| where NewProcessName !contains \":\\\\Windows\\\\Syswow64\"\n| summarize minTimeGenerated=min(TimeGenerated), maxTimeGenerated=max(TimeGenerated), count() by Computer, SubjectUserName, NewProcessName, CommandLine, Account\n| project minTimeGenerated , maxTimeGenerated , count_ , Computer , SubjectUserName , NewProcessName , CommandLine, Account \n| extend timestamp = minTimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_39')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "New processes observed in last 24 hours",
                                             "query":  "//These new processes could be benign new programs installed on hosts; however, especially in normally stable environments, \n//these new processes could provide an indication of an unauthorized/malicious binary that has been installed and run. \n//Reviewing the wider context of the logon sessions in which these binaries ran can provide a good starting point for identifying possible attacks.\n//\n\nlet starttime = 14d;\nlet endtime = 1d;\nlet ProcessCreationEvents=() {\nlet processEvents=SecurityEvent\n| where EventID==4688\n| where TimeGenerated \u003e= ago(starttime) \n| project TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName, AccountDomain=SubjectDomainName, FileName=tostring(split(NewProcessName, @'')[(-1)]), ProcessCommandLine = CommandLine, InitiatingProcessFileName=ParentProcessName,InitiatingProcessCommandLine='',InitiatingProcessParentFileName='';\nprocessEvents};\nProcessCreationEvents\n| where TimeGenerated \u003e= ago(starttime) and TimeGenerated \u003c ago(endtime)\n| summarize HostCount=dcount(ComputerName) by tostring(FileName)\n| join kind=rightanti (\n    ProcessCreationEvents\n    | where TimeGenerated \u003e= ago(endtime)\n    | summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Computers = makeset(ComputerName) , HostCount=dcount(ComputerName) by tostring(FileName)\n) on FileName\n| project StartTimeUtc, Computers, HostCount, FileName\n| extend timestamp = StartTimeUtc\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_40')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "Summary of users created using uncommon/undocumented commandline switches",
                                             "query":  "//Summarizes uses of uncommon \u0026 undocumented commandline switches to create persistence\n//User accounts may be created to achieve persistence on a machine.\n//Read more here: https://attack.mitre.org/wiki/Technique/T1136\n//Query for users being created using \"net user\" command\n//\"net user\" commands are noisy, so needs to be joined with another signal -\n//e.g. in this example we look for some undocumented variations (e.g. /ad instead of /add)\n//\n\nlet timeframe = 1d;\nSecurityEvent\n| where TimeGenerated \u003e= ago(timeframe) \n| where EventID==4688\n| project TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName, \n    AccountDomain=SubjectDomainName, FileName=tostring(split(NewProcessName, '\\\\')[-1]), \n    ProcessCommandLine = CommandLine, \n    FolderPath = \"\", InitiatingProcessFileName=ParentProcessName,\n    InitiatingProcessCommandLine=\"\",InitiatingProcessParentFileName=\"\"\n| where FileName in~ (\"net.exe\", \"net1.exe\")\n| parse kind=regex flags=iU ProcessCommandLine with * \"user \" CreatedUser \" \" * \"/ad\"\n| where not(FileName =~ \"net1.exe\" and InitiatingProcessFileName =~ \"net.exe\" and replace(\"net\", \"net1\", InitiatingProcessCommandLine) =~ ProcessCommandLine)\n| extend CreatedOnLocalMachine=(ProcessCommandLine !contains \"/do\")\n| where ProcessCommandLine contains \"/add\" or (CreatedOnLocalMachine == 0 and ProcessCommandLine !contains \"/domain\")\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), MachineCount=dcount(ComputerName) by CreatedUser, CreatedOnLocalMachine, InitiatingProcessFileName, FileName, ProcessCommandLine, InitiatingProcessCommandLine\n| extend timestamp = StartTimeUtc, AccountCustomEntity = CreatedUser\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_41')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "PowerShell downloads",
                                             "query":  "//Finds PowerShell execution events that could involve a download\n//\n\nlet timeframe = 1d;\nlet ProcessCreationEvents=() {\nlet processEvents=SecurityEvent\n| where EventID==4688\n| project  TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName,        AccountDomain=SubjectDomainName,\n  FileName=tostring(split(NewProcessName, '\\\\')[-1]),\nProcessCommandLine = CommandLine, \nInitiatingProcessFileName=ParentProcessName,InitiatingProcessCommandLine=\"\",InitiatingProcessParentFileName=\"\";\nprocessEvents};\nProcessCreationEvents\n| where TimeGenerated \u003e= ago(timeframe) \n| where FileName in~ (\"powershell.exe\", \"powershell_ise.exe\")\n| where ProcessCommandLine has \"Net.WebClient\"\n   or ProcessCommandLine has \"DownloadFile\"\n   or ProcessCommandLine has \"Invoke-WebRequest\"\n   or ProcessCommandLine has \"Invoke-Shellcode\"\n   or ProcessCommandLine contains \"http:\"\n| project TimeGenerated, ComputerName, AccountName, InitiatingProcessFileName, FileName, ProcessCommandLine\n| top 100 by TimeGenerated\n| extend timestamp = TimeGenerated, HostCustomEntity = ComputerName, AccountCustomEntity = AccountName\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_42')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "New PowerShell scripts encoded on the commandline",
                                             "query":  "//Identify and decode new encoded powershell scripts this week versus previous 14 days\n//\n\nlet starttime = 21d;\nlet midtime = 14d;\nlet endtime = 7d;\nlet ProcessCreationEvents=() {\nlet processEvents=SecurityEvent\n| where EventID==4688\n| project  TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName,AccountDomain=SubjectDomainName,\n  FileName=tostring(split(NewProcessName, '\\\\')[-1]),\nProcessCommandLine = CommandLine, \nInitiatingProcessFileName=ParentProcessName,InitiatingProcessCommandLine=\"\",InitiatingProcessParentFileName=\"\";\nprocessEvents};\nlet encodedPSScripts = \nProcessCreationEvents \n| where TimeGenerated \u003e= ago(midtime)\n| where FileName =~ \"powershell.exe\"\n| where ProcessCommandLine contains \"-encodedCommand\";\nencodedPSScripts\n| where TimeGenerated \u003e ago(endtime)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by ProcessCommandLine\n| parse ProcessCommandLine with * \"-EncodedCommand \" encodedCommand\n| project StartTimeUtc, EndTimeUtc, decodedCommand=base64_decodestring(substring(encodedCommand, 0, \n strlen(encodedCommand) - (strlen(encodedCommand) %8))), encodedCommand \n| join kind=anti (encodedPSScripts\n  | where TimeGenerated between(ago(starttime)..ago(endtime))\n  | summarize count() by ProcessCommandLine\n  | parse ProcessCommandLine with * \"-EncodedCommand \" encodedCommand\n  | project decodedCommand=base64_decodestring(substring(encodedCommand, 0, \n   strlen(encodedCommand) - (strlen(encodedCommand) %8))), encodedCommand \n) on encodedCommand, decodedCommand \n| extend timestamp = StartTimeUtc\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_43')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "Entropy for Processes for a given Host",
                                             "query":  "//Entropy calculation used to help identify Hosts where they have a high variety of processes(a high entropy process list on a given Host over time).\n//This helps us identify rare processes on a given Host. Rare here means a process shows up on the Host relatively few times in the the last 7days.\n//The Weight is calculated based on the Entropy, Process Count and Distinct Hosts with that Process. The lower the Weight/ProcessEntropy the, more interesting.\n//The Weight calculation increases the Weight if the process executes more than once on the Host or has executed on more than 1 Hosts.\n//In general, this should identify processes on a Host that are rare and rare for the environment.\n//References: https://medium.com/udacity/shannon-entropy-information-gain-and-picking-balls-from-buckets-5810d35d54b4\n//https://en.wiktionary.org/wiki/Shannon_entropy\n//\n\n// May need to reduce the number of days if the environment is very large.  Try 3-5 days, but less accuracy.\nlet end = startofday(now());\nlet start = end - 7d;\nlet Exclude = SecurityEvent\n// Timeframe is set so that results do not change during the same day (UTC time)\n| where TimeGenerated \u003e= start and TimeGenerated \u003c= end\n| where EventID == 4688\n| summarize ExcludeCompCount = dcount(Computer),  ExcludeProcCount = count() by Process \n// Removing noisy processes for an environment, adjust as needed\n| where ExcludeProcCount \u003e= 2000 and ExcludeCompCount \u003e 2\n;\nlet AllSecEvents = SecurityEvent\n| where TimeGenerated \u003e= start and TimeGenerated \u003c= end\n| where EventID == 4688\n// excluding well known processes\n| where NewProcessName !endswith ':\\\\Windows\\\\System32\\\\conhost.exe' and ParentProcessName !endswith ':\\\\Windows\\\\System32\\\\conhost.exe'\n| where ParentProcessName !endswith \":\\\\Windows\\\\System32\\\\wuauclt.exe\" and NewProcessName !startswith \"C:\\\\Windows\\\\SoftwareDistribution\\\\Download\\\\Install\\\\AM_Delta_Patch_\"\n| where ParentProcessName !has \":\\\\WindowsAzure\\\\GuestAgent_\" and NewProcessName !has \":\\\\WindowsAzure\\\\GuestAgent_\"\n| where ParentProcessName !has \":\\\\WindowsAzure\\\\WindowsAzureNetAgent_\" and NewProcessName !has \":\\\\WindowsAzure\\\\WindowsAzureNetAgent_\"\n| where ParentProcessName !has \":\\\\ProgramData\\\\Microsoft\\\\Windows Defender\\\\platform\\\\\" and ParentProcessName !endswith \"\\\\MpCmdRun.exe\" \n| project Computer, Process;\n// Removing noisy process from full list\nlet Include = Exclude | join kind= rightanti (\nAllSecEvents\n) on Process;\n// Identifying prevalence for a given process in the environment\nlet DCwPC = Include | summarize DistinctComputersWithProcessCount = dcount(Computer) by Process\n| join kind=inner (\nInclude \n) on Process\n| distinct Computer, Process, DistinctComputersWithProcessCount;\n// Getting the Total process count on each host to use as the denominator in the entropy calc\nlet TPCoH = Include | summarize TotalProcessCountOnHost = count(Process) by Computer\n| join kind=inner (\nInclude \n) on Computer\n| distinct Computer, Process, TotalProcessCountOnHost\n//Getting a decimal value for later computation\n| extend TPCoHValue = todecimal(TotalProcessCountOnHost);\n// Need the count of each class in my bucket or also said as count of ProcName(Class) per Host(Bucket) for use in the entropy calc\nlet PCoH = Include | summarize ProcessCountOnHost = count(Process) by Computer, Process\n| join kind=inner (\nInclude\n) on Computer,Process\n| distinct Computer, Process, ProcessCountOnHost\n//Getting a decimal value for later computation\n| extend PCoHValue = todecimal(ProcessCountOnHost);\nlet Combined = DCwPC | join ( TPCoH ) on Computer, Process | join ( PCoH ) on Computer, Process; \nlet Results = Combined\n// Entropy calculation\n| extend ProcessEntropy = -log2(PCoHValue/TPCoHValue)*(PCoHValue/TPCoHValue)\n| extend AdjustedProcessEntropy = toreal(ProcessEntropy*10000)\n// Calculating Weight, see details in description\n| extend Weight = toreal((ProcessEntropy*10000)*ProcessCountOnHost*DistinctComputersWithProcessCount)\n// Remove or increase value to see processes with low entropy, meaning more common.\n| where Weight \u003c= 75\n| project Computer, Process, Weight , ProcessEntropy, TotalProcessCountOnHost, ProcessCountOnHost, DistinctComputersWithProcessCount, AdjustedProcessEntropy;\n// Join back full entry\nResults | join kind= inner (\n    SecurityEvent\n    | where TimeGenerated \u003e= start and TimeGenerated \u003c= end\n    | where EventID == 4688\n    // excluding well known processes\n    | where NewProcessName !endswith ':\\\\Windows\\\\System32\\\\conhost.exe' and ParentProcessName !endswith ':\\\\Windows\\\\System32\\\\conhost.exe'\n    | where ParentProcessName !endswith \":\\\\Windows\\\\System32\\\\wuauclt.exe\" and NewProcessName !startswith \"C:\\\\Windows\\\\SoftwareDistribution\\\\Download\\\\Install\\\\AM_Delta_Patch_\"\n    | where ParentProcessName !has \":\\\\WindowsAzure\\\\GuestAgent_\" and NewProcessName !has \":\\\\WindowsAzure\\\\GuestAgent_\"\n    | where ParentProcessName !has \":\\\\WindowsAzure\\\\WindowsAzureNetAgent_\" and NewProcessName !has \":\\\\WindowsAzure\\\\WindowsAzureNetAgent_\"\n    | where ParentProcessName !has \":\\\\ProgramData\\\\Microsoft\\\\Windows Defender\\\\platform\\\\\" and ParentProcessName !endswith \"\\\\MpCmdRun.exe\" \n    | project TimeGenerated, EventID, Computer, SubjectUserSid, Account, AccountType, Process, NewProcessName, CommandLine, ParentProcessName\n) on Computer, Process\n| project TimeGenerated, EventID, Computer, SubjectUserSid, Account, Weight, AdjustedProcessEntropy, FullDecimalProcessEntropy = ProcessEntropy, Process, NewProcessName, CommandLine, ParentProcessName, TotalProcessCountOnHost, ProcessCountOnHost, DistinctComputersWithProcessCount\n| sort by Weight asc, AdjustedProcessEntropy asc, NewProcessName asc\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_44')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "Rare processes run by Service accounts",
                                             "query":  "//Service accounts normally are supposed to perform a limited set of tasks in a stable environment. \n//The query collects a list of service account and then joins them with rare processes in an environment to detect anomalous behaviours.\n//\n\nlet timeframe = 1d;\nlet List1 = datatable(AccountName:string)[\"MSSQLSERVER\", \"ReportServer\", \"MSDTSServer100\", \"IUSR\"];         \n// Provide a list of service account/ built-in accounts in an environment.\nlet List2 = SecurityEvent                                                                                   \n// Self generating a list of Service account using event Id :4624\n| where TimeGenerated \u003e= ago(timeframe)\n| where EventID == \"4624\"\n| where Account !contains \"$\" and Account !contains \"Local SYSTEM\" and Account !contains  \"Local SERVICE\" and Account !contains  \"Network SERVICE\" and Account !contains \"NT AUTHORITY\" and Account !contains \"NT-AUTORIT??T\"\n| where LogonType == \"5\"                                                                                          \n| extend AccountName = Account \n| distinct AccountName;\nlet Accounts = List1 | union (List2 | distinct AccountName);\nlet ProcessCreationEvents=() {\n    let processEvents=SecurityEvent\n\t| where TimeGenerated \u003e= ago(timeframe)\n    | where EventID==4688\n    // filter out common randomly named files related to MSI installers and browsers\n    | where not(NewProcessName matches regex @\"\\\\TRA[0-9A-Fa-f]{3}\\.tmp\")\n    | where not(NewProcessName matches regex @\"\\\\TRA[0-9A-Fa-f]{4}\\.tmp\")\n    | where not(NewProcessName matches regex @\"Installer\\\\MSI[0-9A-Fa-f]{3}\\.tmp\")\n    | where not(NewProcessName matches regex @\"Installer\\\\MSI[0-9A-Fa-f]{4}\\.tmp\")\n    | project TimeGenerated, \n      ComputerName=Computer,\n      AccountName=SubjectUserName, \n      AccountDomain=SubjectDomainName,\n      FileName=tostring(split(NewProcessName, '\\\\')[-1]),\n      ProcessCommandLine = CommandLine, \n      InitiatingProcessFileName=ParentProcessName,\n      InitiatingProcessCommandLine=\"\",\n      InitiatingProcessParentFileName=\"\";\n    processEvents;\n    };\n    let normalizedProcesses = ProcessCreationEvents \n       // normalize guids\n       | project TimeGenerated, AccountName, FileName = replace(\"[0-9A-Fa-f]{8}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{12}\", \"\u003cguid\u003e\", FileName)\n       // normalize digits away\n       | project TimeGenerated, AccountName, FileName=replace(@'\\d', 'n', FileName); \nlet freqs = normalizedProcesses\n    | summarize frequency = count() by FileName\n    | join kind= leftouter (\n       normalizedProcesses\n       | summarize Since=min(TimeGenerated), LastSeen=max(TimeGenerated)  by FileName, AccountName\n    ) on FileName;\n   let Finalfreqs = freqs \n    | where frequency \u003c= toscalar( freqs | serialize | project frequency | summarize percentiles(frequency, 10))\n    | order by frequency asc\n    | project FileName, frequency, Since, LastSeen , AccountName \n    // restrict results to unusual processes seen in last day \n    | where LastSeen \u003e= ago(timeframe);\nAccounts\n    | join kind= inner (\n        Finalfreqs\n) on AccountName\n| where frequency \u003c 10\n| project-away AccountName1\n| extend AccountCustomEntity = AccountName \n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_45')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "Rare Process Path",
                                             "query":  "//Identifies when a process is running from a rare path. This could indicate malicious or unexpected activity as attacks \n//often try to use common process names running from non-standard locations\n//\n\nlet end = startofday(now());\nlet start = end - 8d;\nlet processEvents=\nSecurityEvent\n| where TimeGenerated \u003e= start and TimeGenerated \u003c= end\n| where EventID==4688\n// excluding well known processes\n| where NewProcessName !endswith ':\\\\Windows\\\\System32\\\\conhost.exe' and ParentProcessName !endswith ':\\\\Windows\\\\System32\\\\conhost.exe'\n| where ParentProcessName !endswith \":\\\\Windows\\\\System32\\\\wuauclt.exe\" and NewProcessName !startswith \"C:\\\\Windows\\\\SoftwareDistribution\\\\Download\\\\Install\\\\AM_Delta_Patch_\"\n| where NewProcessName !has \":\\\\Windows\\\\WinSxS\\\\amd64_microsoft-windows-servicingstack_\" and ParentProcessName !has \":\\\\Windows\\\\WinSxS\\\\amd64_microsoft-windows-servicingstack_\"\n| where NewProcessName !endswith \":\\\\WindowsAzure\\\\SecAgent\\\\WaSecAgentProv.exe\" \n| where ParentProcessName !has \":\\\\WindowsAzure\\\\GuestAgent_\" and NewProcessName !has \":\\\\WindowsAzure\\\\GuestAgent_\"\n| where ParentProcessName !has \":\\\\WindowsAzure\\\\WindowsAzureNetAgent_\" and NewProcessName !has \":\\\\WindowsAzure\\\\WindowsAzureNetAgent_\"\n| where ParentProcessName !has \":\\\\ProgramData\\\\Microsoft\\\\Windows Defender\\\\platform\\\\\" and ParentProcessName !endswith \"\\\\MpCmdRun.exe\" \n| where NewProcessName !has \":\\\\ProgramData\\\\Microsoft\\\\Windows Defender\\\\platform\\\\\" and NewProcessName !endswith \"\\\\MpCmdRun.exe\" \n| where NewProcessName !has ':\\\\Program Files\\\\Microsoft Monitoring Agent\\\\Agent\\\\'\n// filter out common randomly named paths and files\n| where not(NewProcessName matches regex @\"\\\\TRA[0-9A-Fa-f]{3}\\.tmp\")\n| where not(NewProcessName matches regex @\"\\\\TRA[0-9A-Fa-f]{4}\\.tmp\")\n| where not(NewProcessName matches regex @\"Installer\\\\MSI[0-9A-Fa-f]{3}\\.tmp\")\n| where not(NewProcessName matches regex @\"Installer\\\\MSI[0-9A-Fa-f]{4}\\.tmp\")\n| where not(NewProcessName matches regex @\"\\\\Windows\\\\Temp\\\\[0-9A-Za-z-]*\\\\DismHost\\.exe\")\n| where not(NewProcessName matches regex @\"\\\\Users\\\\[0-9A-Za-z-_~\\.]*\\\\AppData\\\\Local\\\\Temp\\\\[0-9A-Za-z-]*\\\\DismHost\\.exe\")\n| where not(NewProcessName matches regex @\"\\\\Windows\\\\Temp\\\\[0-9A-Za-z-]*\\\\MpSigStub\\.exe\")\n| where not(NewProcessName matches regex @\"\\\\[0-9A-Za-z]*\\\\amd64\\\\setup\\.exe\") and (ParentProcessName !has \":\\\\Windows\\\\SoftwareDistribution\\\\Download\\\\Install\\\\\" \nor ParentProcessName !has \"\\\\AppData\\\\Local\\\\Temp\\\\mpam-\")\n| where not(NewProcessName matches regex @\"\\\\Windows\\\\Microsoft.NET\\\\(Framework|Framework64)\\\\v[0-9].[0-9].[0-9]*\\\\(csc\\.exe|cvtres\\.exe|mscorsvw\\.exe|ngentask\\.exe|ngen\\.exe)\")\n| where not(NewProcessName matches regex @\"\\\\WindowsAzure\\\\GuestAgent_[0-9].[0-9].[0-9]*.[0-9]*_[0-9]*-[0-9]*-[0-9]*_[0-9]*\\\\\") \nand not(ParentProcessName matches regex @\"\\\\WindowsAzure\\\\GuestAgent_[0-9].[0-9].[0-9]*.[0-9]*_[0-9]*-[0-9]*-[0-9]*_[0-9]*\\\\\")\n| where not(NewProcessName matches regex @\"\\\\[0-9A-Za-z]*\\\\epplauncher.exe\")\n| where not(NewProcessName matches regex @\"\\\\Packages\\\\Plugins\\\\Microsoft\\.\")\n| extend path_parts = parse_path(NewProcessName)\n| extend ProcessPath = tostring(path_parts.DirectoryPath)\n;\nlet normalizedProcessPath = processEvents\n| extend NormalizedProcessPath = ProcessPath\n// normalize guids\n| project TimeGenerated, Computer, Account, Process, ProcessPath, \nNormalizedProcessPath = replace(\"[0-9A-Fa-f]{8}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{12}\", \"\u003cguid\u003e\", NormalizedProcessPath)\n// normalize digits away\n| project TimeGenerated, Computer, Account, Process, ProcessPath, NormalizedProcessPath = replace(@'\\d', '#', NormalizedProcessPath)\n; \nlet freqs = normalizedProcessPath\n| summarize makelist(Computer), makelist(Account), makelist(ProcessPath), frequency=count() by NormalizedProcessPath, Process\n| join kind= leftouter (\nnormalizedProcessPath\n| summarize StartTimeUtc=min(TimeGenerated), EndTimeUtc=max(TimeGenerated) by NormalizedProcessPath, Process\n) on NormalizedProcessPath, Process;\nfreqs\n| where frequency \u003c= toscalar( freqs | serialize | project frequency | summarize percentiles(frequency, 5))\n| order by frequency asc  \n| mvexpand Computer = list_Computer, Account = list_Account, ProcessPath = list_ProcessPath\n| project StartTimeUtc, EndTimeUtc, frequency, Process, NormalizedProcessPath, tostring(ProcessPath), tostring(Computer), tostring(Account)\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_46')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "Hosts running a rare process with commandline",
                                             "query":  "//Looking for hosts running a rare process. Less than 1% of the average for 30 days and less than a count of 100 on a given host or less than a 14 count on a given host from the last 7 days\n//\nlet v_StartTime = ago(7d);\nlet v_EndTime = ago(1m);\nlet basic=materialize(\n  SecurityEvent\n    | where TimeGenerated \u003e= ago(30d)\n    | where EventID == 4688\n    | where isnotempty(CommandLine) and NewProcessName !endswith \":\\\\windows\\\\system32\\\\conhost.exe\" and CommandLine !~ NewProcessName and CommandLine !~ strcat('\\\"',NewProcessName,'\\\"',\" \"))\n    | extend CommandLine=tolower(CommandLine)\n    | summarize FullCount = count()\n                , Count= countif(TimeGenerated between (v_StartTime .. v_EndTime))\n                , min_TimeGenerated=min(TimeGenerated)\n                , max_TimeGenerated=max(TimeGenerated) \n                      by Computer, NewProcessName, CommandLine\n    | where Count \u003e 0 and Count \u003c 100);\nlet basic_avg = basic\n    | summarize Avg = avg(FullCount) by  NewProcessName, CommandLine;\nbasic | project-away FullCount\n  | join kind=inner \nbasic_avg \n  on NewProcessName, CommandLine | project-away NewProcessName1, CommandLine1\n  | where Count \u003c 7 or (Count \u003c= Avg*0.01 and Count \u003c 100) \n  | extend HostCustomEntity=Computer\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_47')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "Hosts running a rare process",
                                             "query":  "//Looking for hosts running a rare process. Less than 1% of the average for 30 days and less than a count of 100 on a given host or less than a 14 count on a given host from the last 7 days\n//\nlet v_StartTime = ago(1d);\nlet v_EndTime = ago(1m);\nlet basic=materialize(\n  SecurityEvent\n    | where TimeGenerated \u003e= ago(30d)\n    | where EventID == 4688\n    | summarize FullCount = count()\n                , Count= countif(TimeGenerated between (v_StartTime .. v_EndTime))\n                , min_TimeGenerated=min(TimeGenerated)\n                , max_TimeGenerated=max(TimeGenerated) \n                      by Computer, NewProcessName\n    | where Count \u003e 0 and Count \u003c 100);\nlet basic_avg = basic\n    | summarize Avg = avg(FullCount) by  NewProcessName;\nbasic | project-away FullCount\n  | join kind=inner \nbasic_avg \n  on NewProcessName | project-away NewProcessName1\n  | where Count \u003c 14 or (Count \u003c= Avg*0.01 and Count \u003c 100) \n  | extend HostCustomEntity=Computer\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_48')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "Suspicious Windows Login outside normal hours",
                                             "query":  "//Looking for suspiciopus interactive logon events which are outside normal logon hours for the user. Current day logon events are comapred with last 14 days activity \n//and filtered for events which are above or below of historical logon hour range seen for the user.\n//\nlet v_StartTime = 14d;\nlet v_EndTime = 2d;\nlet lookback = 1d;\nlet AllLogonEvents = materialize(\nSecurityEvent\n| where TimeGenerated  between (ago(v_StartTime)..ago(v_EndTime))\n| where EventID in (4624, 4625)\n| where LogonTypeName in~ ('2 - Interactive','10 - RemoteInteractive')\n| where AccountType =~ 'User'\n| extend HourOfLogin = hourofday(TimeGenerated), DayNumberofWeek = dayofweek(TimeGenerated)\n| extend DayofWeek = case(\nDayNumberofWeek == \"00:00:00\", \"Sunday\", \nDayNumberofWeek == \"1.00:00:00\", \"Monday\", \nDayNumberofWeek == \"2.00:00:00\", \"Tuesday\", \nDayNumberofWeek == \"3.00:00:00\", \"Wednesday\", \nDayNumberofWeek == \"4.00:00:00\", \"Thursday\", \nDayNumberofWeek == \"5.00:00:00\", \"Friday\", \nDayNumberofWeek == \"6.00:00:00\", \"Saturday\",\"InvalidTimeStamp\")\n// map the most common ntstatus codes\n| extend StatusDesc = case(\nStatus =~ \"0x80090302\", \"SEC_E_UNSUPPORTED_FUNCTION\",\nStatus =~ \"0x80090308\", \"SEC_E_INVALID_TOKEN\",\nStatus =~ \"0x8009030E\", \"SEC_E_NO_CREDENTIALS\",\nStatus =~ \"0xC0000008\", \"STATUS_INVALID_HANDLE\",\nStatus =~ \"0xC0000017\", \"STATUS_NO_MEMORY\",\nStatus =~ \"0xC0000022\", \"STATUS_ACCESS_DENIED\",\nStatus =~ \"0xC0000034\", \"STATUS_OBJECT_NAME_NOT_FOUND\",\nStatus =~ \"0xC000005E\", \"STATUS_NO_LOGON_SERVERS\",\nStatus =~ \"0xC000006A\", \"STATUS_WRONG_PASSWORD\",\nStatus =~ \"0xC000006D\", \"STATUS_LOGON_FAILURE\",\nStatus =~ \"0xC000006E\", \"STATUS_ACCOUNT_RESTRICTION\",\nStatus =~ \"0xC0000073\", \"STATUS_NONE_MAPPED\",\nStatus =~ \"0xC00000FE\", \"STATUS_NO_SUCH_PACKAGE\",\nStatus =~ \"0xC000009A\", \"STATUS_INSUFFICIENT_RESOURCES\",\nStatus =~ \"0xC00000DC\", \"STATUS_INVALID_SERVER_STATE\",\nStatus =~ \"0xC0000106\", \"STATUS_NAME_TOO_LONG\",\nStatus =~ \"0xC000010B\", \"STATUS_INVALID_LOGON_TYPE\",\nStatus =~ \"0xC000015B\", \"STATUS_LOGON_TYPE_NOT_GRANTED\",\nStatus =~ \"0xC000018B\", \"STATUS_NO_TRUST_SAM_ACCOUNT\",\nStatus =~ \"0xC0000224\", \"STATUS_PASSWORD_MUST_CHANGE\",\nStatus =~ \"0xC0000234\", \"STATUS_ACCOUNT_LOCKED_OUT\",\nStatus =~ \"0xC00002EE\", \"STATUS_UNFINISHED_CONTEXT_DELETED\",\nEventID == 4624, \"Success\",\n\"See - https://docs.microsoft.com/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55\"\n)\n| extend SubStatusDesc = case(\nSubStatus =~ \"0x80090325\", \"SEC_E_UNTRUSTED_ROOT\",\nSubStatus =~ \"0xC0000008\", \"STATUS_INVALID_HANDLE\",\nSubStatus =~ \"0xC0000022\", \"STATUS_ACCESS_DENIED\",\nSubStatus =~ \"0xC0000064\", \"STATUS_NO_SUCH_USER\",\nSubStatus =~ \"0xC000006A\", \"STATUS_WRONG_PASSWORD\",\nSubStatus =~ \"0xC000006D\", \"STATUS_LOGON_FAILURE\",\nSubStatus =~ \"0xC000006E\", \"STATUS_ACCOUNT_RESTRICTION\",\nSubStatus =~ \"0xC000006F\", \"STATUS_INVALID_LOGON_HOURS\",\nSubStatus =~ \"0xC0000070\", \"STATUS_INVALID_WORKSTATION\",\nSubStatus =~ \"0xC0000071\", \"STATUS_PASSWORD_EXPIRED\",\nSubStatus =~ \"0xC0000072\", \"STATUS_ACCOUNT_DISABLED\",\nSubStatus =~ \"0xC0000073\", \"STATUS_NONE_MAPPED\",\nSubStatus =~ \"0xC00000DC\", \"STATUS_INVALID_SERVER_STATE\",\nSubStatus =~ \"0xC0000133\", \"STATUS_TIME_DIFFERENCE_AT_DC\",\nSubStatus =~ \"0xC000018D\", \"STATUS_TRUSTED_RELATIONSHIP_FAILURE\",\nSubStatus =~ \"0xC0000193\", \"STATUS_ACCOUNT_EXPIRED\",\nSubStatus =~ \"0xC0000380\", \"STATUS_SMARTCARD_WRONG_PIN\",\nSubStatus =~ \"0xC0000381\", \"STATUS_SMARTCARD_CARD_BLOCKED\",\nSubStatus =~ \"0xC0000382\", \"STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED\",\nSubStatus =~ \"0xC0000383\", \"STATUS_SMARTCARD_NO_CARD\",\nSubStatus =~ \"0xC0000384\", \"STATUS_SMARTCARD_NO_KEY_CONTAINER\",\nSubStatus =~ \"0xC0000385\", \"STATUS_SMARTCARD_NO_CERTIFICATE\",\nSubStatus =~ \"0xC0000386\", \"STATUS_SMARTCARD_NO_KEYSET\",\nSubStatus =~ \"0xC0000387\", \"STATUS_SMARTCARD_IO_ERROR\",\nSubStatus =~ \"0xC0000388\", \"STATUS_DOWNGRADE_DETECTED\",\nSubStatus =~ \"0xC0000389\", \"STATUS_SMARTCARD_CERT_REVOKED\",\nEventID == 4624, \"Success\",\n\"See - https://docs.microsoft.com/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55\"\n)\n| project StartTime = TimeGenerated, DayofWeek, HourOfLogin, EventID, Activity, IpAddress, WorkstationName, Computer, TargetUserName, TargetDomainName, ProcessName, SubjectUserName, PrivilegeList, LogonTypeName, StatusDesc, SubStatusDesc\n);\nAllLogonEvents\n| where TargetDomainName !in (\"Window Manager\",\"Font Driver Host\")\n| summarize max(HourOfLogin), min(HourOfLogin), historical_DayofWeek=make_set(DayofWeek) by TargetUserName\n| join kind= inner\n(\n    AllLogonEvents\n    | where StartTime \u003e ago(lookback)\n)\non TargetUserName\n// Filtering for logon events based on range of max and min of historical logon hour values seen\n| where HourOfLogin \u003e max_HourOfLogin or HourOfLogin \u003c min_HourOfLogin\n// Also populating additional column showing historical days of week when logon was seen\n| extend historical_DayofWeek = tostring(historical_DayofWeek)\n| summarize Total= count(), max(HourOfLogin), min(HourOfLogin), current_DayofWeek =make_set(DayofWeek), StartTime=max(StartTime), EndTime = min(StartTime), SourceIP = make_set(IpAddress), SourceHost = make_set(WorkstationName), SubjectUserName = make_set(SubjectUserName), HostLoggedOn = make_set(Computer) by EventID, Activity, TargetDomainName, TargetUserName , ProcessName , LogonTypeName, StatusDesc, SubStatusDesc, historical_DayofWeek\n| extend historical_DayofWeek = todynamic(historical_DayofWeek) \n| extend timestamp = StartTime, AccountCustomEntity = TargetUserName\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_49')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "Uncommon processes - bottom 5%",
                                             "query":  "//Shows the rarest processes seen running for the first time. (Performs best over longer time ranges - eg 3+ days rather than 24 hours!)\n//These new processes could be benign new programs installed on hosts; \n//However, especially in normally stable environments, these new processes could provide an indication of an unauthorized/malicious binary that has been installed and run. \n//Reviewing the wider context of the logon sessions in which these binaries ran can provide a good starting point for identifying possible attacks.\n//\n\nlet timeframe = 1d;\nlet ProcessCreationEvents=() {\nlet processEvents=SecurityEvent\n| where EventID==4688\n// filter out common randomly named files related to MSI installers and browsers\n| where not(NewProcessName matches regex @\"\\\\TRA[0-9A-Fa-f]{3}\\.tmp\")\n| where not(NewProcessName matches regex @\"\\\\TRA[0-9A-Fa-f]{4}\\.tmp\")\n| where not(NewProcessName matches regex @\"Installer\\\\MSI[0-9A-Fa-f]{3}\\.tmp\")\n| where not(NewProcessName matches regex @\"Installer\\\\MSI[0-9A-Fa-f]{4}\\.tmp\")\n| project TimeGenerated, ComputerName=Computer, AccountName=SubjectUserName, AccountDomain=SubjectDomainName,\nFileName=tostring(split(NewProcessName, '\\\\')[-1]), ProcessCommandLine = CommandLine, \nInitiatingProcessFileName=ParentProcessName, InitiatingProcessCommandLine=\"\", InitiatingProcessParentFileName=\"\";\nprocessEvents;\n};\nlet normalizedProcesses = ProcessCreationEvents \n| where TimeGenerated \u003e= ago(timeframe)\n// normalize guids\n| project TimeGenerated, FileName = replace(\"[0-9A-Fa-f]{8}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{12}\", \"\u003cguid\u003e\", FileName)\n// normalize digits away\n| project TimeGenerated, FileName=replace(@'\\d', 'n', FileName); \nlet freqs = normalizedProcesses\n| summarize frequency=count() by FileName\n| join kind= leftouter (\nnormalizedProcesses\n| summarize Since=min(TimeGenerated), LastSeen=max(TimeGenerated) by FileName\n) on FileName;\nfreqs \n| where frequency \u003c= toscalar( freqs | serialize | project frequency | summarize percentiles(frequency, 5))\n| order by frequency asc\n| project FileName, frequency, Since, LastSeen \n// restrict results to unusual processes seen in last day \n| where LastSeen \u003e= ago(1d)\n| extend timestamp = LastSeen \n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_50')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "Summary of user logons by logon type",
                                             "query":  "//Comparing succesful and nonsuccessful logon attempts can be used to identify attempts to move laterally within the \n//environment with the intention of discovering credentials and sensitive data.\n//\n\nlet timeframe = 1d;\nSecurityEvent\n| where TimeGenerated \u003e= ago(timeframe)\n| where EventID in (4624, 4625)\n| where AccountType == 'User' \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Amount = count() by LogonTypeName\n| extend timestamp = StartTimeUtc\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_51')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "User Account added to Built in Domain Local or Global Group",
                                             "query":  "//User account was added to a privileged built in domain local group or global group such as the Enterprise Adminis, Cert Publishers or DnsAdmins\n//Be sure to verify this is an expected addition.\n//\n\nlet timeframe = 10d;\n// For AD SID mappings - https://docs.microsoft.com/windows/security/identity-protection/access-control/active-directory-security-groups\nlet WellKnownLocalSID = \"S-1-5-32-5[0-9][0-9]$\";\nlet WellKnownGroupSID = \"S-1-5-21-[0-9]*-[0-9]*-[0-9]*-5[0-9][0-9]$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1102$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1103$\";\nSecurityEvent \n| where TimeGenerated \u003e ago(timeframe) \n| where AccountType == \"User\"\n// 4728 - A member was added to a security-enabled global group\n// 4732 - A member was added to a security-enabled local group\n// 4756 - A member was added to a security-enabled universal group\n| where EventID in (\"4728\", \"4732\", \"4756\")   \n| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID\n// Exclude Remote Desktop Users group: S-1-5-32-555\n| where TargetSid !in (\"S-1-5-32-555\")\n| project StartTimeUtc = TimeGenerated, EventID, Activity, Computer, TargetUserName, TargetDomainName, TargetSid, UserPrincipalName, SubjectUserName, SubjectUserSid \n| extend timestamp = StartTimeUtc, HostCustomEntity = Computer, AccountCustomEntity = UserPrincipalName\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_52')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "Long lookback User Account Created and Deleted within 10mins",
                                             "query":  "//User account created and then deleted within 10 minutes across last 14 days\n//\n\n// TimeFrame is the number of lookback days, default is last 14 days\nlet timeframe = 14d;\n// TimeDelta is the difference between when the account was created and when it was deleted, default is set to 10min or less\nlet timedelta = 10m;\nSecurityEvent \n| where TimeGenerated \u003e ago(timeframe) \n// A user account was created\n| where EventID == \"4720\"\n| where AccountType == \"User\"\n| project creationTime = TimeGenerated, CreateEventID = EventID, Activity, Computer, TargetUserName, UserPrincipalName, \nAccountUsedToCreate = SubjectUserName, TargetSid, SubjectUserSid \n| join kind= inner (\n   SecurityEvent\n   | where TimeGenerated \u003e ago(timeframe) \n   // A user account was deleted \n   | where EventID == \"4726\" \n| where AccountType == \"User\"\n| project deletionTime = TimeGenerated, DeleteEventID = EventID, Activity, Computer, TargetUserName, UserPrincipalName, \nAccountUsedToDelete = SubjectUserName, TargetSid, SubjectUserSid \n) on Computer, TargetUserName\n| where deletionTime - creationTime \u003c timedelta\n| extend TimeDelta = deletionTime - creationTime\n| where tolong(TimeDelta) \u003e= 0\n| project TimeDelta, creationTime, CreateEventID, Computer, TargetUserName, UserPrincipalName, AccountUsedToCreate, \ndeletionTime, DeleteEventID, AccountUsedToDelete\n| extend timestamp = creationTime, HostCustomEntity = Computer, AccountCustomEntity = UserPrincipalName\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_53')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "User account added or removed from a security group by an unauthorized user",
                                             "query":  "//User account added or removed from a security group by an unauthorized user, pass in a list\n//\n\n// Create DataTable with your own values, example below shows dummy usernames that are authorized and for what domain\nlet List = datatable(AuthorizedUser:string, Domain:string)[\"Bob\", \"Domain\", \"joe\", \"domain\", \"MATT\", \"DOMAIN\"];\nlet timeframe = 1d;\nSecurityEvent\n| where TimeGenerated \u003e= ago(timeframe)\n| where EventID in (4728, 4729, 4732, 4733, 4746, 4747, 4751, 4752, 4756, 4757, 4761, 4762)\n| join kind= leftanti (\n    List\n    | project SubjectUserName = tolower(AuthorizedUser), SubjectDomainName = toupper(Domain)\n) on SubjectUserName, SubjectDomainName\n| project TimeGenerated, Computer, Account, SubjectUserName, SubjectDomainName, TargetAccount, EventID, Activity\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_54')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "User created by unauthorized user",
                                             "query":  "//User account created by an unauthorized user, pass in a list\n//\n\n// Create DataTable with your own values, example below shows dummy usernames that are authorized and for what domain\nlet List = datatable(AuthorizedUser:string, Domain:string)[\"Bob\", \"Domain\", \"joe\", \"domain\", \"MATT\", \"DOMAIN\"];\nlet timeframe = 1d;\nSecurityEvent\n| where TimeGenerated \u003e= ago(timeframe)\n| where EventID == 4720\n| where AccountType == \"User\"\n| join kind= leftanti (\n    List\n    | project SubjectUserName = tolower(AuthorizedUser), SubjectDomainName = toupper(Domain)\n) on SubjectUserName, SubjectDomainName\n| project TimeGenerated, Computer, Account, SubjectUserName, SubjectDomainName, TargetAccount, EventID, Activity\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_55')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SecurityEvent",
                                             "displayName":  "VIP account more than 6 failed logons in 10",
                                             "query":  "//VIP Account with more than 6 failed logon attempts in 10 minutes, include your own VIP list in the table below\n//\n\n// Create DataTable with your own values, example below shows dummy usernames that are authorized and for what domain\nlet List = datatable(VIPUser:string, Domain:string)[\"Bob\", \"Domain\", \"joe\", \"domain\", \"MATT\", \"DOMAIN\"];\nlet timeframe = 10m;\nList | extend Account = strcat(Domain,\"\\\\\",VIPUser) | join kind= inner (\nSecurityEvent \n| where TimeGenerated \u003e ago(timeframe) \n| where EventID == \"4625\"\n| where AccountType == \"User\"\n| where LogonType == \"2\" or LogonType == \"3\"\n) on Account \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), FailedVIPLogons = count() by LogonType, Account\n| where FailedVIPLogons \u003e= 6\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Account\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_56')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SigninLogs",
                                             "displayName":  "Anomalous sign-in location by user account and authenticating application",
                                             "query":  "//This query over Azure Active Directory sign-in considers all user sign-ins for each Azure Active \n//Directory application and picks out the most anomalous change in location profile for a user within an \n//individual application. The intent is to hunt for user account compromise, possibly via a specific application\n//vector.\n//\n\nlet timeRange=ago(14d);\nSigninLogs \n// Forces Log Analytics to recognize that the query should be run over full time range\n| where TimeGenerated \u003e= timeRange\n| extend  locationString= strcat(tostring(LocationDetails[\"countryOrRegion\"]), \"/\", \ntostring(LocationDetails[\"state\"]), \"/\", tostring(LocationDetails[\"city\"]), \";\") \n| project TimeGenerated, AppDisplayName, UserPrincipalName, locationString \n// Create time series \n| make-series dLocationCount = dcount(locationString) on TimeGenerated in range(timeRange,now(), 1d) \nby UserPrincipalName, AppDisplayName \n// Compute best fit line for each entry \n| extend (RSquare, Slope, Variance, RVariance, Interception, LineFit) = series_fit_line(dLocationCount) \n// Chart the 3 most interesting lines  \n// A 0-value slope corresponds to an account being completely stable over time for a given Azure Active Directory application\n| top 3 by Slope desc\n| extend AccountCustomEntity = UserPrincipalName \n| render timechart\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_57')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SigninLogs",
                                             "displayName":  "Anomalous sign-in location by user account and authenticating application - with sign-in details",
                                             "query":  "//This query over Azure Active Directory sign-in considers all user sign-ins for each Azure Active \n//Directory application and picks out the most anomalous change in location profile for a user within an \n//individual application. The intent is to hunt for user account compromise, possibly via a specific application\n//vector.\n//This variation of the query joins the results back onto the original sign-in data to allow review of the \n//location set with each identified user in tabular form.\n//\n\nlet timeRange = ago(14d);\nSigninLogs \n// Forces Log Analytics to recognize that the query should be run over full time range\n| where TimeGenerated \u003e= timeRange\n| extend  locationString= strcat(tostring(LocationDetails[\"countryOrRegion\"]), \"/\", \ntostring(LocationDetails[\"state\"]), \"/\", tostring(LocationDetails[\"city\"]), \";\") \n| project TimeGenerated, AppDisplayName , UserPrincipalName, locationString \n// Create time series \n| make-series dLocationCount = dcount(locationString) on TimeGenerated in range(timeRange,now(), 1d) \nby UserPrincipalName, AppDisplayName \n// Compute best fit line for each entry \n| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dLocationCount) \n// Chart the 3 most interesting lines  \n// A 0-value slope corresponds to an account being completely stable over time for a given Azure Active Directory application\n| top 3 by Slope desc  \n// Extract the set of locations for each top user:\n| join kind=inner (SigninLogs\n| where TimeGenerated \u003e= timeRange\n| extend  locationString= strcat(tostring(LocationDetails[\"countryOrRegion\"]), \"/\", \ntostring(LocationDetails[\"state\"]), \"/\", tostring(LocationDetails[\"city\"]), \";\")\n| summarize locationList = makeset(locationString), threeDayWindowLocationCount=dcount(locationString) by AppDisplayName, UserPrincipalName, \ntimerange=bin(TimeGenerated, 3d)) on AppDisplayName, UserPrincipalName\n| order by UserPrincipalName, timerange asc\n| project timerange, AppDisplayName , UserPrincipalName, threeDayWindowLocationCount, locationList \n| order by AppDisplayName, UserPrincipalName, timerange asc\n| extend timestamp = timerange, AccountCustomEntity = UserPrincipalName\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_58')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SigninLogs",
                                             "displayName":  "Anomalous Azure Active Directory apps based on authentication location",
                                             "query":  "//This query over Azure AD sign-in activity highlights Azure AD apps with \n//an unusually high ratio of distinct geolocations versus total number of authentications\n//\n\nlet timeRange=ago(14d);\nlet azureSignIns = \nSigninLogs\n| where TimeGenerated \u003e= timeRange\n| where SourceSystem == \"Azure AD\"\n| where OperationName == \"Sign-in activity\"\n| project TimeGenerated, OperationName, AppDisplayName , Identity, UserId, UserPrincipalName, Location, LocationDetails, \nClientAppUsed, DeviceDetail, ConditionalAccessPolicies;\nazureSignIns\n| extend locationString = strcat(tostring(LocationDetails[\"countryOrRegion\"]), \"/\", \ntostring(LocationDetails[\"state\"]), \"/\", tostring(LocationDetails[\"city\"]), \";\" , tostring(LocationDetails[\"geoCoordinates\"]))\n| summarize rawSigninCount = count(), countByAccount = dcount(UserId), locationCount = dcount(locationString) by AppDisplayName\n// tail - pick a threshold to rule out the very-high volume Azure AD apps\n| where rawSigninCount \u003c 1000\n// more locations than accounts\n| where locationCount\u003ecountByAccount\n// almost as many / more locations than sign-ins!\n| where 1.0*rawSigninCount / locationCount \u003e 0.8 \n| order by rawSigninCount  desc\n| join kind = leftouter (\n   azureSignIns \n) on AppDisplayName \n| project AppDisplayName, TimeGenerated , Identity, rawSigninCount, countByAccount, locationCount,  \nlocationString = strcat(tostring(LocationDetails[\"countryOrRegion\"]), \"/\", tostring(LocationDetails[\"state\"]), \"/\", \ntostring(LocationDetails[\"city\"]), \";\" , tostring(LocationDetails[\"geoCoordinates\"])), UserPrincipalName\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName \n| order by AppDisplayName, TimeGenerated desc\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_59')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SigninLogs",
                                             "displayName":  "Attempts to sign in to disabled accounts by account name",
                                             "query":  "//Failed attempts to sign in to disabled accounts summarized by account name\n//\n\nlet timeRange = 14d;\nSigninLogs \n| where TimeGenerated \u003e= ago(timeRange)\n| where ResultType == \"50057\" \n| where ResultDescription == \"User account is disabled. The account has been disabled by an administrator.\" \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by AppDisplayName, UserPrincipalName\n| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName\n| order by count_ desc\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_60')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SigninLogs",
                                             "displayName":  "Attempts to sign in to disabled accounts by IP address",
                                             "query":  "//Failed attempts to sign in to disabled accounts summarized by the IP address from from the sign-in attempts originate\n//\n\nlet timeRange = 14d;\nSigninLogs \n| where TimeGenerated \u003e= ago(timeRange)\n| where ResultType == \"50057\" \n| where ResultDescription == \"User account is disabled. The account has been disabled by an administrator.\" \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), numberAccountsTargeted = dcount(UserPrincipalName), \nnumberApplicationsTargeted = dcount(AppDisplayName), accountSet = makeset(UserPrincipalName), applicationSet=makeset(AppDisplayName), \nnumberLoginAttempts = count() by IPAddress\n| extend timestamp = StartTimeUtc, IPCustomEntity = IPAddress\n| order by numberLoginAttempts desc\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_61')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SigninLogs",
                                             "displayName":  "Inactive or new account signins",
                                             "query":  "//Query for accounts seen signing in for the first time - these could be associated\n//with stale/inactive accounts that ought to have been deleted but werent - and have \n//subseuqently been compromised. \n//Results for user accounts created in the last 7 days are filtered out\n//\n\n//Inactive accounts that sign in - first-time logins for accounts created in last 7 days are filtered out\nlet starttime = 14d;\nlet midtime = 7d;\nlet endtime = 1d;\nSigninLogs\n| where TimeGenerated \u003e= ago(endtime)\n// successful sign-in\n| where ResultType == 0\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), loginCountToday=count() by UserPrincipalName, Identity\n| join kind=leftanti (\n   SigninLogs\n   // historical successful sign-in\n   | where TimeGenerated \u003c ago(endtime)\n   | where TimeGenerated \u003e= ago(starttime)\n   | where ResultType == 0\n   | summarize by UserPrincipalName, Identity\n) on UserPrincipalName \n| join kind= leftanti (\n   // filter out newly created user accounts\n   AuditLogs\n   | where TimeGenerated \u003e= ago(midtime)\n   | where OperationName == \"Add user\" \n   // Normalize to lower case in order to match against equivalent UPN in Signin logs\n   | extend NewUserPrincipalName = tolower(extractjson(\"$.userPrincipalName\", tostring(TargetResources[0]), typeof(string)))\n) on $left.UserPrincipalName == $right.NewUserPrincipalName \n| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_62')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SigninLogs",
                                             "displayName":  "Login attempts using Legacy Auth",
                                             "query":  "//This query over Azure AD sign-in activity highlights use of legacy authentication protocol in the \n//environment. Because conditional access policies are not evaluated when legacy authentication is used, \n//legacy authentication can be used to circumvent all Azure Conditional Access policies.\n//\n\nlet endtime = 1d;\nlet starttime = 7d;\nlet legacyAuthentications =\nSigninLogs\n| where TimeGenerated \u003e= ago(starttime)\n// success logons only\n| where ResultType == 0\n| extend ClientAppUsed = iff(isempty(ClientAppUsed)==true,\"Unknown\" ,ClientAppUsed)\n| extend isLegacyAuth = case(\nClientAppUsed contains \"Browser\", \"No\", \nClientAppUsed contains \"Mobile Apps and Desktop clients\", \"No\", \nClientAppUsed contains \"Exchange ActiveSync\", \"No\", \nClientAppUsed contains \"Other clients\", \"Yes\", \n\"Unknown\")\n| where isLegacyAuth==\"Yes\";\nlegacyAuthentications \n| where TimeGenerated \u003e= ago(endtime)\n// Don't alert for accounts already seen using legacy auth in prior 7 days\n| join kind=leftanti (\n   legacyAuthentications \n   | where TimeGenerated between(ago(starttime) .. ago(endtime))\n) on UserPrincipalName, ClientAppUsed, AppDisplayName, IPAddress\n| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser\n| extend LocationString= strcat(tostring(LocationDetails[\"countryOrRegion\"]), \"/\", \ntostring(LocationDetails[\"state\"]), \"/\", tostring(LocationDetails[\"city\"]))\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), AttemptCount = count() \nby UserPrincipalName, ClientAppUsed, AppDisplayName, IPAddress, isLegacyAuth, tostring(OS), tostring(Browser), LocationString\n| sort by AttemptCount desc nulls last \n| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_63')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SigninLogs",
                                             "displayName":  "Login attempt by Blocked MFA user",
                                             "query":  "//An account could be blocked if there are too many failed authentication attempts in a row. This hunting query identifies if a MFA user account that is set to blocked tries to login to Azure AD.\n//\nlet timeRange = 1d;\nlet lookBack = 7d;\nlet isGUID = \"[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}\";\nlet MFABlocked = SigninLogs\n| where TimeGenerated \u003e= ago(timeRange)\n| where ResultType != \"0\" \n| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails), Status = strcat(ResultType, \": \", ResultDescription)\n| where StatusDetails =~ \"MFA denied; user is blocked\"\n| extend Unresolved = iff(Identity matches regex isGUID, true, false);\n// Lookup up resolved identities from last 7 days\nlet identityLookup = SigninLogs\n| where TimeGenerated \u003e= ago(lookBack)\n| where not(Identity matches regex isGUID)\n| summarize by UserId, lu_UserDisplayName = UserDisplayName, lu_UserPrincipalName = UserPrincipalName;\n// Join resolved names to unresolved list from MFABlocked signins\nlet unresolvedNames = MFABlocked | where Unresolved == true | join kind= inner (\n identityLookup \n) on UserId\n| extend UserDisplayName = lu_UserDisplayName, UserPrincipalName = lu_UserPrincipalName\n| project-away lu_UserDisplayName, lu_UserPrincipalName;\n// Join Signins that had resolved names with list of unresolved that now have a resolved name\nlet u_MFABlocked = MFABlocked | where Unresolved == false | union unresolvedNames;\nu_MFABlocked \n| extend OS = tostring(DeviceDetail.operatingSystem), Browser = tostring(DeviceDetail.browser)\n| extend FullLocation = strcat(Location,'|', LocationDetails.state, '|', LocationDetails.city)\n| summarize TimeGenerated = makelist(TimeGenerated), Status = makelist(Status), IPAddresses = makelist(IPAddress), IPAddressCount = dcount(IPAddress), \n  AttemptCount = count() by UserPrincipalName, UserId, UserDisplayName, AppDisplayName, Browser, OS, FullLocation , CorrelationId \n| mvexpand TimeGenerated, IPAddresses, Status\n| extend TimeGenerated = todatetime(tostring(TimeGenerated)), IPAddress = tostring(IPAddresses), Status = tostring(Status)\n| project-away IPAddresses\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserPrincipalName, UserId, UserDisplayName, Status,  IPAddress, IPAddressCount, AppDisplayName, Browser, OS, FullLocation\n| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_64')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SigninLogs",
                                             "displayName":  "Azure Active Directory signins from new locations",
                                             "query":  "//New Azure Active Directory signin locations today versus historical Azure Active Directory signin data\n//In the case of password spraying or brute force attacks one might see authentication attempts for many \n//accounts from a new location\n//\n\nlet starttime = 14d;\nlet endtime = 1d;\nlet countThreshold = 1;\nSigninLogs\n| where TimeGenerated \u003e= ago(endtime)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), perIdentityAuthCount = count() \nby Identity, locationString = strcat(tostring(LocationDetails[\"countryOrRegion\"]), \"/\", tostring(LocationDetails[\"state\"]), \"/\", \ntostring(LocationDetails[\"city\"]), \";\" , tostring(LocationDetails[\"geoCoordinates\"]))\n| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc), distinctAccountCount = count(), identityList=makeset(Identity) by locationString\n| extend identityList = iff(distinctAccountCount\u003c10, identityList, \"multiple (\u003e10)\")\n| join kind= anti (\nSigninLogs\n  | where TimeGenerated \u003e= ago(starttime) and TimeGenerated \u003c ago(endtime)\n  | project locationString= strcat(tostring(LocationDetails[\"countryOrRegion\"]), \"/\", tostring(LocationDetails[\"state\"]), \"/\", \n  tostring(LocationDetails[\"city\"]), \";\" , tostring(LocationDetails[\"geoCoordinates\"]))\n  | summarize priorCount = count() by locationString\n) \non locationString\n// select threshold above which #new accounts from a new location is deemed suspicious\n| where distinctAccountCount \u003e countThreshold\n| extend timestamp = StartTimeUtc\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_65')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SigninLogs",
                                             "displayName":  "Azure Active Directory sign-in burst from multiple locations",
                                             "query":  "//This query over Azure Active Directory sign-in activity highlights accounts associated\n//with multiple authentications from different geographical locations in a short space of time.\n//\n\nlet timeRange = ago(10d);\nlet signIns = SigninLogs\n| where TimeGenerated \u003e= timeRange\n| extend locationString= strcat(tostring(LocationDetails[\"countryOrRegion\"]), \"/\",\n tostring(LocationDetails[\"state\"]), \"/\", tostring(LocationDetails[\"city\"]))\n| where locationString != \"//\" \n// filter out signins associated with top 100 signin locations \n| join kind=anti (\nSigninLogs\n  | extend locationString= strcat(tostring(LocationDetails[\"countryOrRegion\"]), \"/\", \n  tostring(LocationDetails[\"state\"]), \"/\", tostring(LocationDetails[\"city\"]))\n  | where locationString != \"//\"\n  | summarize count() by locationString\n  | order by count_ desc\n  | take 100) on locationString ; // TODO - make this threshold percentage-based\n// We will perform a time window join to identify signins from multiple locations within a 10-minute period\nlet lookupWindow = 10m;\nlet lookupBin = lookupWindow / 2.0; // lookup bin = equal to 1/2 of the lookup window\nsignIns \n| project-rename Start=TimeGenerated \n| extend TimeKey = bin(Start, lookupBin)\n| join kind = inner (\nsignIns \n| project-rename End=TimeGenerated, EndLocationString=locationString \n  // TimeKey on the right side of the join - emulates this authentication appearing several times\n  | extend TimeKey = range(bin(End - lookupWindow, lookupBin),\n  bin(End, lookupBin), lookupBin)\n  | mvexpand TimeKey to typeof(datetime) // translate TimeKey arrange range to a column\n) on Identity, TimeKey\n| where End \u003e Start\n| project timeSpan = End - Start, Identity, locationString, EndLocationString,tostring(Start), tostring(End), UserPrincipalName\n| where locationString != EndLocationString\n| summarize by timeSpan, Identity, locationString, EndLocationString, Start, End, UserPrincipalName\n| extend timestamp = Start, AccountCustomEntity = UserPrincipalName \n| order by Identity\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_66')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SigninLogs",
                                             "displayName":  "Signin Logs with expanded Conditional Access Policies",
                                             "query":  "//Example query for SigninLogs showing how to break out packed fields.  In this case extending conditional access Policies \n//\n\nlet timeframe = 1d;\nSigninLogs \n| where TimeGenerated \u003e= ago(timeframe)\n| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser\n| extend ConditionalAccessPol0Name = tostring(ConditionalAccessPolicies[0].displayName), ConditionalAccessPol0Result = tostring(ConditionalAccessPolicies[0].result)\n| extend ConditionalAccessPol1Name = tostring(ConditionalAccessPolicies[1].displayName), ConditionalAccessPol1Result = tostring(ConditionalAccessPolicies[1].result)\n| extend ConditionalAccessPol2Name = tostring(ConditionalAccessPolicies[2].displayName), ConditionalAccessPol2Result = tostring(ConditionalAccessPolicies[2].result)\n| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails)\n| extend State = tostring(LocationDetails.state), City = tostring(LocationDetails.city)\n| extend Date = startofday(TimeGenerated), Hour = datetime_part(\"Hour\", TimeGenerated)\n| summarize count() by Date, Identity, UserDisplayName, UserPrincipalName, IPAddress, ResultType, ResultDescription, StatusCode, StatusDetails, \nConditionalAccessPol0Name, ConditionalAccessPol0Result, ConditionalAccessPol1Name, ConditionalAccessPol1Result, ConditionalAccessPol2Name, ConditionalAccessPol2Result, \nLocation, State, City\n| extend timestamp = Date, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n| sort by Date \n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_67')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SigninLogs",
                                             "displayName":  "Sign-ins from IPs that attempt sign-ins to disabled accounts",
                                             "query":  "//Identifies IPs with failed attempts to sign in to one or more disabled accounts signed in successfully to another account.\n//References: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes\n//50057 - User account is disabled. The account has been disabled by an administrator. This analytic will additionally identify the successful signed in accounts as the mapped account entities for investigation in Sentinel.\n//\nlet lookBack = 1d;\nlet threshold = 100;\nSigninLogs \n| where TimeGenerated \u003e= ago(lookBack)\n| where ResultType == \"50057\" \n| where ResultDescription == \"User account is disabled. The account has been disabled by an administrator.\" \n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), disabledAccountLoginAttempts = count(), \ndisabledAccountsTargeted = dcount(UserPrincipalName), applicationsTargeted = dcount(AppDisplayName), disabledAccountSet = makeset(UserPrincipalName), \napplicationSet = makeset(AppDisplayName) by IPAddress\n| order by disabledAccountLoginAttempts desc\n| join kind= leftouter (\n    // Consider these IPs suspicious - and alert any related  successful sign-ins\n    SigninLogs\n    | where TimeGenerated \u003e= ago(lookBack)\n    | where ResultType == 0\n    | summarize successfulAccountSigninCount = dcount(UserPrincipalName), successfulAccountSigninSet = makeset(UserPrincipalName, 15) by IPAddress\n    // Assume IPs associated with sign-ins from 100+ distinct user accounts are safe\n    | where successfulAccountSigninCount \u003c threshold\n) on IPAddress  \n// IPs from which attempts to authenticate as disabled user accounts originated, and had a non-zero success rate for some other account\n| where successfulAccountSigninCount != 0\n// Successful Account Signins occur within the same lookback period as the failed \n| extend SuccessBeforeFailure = iff(TimeGenerated \u003c StartTime, true, false) \n| project StartTime, EndTime, IPAddress, disabledAccountLoginAttempts, disabledAccountsTargeted, disabledAccountSet, applicationSet, \nsuccessfulAccountSigninCount, successfulAccountSigninSet\n| order by disabledAccountLoginAttempts\n// Break up the string of Succesfully signed into accounts into individual events\n| mvexpand successfulAccountSigninSet\n| extend AccountCustomEntity = tostring(successfulAccountSigninSet), timestamp = StartTime, IPCustomEntity = IPAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_68')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SigninLogs",
                                             "displayName":  "Same User - Successful logon for a given App and failure on another App within 1m and low distribution",
                                             "query":  "//This identifies when a user account successfully logs onto a given App and within 1 minute fails to logon to a different App.\n//This may indicate a malicious attempt at accessing disallowed Apps for discovery or potential lateral movement\n//\n\nlet timeFrame = ago(1d);\nlet logonDiff = 1m;\nlet Success = SigninLogs \n| where TimeGenerated \u003e= timeFrame \n| where ResultType == \"0\" \n| where AppDisplayName !in (\"Office 365 Exchange Online\", \"Skype for Business Online\", \"Office 365 SharePoint Online\")\n| project SuccessLogonTime = TimeGenerated, UserPrincipalName, IPAddress , SuccessAppDisplayName = AppDisplayName;\nlet Fail = SigninLogs \n| where TimeGenerated \u003e= timeFrame \n| where ResultType !in (\"0\", \"50140\") \n| where ResultDescription !~ \"Other\" \n| where AppDisplayName !in (\"Office 365 Exchange Online\", \"Skype for Business Online\", \"Office 365 SharePoint Online\")\n| project FailedLogonTime = TimeGenerated, UserPrincipalName, IPAddress , FailedAppDisplayName = AppDisplayName, ResultType, ResultDescription;\nlet InitialDataSet = \nSuccess | join kind= inner (\nFail\n) on UserPrincipalName, IPAddress \n| where isnotempty(FailedAppDisplayName)\n| where SuccessLogonTime \u003c FailedLogonTime and FailedLogonTime - SuccessLogonTime \u003c= logonDiff and SuccessAppDisplayName != FailedAppDisplayName;\nlet InitialHits = \nInitialDataSet\n| summarize FailedLogonTime = min(FailedLogonTime), SuccessLogonTime = min(SuccessLogonTime) \nby UserPrincipalName, SuccessAppDisplayName, FailedAppDisplayName, IPAddress, ResultType, ResultDescription;\n// Only take hits where there is 5 or less distinct AppDisplayNames on the success side as this limits highly active applications where failures occur more regularly\nlet Distribution =\nInitialDataSet\n| summarize count(SuccessAppDisplayName) by SuccessAppDisplayName, ResultType\n| where count_SuccessAppDisplayName \u003c= 5;\nInitialHits | join (\n   Distribution \n) on SuccessAppDisplayName, ResultType\n| project UserPrincipalName, SuccessLogonTime, IPAddress, SuccessAppDisplayName, FailedLogonTime, FailedAppDisplayName, ResultType, ResultDescription \n| extend timestamp = SuccessLogonTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_69')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-SigninLogs",
                                             "displayName":  "Failed attempt to access Azure Portal",
                                             "query":  "//Access attempts to Azure Portal from an unauthorized user.  Either invalid password or the user account does not exist.\n//\n\nlet timeRange=ago(7d);\nSigninLogs\n| where TimeGenerated \u003e= timeRange\n| where AppDisplayName contains \"Azure Portal\"\n// 50126 - Invalid username or password, or invalid on-premises username or password.\n// 50020? - The user doesn't exist in the tenant.\n| where ResultType in ( \"50126\" , \"50020\")\n| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser\n| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails)\n| extend State = tostring(LocationDetails.state), City = tostring(LocationDetails.city)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), IPAddresses = makeset(IPAddress), DistinctIPCount = dcount(IPAddress), \nmakeset(OS), makeset(Browser), makeset(City), AttemptCount = count() \nby UserDisplayName, UserPrincipalName, AppDisplayName, ResultType, ResultDescription, StatusCode, StatusDetails, Location, State\n| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName\n| sort by AttemptCount\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_70')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-Syslog",
                                             "displayName":  "Crypto currency miners EXECVE",
                                             "query":  "//This query hunts through EXECVE syslog data generated by AUOMS to find instances of crypto currency miners being\n//downloaded.  It returns a table of suspicious command lines.\n//Find more details on collecting EXECVE data into Azure Sentinel - https://techcommunity.microsoft.com/t5/azure-sentinel/hunting-threats-on-linux-with-azure-sentinel/ba-p/1344431\n//\n// Extract EventType and EventData from AUOMS Syslog message\nSyslog\n| parse SyslogMessage with \"type=\" EventType \" audit(\" * \"): \" EventData\n| project TimeGenerated, EventType, Computer, EventData \n// Extract AUOMS_EXECVE details from EventData\n| where EventType =~ \"AUOMS_EXECVE\"\n| parse EventData with * \"syscall=\" syscall \" syscall_r=\" * \" success=\" success \" exit=\" exit \" a0\" * \" ppid=\" ppid \" pid=\" pid \" audit_user=\" audit_user \" auid=\" auid \" user=\" user \" uid=\" uid \" group=\" group \" gid=\" gid \"effective_user=\" effective_user \" euid=\" euid \" set_user=\" set_user \" suid=\" suid \" filesystem_user=\" filesystem_user \" fsuid=\" fsuid \" effective_group=\" effective_group \" egid=\" egid \" set_group=\" set_group \" sgid=\" sgid \" filesystem_group=\" filesystem_group \" fsgid=\" fsgid \" tty=\" tty \" ses=\" ses \" comm=\\\"\" comm \"\\\" exe=\\\"\" exe \"\\\"\" * \"cwd=\\\"\" cwd \"\\\"\" * \"name=\\\"\" name \"\\\"\" * \"cmdline=\\\"\" cmdline \"\\\" containerid=\" containerid\n// Find wget and curl commands\n| where comm in (\"wget\", \"curl\")\n// Find command lines featuring known crypto currency miner names\n| where cmdline contains \"nicehashminer\" or cmdline contains \"ethminer\" or cmdline contains \"equihash\" or cmdline contains \"NsCpuCNMiner64\" or cmdline contains \"minergate\" or cmdline contains \"minerd\" or cmdline contains \"cpuminer\" or cmdline contains \"xmr-stak-cpu\" or cmdline contains \"xmrig\" or cmdline contains \"stratum+tcp\" or cmdline contains \"cryptonight\" or cmdline contains \"monero\" or cmdline contains \"oceanhole\" or cmdline contains \"dockerminer\" or cmdline contains \"xmrdemo\"\n| project TimeGenerated, Computer, audit_user, user, cmdline\n| extend AccountCustomEntity = user, HostCustomEntity = Computer, timestamp = TimeGenerated\n| sort by TimeGenerated desc\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_71')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-Syslog",
                                             "displayName":  "Disabled accounts using Squid proxy",
                                             "query":  "//Look for accounts that have a been recorded as disabled by AD in the previous week but are still using the proxy during \n//the current week. This query presumes the default squid log format is being used. http://www.squid-cache.org/Doc/config/access_log/\n//\n\nlet starttime = 14d;\nlet endtime = 7d;\nlet disabledAccounts = (){\nSigninLogs \n| where TimeGenerated between(ago(starttime) .. ago(endtime))\n| where ResultType == 50057\n| where ResultDescription =~ \"User account is disabled. The account has been disabled by an administrator.\" \n};\nlet proxyEvents = (){\nSyslog\n| where TimeGenerated \u003e ago(endtime)\n| where ProcessName contains \"squid\"\n| extend URL = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :]*)\",3,SyslogMessage), \n         SourceIP = extract(\"([0-9]+ )(([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3}))\",2,SyslogMessage), \n         Status = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))\",1,SyslogMessage), \n         HTTP_Status_Code = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))/([0-9]{3})\",8,SyslogMessage),\n         User = extract(\"(CONNECT |GET )([^ ]* )([^ ]+)\",3,SyslogMessage),\n         RemotePort = extract(\"(CONNECT |GET )([^ ]*)(:)([0-9]*)\",4,SyslogMessage),\n         Domain = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :\\\\/]*)\",3,SyslogMessage),\n         Bytes = toint(extract(\"([A-Z]+\\\\/[0-9]{3} )([0-9]+)\",2,SyslogMessage)),\n         contentType = extract(\"([a-z/]+$)\",1,SyslogMessage)\n| extend TLD = extract(\"\\\\.[a-z]*$\",0,Domain)\n};\nproxyEvents \n| where Status !contains 'DENIED'\n| join kind=inner disabledAccounts on $left.User == $right.UserPrincipalName\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, URLCustomEntity = URL\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_72')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-Syslog",
                                             "displayName":  "Rare process running on a Linux host",
                                             "query":  "//Looks for rare processes that are running on Linux hosts. Looks for process seen less than 14 times in last 7 days, \n// or observed rate is less than 1% of of the average for the environment and fewer than 100.\n//\nlet starttime = 7d;\nlet endtime = 1m;\nlet lookback = 30d\nlet count_threshold = 100;\nlet perc_threshold = 0.01;\nlet host_threshold = 14;\nlet basic=materialize(\n  Syslog\n    | where TimeGenerated \u003e= ago(lookback)\n    | summarize FullCount = count()\n                , Count= countif(TimeGenerated between (ago(starttime) .. ago(endtime)))\n                , min_TimeGenerated=min(TimeGenerated)\n                , max_TimeGenerated=max(TimeGenerated) \n                      by Computer, ProcessName\n    | where Count \u003e 0 and Count \u003c count_threshold);\nlet basic_avg = basic\n    | summarize Avg = avg(FullCount) by  ProcessName;\nbasic | project-away FullCount\n  | join kind=inner \nbasic_avg \n  on ProcessName | project-away ProcessName1\n  | where Count \u003c host_threshold or (Count \u003c= Avg*perc_threshold and Count \u003c count_threshold) \n  | extend HostCustomEntity=Computer\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_73')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-Syslog",
                                             "displayName":  "Linux scheduled task Aggregation",
                                             "query":  "//This query aggregates information about all of the scheduled tasks (Cron jobs) and presents the data in a chart.\n//The aggregation is done based on unique user-commandline pairs. It returns how many times a command line has\n//been run from a particular user, how many computers that pair has run on, and what percentage that is of the\n//total number of computers in the tenant.\n//\n\n// Change startdate below if you want a different timespan\nlet startdate = 7d;\n// Pull messages from Syslog-cron where the process name is \"CRON\" or \"CROND\", the severity level is info, and the SyslogMessage contains \"CMD\".\n// It also parses out the user and commandline from the message.\nlet RawCommands = Syslog \n| where TimeGenerated \u003e= ago(startdate)\n| where Facility =~ \"cron\" \n| where SeverityLevel =~ \"info\" \n| where ProcessName =~ \"CRON\" or ProcessName =~ \"CROND\"  \n| where SyslogMessage contains \"CMD \" \n| project TenantId, TimeGenerated, Computer, SeverityLevel, ProcessName, SyslogMessage\n| extend TrimmedSyslogMsg = trim_end(@\"\\)\", SyslogMessage)\n| parse TrimmedSyslogMsg with * \"(\" user  \") CMD (\" cmdline \n| project TenantId, TimeGenerated, Computer, user, cmdline; \n// Count how many times a particular commandline has been seen based on unique Computer, User, and cmdline sets\nlet CommandCount = RawCommands\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count(cmdline) by Computer, user, cmdline\n| project StartTimeUtc, EndTimeUtc, Computer, user, cmdline, CmdlineCount = count_cmdline ; \n// Count how many computers have run a particular user and cmdline pair\nlet DistComputerCount = RawCommands\n| summarize dcount(Computer) by TenantId, user, cmdline\n| project TenantId, user, cmdline, ComputerCount = dcount_Computer ; \n// Join above counts based on user and commandline pair\nlet CommandSummary = CommandCount | join (DistComputerCount) on user, cmdline\n| project StartTimeUtc, EndTimeUtc, TenantId, user, CmdlineCount, ComputerCount, cmdline ;\n// Count the total number of computers reporting cron messages in the tenant\nlet TotalComputers = Syslog\n| where Facility =~ \"cron\"\n| summarize dcount(Computer) by TenantId ;\n// Join the previous counts with the total computers count. Calculate the percentage of total computers value.\nlet FinalSummary = CommandSummary | join kind= leftouter (TotalComputers) on TenantId\n| project StartTimeUtc, EndTimeUtc, user, TimesCmdlineSeen = CmdlineCount, CompsThatHaveRunCmdline = ComputerCount, \nAsPercentOfTotalComps = round(100 * (toreal(ComputerCount)/toreal(dcount_Computer)),2), cmdline\n| order by user asc, TimesCmdlineSeen desc;\nFinalSummary \n| extend timestamp = StartTimeUtc, AccountCustomEntity = user\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_74')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-Syslog",
                                             "displayName":  "Editing Linux scheduled tasks through Crontab",
                                             "query":  "//This query shows when users have edited or replaced the scheduled tasks using crontab. The events are bucketed into 10 minute intervals \n//and all the actions that a particular used took are collected into the List of Actions. Default query is for seven days.\n//\n\n// Change startdate below if you want a different timespan\nlet startdate = 14d;\n// Pull messages from Syslog-cron logs where the process is crontab and the severity level is \"info\". Extract the User and Action information from the SyslogMessage\nSyslog \n| where TimeGenerated  \u003e= ago(startdate)\n| where Facility =~ \"cron\" \n| where ProcessName =~ \"crontab\" \n| where SeverityLevel =~ \"info\" \n| project TimeGenerated, Computer, SeverityLevel, ProcessName, SyslogMessage\n| parse SyslogMessage with * \"(\" user  \") \" Action \" (\" *\n// Only look for messages that contain edit or replace\n| where Action contains \"EDIT\" or Action contains \"REPLACE\"\n//| summarize all the actions into a single set based on 10 minute time intervals\n| summarize makeset(Action) by bin(TimeGenerated, 10m), Computer, user  \n| project EventTime10MinInterval = TimeGenerated, Computer, user, ListOfActions = set_Action \n| order by Computer asc nulls last, EventTime10MinInterval asc\n| extend timestamp = EventTime10MinInterval, AccountCustomEntity = user, HostCustomEntity = Computer\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_75')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-Syslog",
                                             "displayName":  "Squid commonly abused TLDs",
                                             "query":  "//Some top level domains (TLDs) are more commonly associated with malware for a range of reasons - including how easy domains on these TLDs are to obtain. \n//Many of these may be undesirable from an enterprise policy perspective. The clientCount column provides an initial insight into how widespread the domain \n//usage is across the estate. This query presumes the default squid log format is being used. http://www.squid-cache.org/Doc/config/access_log/\n//\n\nlet suspicious_tlds = dynamic([ \".click\", \".club\", \".download\",  \".xxx\", \".xyz\"]);\nlet timeframe = 14d;\nSyslog\n| where TimeGenerated \u003e= ago(timeframe) \n| where ProcessName contains \"squid\"\n| extend URL = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :]*)\",3,SyslogMessage), \n         SourceIP = extract(\"([0-9]+ )(([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3}))\",2,SyslogMessage), \n         Status = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))\",1,SyslogMessage), \n         HTTP_Status_Code = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))/([0-9]{3})\",8,SyslogMessage),\n         User = extract(\"(CONNECT |GET )([^ ]* )([^ ]+)\",3,SyslogMessage),\n         RemotePort = extract(\"(CONNECT |GET )([^ ]*)(:)([0-9]*)\",4,SyslogMessage),\n         Domain = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :\\\\/]*)\",3,SyslogMessage)\n| extend TLD = extract(\"\\\\.[a-z]*$\",0,Domain)\n| where TLD in (suspicious_tlds)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), clientCount = dcount(SourceIP) by TLD, User, URL\n| order by TLD asc, clientCount desc\n| extend timestamp = StartTimeUtc, AccountCustomEntity = User, URLCustomEntity = URL\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_76')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-Syslog",
                                             "displayName":  "Squid malformed requests",
                                             "query":  "//Malformed web requests are sometimes used for reconnaissance to detect the presence of network security devices.\n//Hunting for a large number of requests from a single source may assist in locating compromised hosts. Note: internal sites may\n//be detected by this query and may need excluding on a individual basis. This query presumes the default squid log format is\n//being used.\n//\n\nlet timeframe = 14d;\nSyslog\n| where TimeGenerated \u003e= ago(timeframe) \n| where ProcessName contains \"squid\"\n| extend URL = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :]*)\",3,SyslogMessage), \n         SourceIP = extract(\"([0-9]+ )(([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3}))\",2,SyslogMessage), \n         Status = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))\",1,SyslogMessage), \n         HTTP_Status_Code = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))/([0-9]{3})\",8,SyslogMessage),\n         User = extract(\"(CONNECT |GET )([^ ]* )([^ ]+)\",3,SyslogMessage),\n         RemotePort = extract(\"(CONNECT |GET )([^ ]*)(:)([0-9]*)\",4,SyslogMessage),\n         Domain = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :\\\\/]*)\",3,SyslogMessage),\n         Bytes = toint(extract(\"([A-Z]+\\\\/[0-9]{3} )([0-9]+)\",2,SyslogMessage)),\n         contentType = extract(\"([a-z/]+$)\",1,SyslogMessage)\n| extend TLD = extract(\"\\\\.[a-z]*$\",0,Domain)\n| where Domain !contains '.' and isnotempty(Domain)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), badRequestCount = count() by Domain, SourceIP, User, URL\n| order by badRequestCount desc\n| extend timestamp = StartTimeUtc, AccountCustomEntity = User, IPCustomEntity = SourceIP, URLCustomEntity = URL\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_77')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-Syslog",
                                             "displayName":  "Squid data volume timeseries anomalies",
                                             "query":  "//Malware infections or data exfiltration activity often leads to anomalies in network data volume\n//this hunting query looks for anomalies in the volume of bytes traversing a squid proxy. Anomalies require further \n//investigation to determine cause. This query presumes the default squid log format is being used.\n//\n\nlet starttime = 14d;\nlet endtime = 1d;\nlet timeframe = 1h;\nlet TimeSeriesData = \nSyslog\n| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))\n| where ProcessName contains \"squid\"\n| extend URL = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :]*)\",3,SyslogMessage), \n         SourceIP = extract(\"([0-9]+ )(([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3}))\",2,SyslogMessage), \n         Status = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))\",1,SyslogMessage), \n         HTTP_Status_Code = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))/([0-9]{3})\",8,SyslogMessage),\n         User = extract(\"(CONNECT |GET )([^ ]* )([^ ]+)\",3,SyslogMessage),\n         RemotePort = extract(\"(CONNECT |GET )([^ ]*)(:)([0-9]*)\",4,SyslogMessage),\n         Domain = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :\\\\/]*)\",3,SyslogMessage),\n         Bytes = toint(extract(\"([A-Z]+\\\\/[0-9]{3} )([0-9]+)\",2,SyslogMessage)),\n         contentType = extract(\"([a-z/]+$)\",1,SyslogMessage)\n| extend TLD = extract(\"\\\\.[a-z]*$\",0,Domain)\n| where isnotempty(Bytes)\n| make-series TotalBytesSent=sum(Bytes) on TimeGenerated from startofday(ago(starttime)) to startofday(ago(endtime)) step timeframe by ProcessName;\nTimeSeriesData\n| extend (anomalies, score, baseline) = series_decompose_anomalies(TotalBytesSent,3, -1, 'linefit')\n| extend timestamp = TimeGenerated\n| render timechart with (title=\"Squid Time Series anomalies\")\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_78')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-W3CIISLog",
                                             "displayName":  "Same IP address with multiple csUserAgent",
                                             "query":  "//This alerts when the same client IP (cIP) is connecting with more than 1 but less than 15 different useragent string (csUserAgent) in less than 1 hour.\n//We limit to 50 or less connections to avoid high traffic sites. This may indicate malicious activity as this is a method of probing an environment\n//References: Status code mappings for your convenience\n//IIS status code mapping - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0\n//Win32 Status code mapping - https://msdn.microsoft.com/library/cc231199.aspx\n//\n\nlet timeFrame = ago(1h);\nW3CIISLog\n| where TimeGenerated \u003e= timeFrame\n| where scStatus !startswith \"20\" and scStatus !startswith \"30\" and cIP !startswith \"192.168.\" and cIP != sIP and cIP != \"::1\"\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), makeset(csUserAgent), ConnectionCount = count() \nby Computer, sSiteName, sIP, sPort, cIP, csMethod\n| extend csUserAgentPerIPCount = arraylength(set_csUserAgent)\n| where  csUserAgentPerIPCount between ( 2 .. 15 ) and ConnectionCount \u003c=50\n| extend timestamp = StartTimeUtc, IPCustomEntity = cIP, HostCustomEntity = Computer\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_79')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-W3CIISLog",
                                             "displayName":  "Web shell Detection",
                                             "query":  "//Web shells are script that when uploaded to a web server can be used for remote administration. \n//Attackers often use web shells to obtain unauthorized access, escalate //privilege as well as further compromise the environment. \n//The query detects web shells that use GET requests by keyword searches in URL strings. \n//This is based out of sigma rules described //here (https://github.com/Neo23x0/sigma/blob/master/rules/web/web_webshell_keyword.yml). \n//There could be some web sites like wikis with articles on os commands and pages that include the os //commands in the URLs that might cause FP.\n//\n\nlet timeFrame = ago(1d);\nlet command = \"(?i)net(1)?(.exe)?(%20){1,}user|cmd(.exe)?(%20){1,}/c(%20){1,}\";\nW3CIISLog\n| where TimeGenerated \u003e= timeFrame\n| where csMethod == \"GET\" \n| where ( csUriQuery has \"whoami\" or csUriQuery matches regex command ) or \n        ( csUriStem has \"whoami\" or csUriStem matches regex command ) or\n        ( csReferer has \"whoami\" or csReferer matches regex command )\n| summarize StartTimeUtc = max(TimeGenerated), EndTimeUtc = min(TimeGenerated), ConnectionCount = count() \nby Computer, sSiteName, sIP, cIP, csUserName, csUriQuery, csMethod, scStatus, scSubStatus, scWin32Status\n| extend timestamp = StartTimeUtc, IPCustomEntity = cIP, HostCustomEntity = Computer, AccountCustomEntity = csUserName \n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_80')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-W3CIISLog",
                                             "displayName":  "Potential IIS brute force",
                                             "query":  "//This query shows when 1200 (20 per minute) or more failed attempts by cIP per hour occur on a given server and then a successful logon by cIP. \n//This only includes when more than 1 user agent strings is used or more than 1 port is used.\n//This could be indicative of successful probing and password brute force success on your IIS servers. \n//Feel free to adjust the threshold as needed - ConnectionCount \u003e= 1200 \n//References: Status code mappings for your convenience, also inline if the mapping is not available\n//IIS status code mapping - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0\n//Win32 Status code mapping - https://msdn.microsoft.com/library/cc231199.aspx\n//\n\nlet timeFrame = ago(1h);\nW3CIISLog\n| where TimeGenerated \u003e= timeFrame\n| where scStatus in (\"401\",\"403\")\n| where cIP !startswith \"192.168.\" and cIP != sIP and cIP != \"::1\" //and csUserName != \"-\" \n// Handling Exchange specific items in IIS logs to remove the unique log identifier in the URI\n| extend csUriQuery = iff(csUriQuery startswith \"MailboxId=\", tostring(split(csUriQuery, \"\u0026\")[0]) , csUriQuery )\n| extend csUriQuery = iff(csUriQuery startswith \"X-ARR-CACHE-HIT=\", strcat(tostring(split(csUriQuery, \"\u0026\")[0]),tostring(split(csUriQuery, \"\u0026\")[1])) , csUriQuery )\n| summarize FailStartTimeUtc = min(TimeGenerated), FailEndTimeUtc = max(TimeGenerated), makeset(sPort), makeset(csUserAgent), makeset(csUserName), csUserNameCount = dcount(csUserName), ConnectionCount = count() by Computer, sSiteName, sIP, cIP, csUriQuery, csMethod, scStatus, scSubStatus, scWin32Status\n| extend csUserAgentPerIPCount = arraylength(set_csUserAgent)\n| extend sPortCount = arraylength(set_sPort)\n| extend scStatusFull = strcat(scStatus, \".\",scSubStatus) \n// Map common IIS codes\n| extend scStatusFull_Friendly = case(\nscStatusFull == \"401.0\", \"Access denied.\",\nscStatusFull == \"401.1\", \"Logon failed.\",\nscStatusFull == \"401.2\", \"Logon failed due to server configuration.\",\nscStatusFull == \"401.3\", \"Unauthorized due to ACL on resource.\",\nscStatusFull == \"401.4\", \"Authorization failed by filter.\",\nscStatusFull == \"401.5\", \"Authorization failed by ISAPI/CGI application.\",\nscStatusFull == \"403.0\", \"Forbidden.\",\nscStatusFull == \"403.4\", \"SSL required.\",\n\"See - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0\")\n// Mapping to Hex so can be mapped using website in comments above\n| extend scWin32Status_Hex = tohex(tolong(scWin32Status)) \n// Map common win32 codes\n| extend scWin32Status_Friendly = case(\nscWin32Status_Hex =~ \"52e\", \"Logon failure: Unknown user name or bad password.\", \nscWin32Status_Hex =~ \"533\", \"Logon failure: Account currently disabled.\", \nscWin32Status_Hex =~ \"2ee2\", \"The request has timed out.\", \nscWin32Status_Hex =~ \"0\", \"The operation completed successfully.\", \nscWin32Status_Hex =~ \"1\", \"Incorrect function.\", \nscWin32Status_Hex =~ \"2\", \"The system cannot find the file specified.\", \nscWin32Status_Hex =~ \"3\", \"The system cannot find the path specified.\", \nscWin32Status_Hex =~ \"4\", \"The system cannot open the file.\", \nscWin32Status_Hex =~ \"5\", \"Access is denied.\", \nscWin32Status_Hex =~ \"8009030e\", \"SEC_E_NO_CREDENTIALS\", \nscWin32Status_Hex =~ \"8009030C\", \"SEC_E_LOGON_DENIED\", \n\"See - https://msdn.microsoft.com/library/cc231199.aspx\")\n// decode URI when available\n| extend decodedUriQuery = url_decode(csUriQuery)\n| where (ConnectionCount \u003e= 1200 and csUserAgentPerIPCount \u003e 1) or (ConnectionCount \u003e= 1200 and sPortCount \u003e 1)\n// now join back to see if there is a successful logon after so many failures\n| join (\nW3CIISLog\n| where TimeGenerated \u003e= timeFrame\n| where scStatus startswith \"20\"\n| where cIP !startswith \"192.168.\" and cIP != sIP and cIP != \"::1\"\n| extend LogonSuccessTimeUtc = TimeGenerated, Success_scStatus = scStatus\n| distinct LogonSuccessTimeUtc, Computer, sSiteName, sIP, cIP, Success_scStatus\n) on Computer, sSiteName, sIP, cIP\n| where FailEndTimeUtc \u003c LogonSuccessTimeUtc and not(LogonSuccessTimeUtc between (FailStartTimeUtc .. FailEndTimeUtc))\n| summarize makeset(LogonSuccessTimeUtc) by FailStartTimeUtc, FailEndTimeUtc, Computer, sSiteName, sIP, cIP, tostring(set_csUserName), csUserNameCount, csUriQuery, csMethod, scStatus, scSubStatus, scWin32Status, tostring(set_sPort), tostring(set_csUserAgent), ConnectionCount, csUserAgentPerIPCount, sPortCount, scStatusFull, scStatusFull_Friendly, scWin32Status_Hex, scWin32Status_Friendly\n| project FailStartTimeUtc, FailEndTimeUtc, set_LogonSuccessTimeUtc, Computer, sSiteName, sIP, cIP, set_csUserName, csUserNameCount, csUriQuery, csMethod, scStatus, scSubStatus, scWin32Status, set_sPort, set_csUserAgent, ConnectionCount, csUserAgentPerIPCount, sPortCount, scStatusFull, scStatusFull_Friendly, scWin32Status_Hex, scWin32Status_Friendly\n| extend timestamp = FailStartTimeUtc, IPCustomEntity = cIP, HostCustomEntity = Computer\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_81')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-W3CIISLog",
                                             "displayName":  "Potential IIS code injection attempt",
                                             "query":  "//Potential code injection into web server roles via scan of IIS logs. This represents an attempt to gain initial access to a system using a \n//drive-by compromise technique.  This sort of attack happens routinely as part of security scans, of both authorized and malicious types. \n//The initial goal of this detection is to flag these events when they occur and give an opportunity to review the data and filter out authorized activity.\n//\n\nlet lookback = 7d;\n// set cIP and csMethod count limit to indicate potentially noisy events, this will be listed at the top of the results \n// for any returns that are gt or equal to the default of 50\nlet cIP_MethodCountLimit = 50;\n// Exclude private ip ranges from cIP list\nlet PrivateIPregex = @'^127\\.|^10\\.|^172\\.1[6-9]\\.|^172\\.2[0-9]\\.|^172\\.3[0-1]\\.|^192\\.168\\.';\n// Exclude common csMethods, add/modify this list as needed for your environment\nlet csMethodExclude = dynamic(['GET', 'DEBUG', 'DELETE', 'LOCK', 'MKCOL', 'MOVE', 'PATCH', 'POST', 'PROPPATCH', \n'PUT', 'SEARCH', 'TRACE', 'TRACK', 'UNLOCK', 'OPTIONS', 'HEAD', 'RPC_IN_DATA', 'RPC_OUT_DATA', 'PROPFIND','BITS_POST','CCM_POST']);\n// Include in the list expected IPs where remote methods such as vuln scanning may be expected for your environment\nlet expectedIPs = dynamic(['X.X.X.X', 'Y.Y.Y.Y']);\nlet codeInjectionAttempts = W3CIISLog\n| where TimeGenerated \u003e= ago(lookback)\n| extend cIPType = iff(cIP matches regex PrivateIPregex,\"private\" ,\"public\" )\n| where cIPType ==\"public\"\n| where cIP !in (expectedIPs)\n| project TimeGenerated, cIP, csUserName, csMethod, csCookie, csHost, sIP, scStatus, csUriStem, csUriQuery, csUserAgent, csReferer \n// Throwing entire record into a single string column for attributable string matching\n| extend pak = tostring(pack_all())\n// Adding \"arr\" column containing indicators of matched suspicious strings\n| extend arr = dynamic([])\n| extend arr = iff(pak contains '\u003cscript' , array_concat(arr, pack_array('STRING MATCH : script')), arr)\n| extend arr = iff(pak contains '%3Cscript' , array_concat(arr, pack_array('STRING MATCH : script')), arr)\n| extend arr = iff(pak contains '%73%63%72%69%70%74' , array_concat(arr, pack_array('STRING MATCH : encoded script')), arr)\n| extend arr = iff(pak contains '\u003cimg' , array_concat(arr, pack_array('STRING MATCH : img')), arr)\n| extend arr = iff(pak contains '%3Cimg' , array_concat(arr, pack_array('STRING MATCH : img')), arr)\n| extend arr = iff(pak contains 'passwd' , array_concat(arr, pack_array('STRING MATCH : passwd')), arr)\n| extend arr = iff(csUserAgent contains 'nmap' , array_concat(arr, pack_array('STRING MATCH : nmap')), arr)\n| extend arr = iff(csUserAgent contains 'nessus' , array_concat(arr, pack_array('STRING MATCH : nessus')), arr)\n| extend arr = iff(csUserAgent contains 'qualys' , array_concat(arr, pack_array('STRING MATCH : qualys')), arr)\n| extend arr = iff(csMethod !in (csMethodExclude), array_concat(arr, pack_array('INVALID HTTP METHOD')), arr)\n| extend arr = iff(csUriStem == '/current_config/passwd' , array_concat(arr, pack_array('STRING MATCH : dahua scan url' )), arr)\n| extend arr = iff(csUriQuery contains '..' and csUriQuery !endswith '...', array_concat(arr, pack_array('BACKTRACK ATTEMPT IN QUERY')), arr)\n| extend arr = iff(csUriQuery contains 'http://www.webscantest.com' , array_concat(arr, pack_array('STRING MATCH : webscantest')), arr)\n| extend arr = iff(csUriQuery contains 'http://appspidered.rapid7.com' , array_concat(arr, pack_array('STRING MATCH : appspider')), arr)\n| where array_length(arr) \u003e 0\n| project-away pak;\nlet cIP_MethodHighCount = codeInjectionAttempts \n| summarize StartTimeUtc = max(TimeGenerated), EndTimeUtc = min(TimeGenerated), cIP_MethodCount = count() \nby cIP, tostring(arr), cIP_MethodCountType = \"High Count of cIP and csMethod, this may be noise\" \n| where cIP_MethodCount \u003e=  cIP_MethodCountLimit;\nlet codeInjectAtt = \ncodeInjectionAttempts \n| summarize StartTimeUtc = max(TimeGenerated), EndTimeUtc = min(TimeGenerated), cIP_MethodCount = count() \nby cIP, cIP_MethodCountType = \"Count of repeated entries, this is to reduce rowsets returned\", csMethod, \ntostring(arr), csHost, scStatus, sIP, csUriStem, csUriQuery, csUserName, csUserAgent, csCookie, csReferer;\n// union the events and sort by cIP_MethodCount to identify potentially noisy entries.  Additionally, cIP_MethodCountType \n// indicates whether it is a high count or simply a count of repeated entries\n(union isfuzzy=true\ncIP_MethodHighCount, codeInjectAtt\n| sort by cIP_MethodCount desc, cIP desc, StartTimeUtc desc)\n| extend timestamp = StartTimeUtc, IPCustomEntity = cIP, HostCustomEntity = csHost, AccountCustomEntity = csUserName, URLCustomEntity = csUriQuery\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_82')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-W3CIISLog",
                                             "displayName":  "URI requests from single client",
                                             "query":  "//This will look for connections to files on the server that are requested by only a single client. This analytic will be effective where an actor is utilising relatively static operational IP addresses. The threshold can be modified. The larger the execution window for this query the more reliable the results returned.\n//\n\nlet timeRange = 7d;\nlet clientThreshold = 1;\nlet data = W3CIISLog\n//Get script files asmx, aspx\n| where csUriStem contains \".as\"\n//Exclude local addresses, needs editing to matc your network configuration\n| where cIP !startswith \"10.\" and cIP !startswith \"fe80\" and cIP !startswith \"::\" and cIP !startswith \"127.\"\n| summarize makelist(cIP), count(TimeGenerated) by csUriStem, sSiteName, csUserAgent;\ndata\n| mvexpand list_cIP\n| distinct tostring(list_cIP), csUriStem, sSiteName, csUserAgent\n| summarize dcount(list_cIP), makelist(list_cIP), makelist(sSiteName) by csUriStem, csUserAgent\n| where dcount_list_cIP == clientThreshold \n//Uncomment to check to see if useragent is likely a browser\n| where csUserAgent startswith \"Mozilla\"\n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_83')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      },
                      {
                          "properties":  {
                                             "category":  "Sentinel-Insight-Hunting-W3CIISLog",
                                             "displayName":  "Rare User Agent strings",
                                             "query":  "//This will check for Rare User Agent strings over the last 3 days.  This can indicate potential probing of your IIS servers.\n//\n\nlet timeframe = 3d;\nW3CIISLog | where TimeGenerated \u003e= ago(timeframe)\n// The below line can be used to exclude local IPs if these create noise\n//| where cIP !startswith \"192.168.\" and cIP != \"::1\"\n| where isnotempty(csUserAgent) and csUserAgent !in~ (\"-\", \"MSRPC\")\n| extend csUserAgent_size = string_size(csUserAgent)\n| project TimeGenerated, sSiteName, sPort, csUserAgent, csUserAgent_size, csUserName , csMethod, csUriStem, sIP, cIP, scStatus, \nscSubStatus, scWin32Status, csHost \n| join (\n    W3CIISLog | where TimeGenerated \u003e= ago(timeframe) \n\t  // The below line can be used to exclude local IPs if these create noise\n    //| where cIP !startswith \"192.168.\" and cIP != \"::1\"\n    | where isnotempty(csUserAgent) and csUserAgent !in~ (\"-\", \"MSRPC\") \n    | extend csUserAgent_size = string_size(csUserAgent)\n    | summarize csUserAgent_count = count() by bin(csUserAgent_size, 1)\n    | top 20 by csUserAgent_count asc nulls last \n) on csUserAgent_size\n| project TimeGenerated, sSiteName, sPort, sIP, cIP, csUserAgent, csUserAgent_size, csUserAgent_count, csUserName , csMethod, csUriStem, \nscStatus, scSubStatus, scWin32Status, csHost\n| extend timestamp = TimeGenerated, IPCustomEntity = cIP, HostCustomEntity = csHost, AccountCustomEntity = csUserName \n",
                                             "version":  "1.0"
                                         },
                          "name":  "[concat(parameters('workspacename'), '/' , 'hunting_query_84')]",
                          "apiVersion":  "2020-03-01-preview",
                          "type":  "Microsoft.OperationalInsights/workspaces/savedSearches",
                          "location":  "[parameters('location')]"
                      }
                  ]
}
